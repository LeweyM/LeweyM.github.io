<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>09 Groups - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="09 Groups"><meta property="og:description" content="Groups Regular expressions can be grouped together using the '()' parenthesis symbols, in the same way that arithmetic constructions such as (1 + (3 * 7)) can be grouped. This hasn&rsquo;t been a problem yet because up until now, we&rsquo;ve only dealt with concatenation, and string concatenation is an associative operation. This means that grouping doesn&rsquo;t make a difference. For example, 'a' + 'b' + 'c' == 'a' + 'bc' == 'ab' + 'c' == 'abc'."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/posts/09-groups/"><meta property="article:section" content="posts"><meta property="og:see_also" content="https://leweym.github.io/posts/01-intro/"><meta property="og:see_also" content="https://leweym.github.io/posts/02-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/posts/03-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/posts/04-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/posts/05-wildcards/"><meta property="og:see_also" content="https://leweym.github.io/posts/06-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="09 Groups"><meta name=twitter:description content="Groups Regular expressions can be grouped together using the '()' parenthesis symbols, in the same way that arithmetic constructions such as (1 + (3 * 7)) can be grouped. This hasn&rsquo;t been a problem yet because up until now, we&rsquo;ve only dealt with concatenation, and string concatenation is an associative operation. This means that grouping doesn&rsquo;t make a difference. For example, 'a' + 'b' + 'c' == 'a' + 'bc' == 'ab' + 'c' == 'abc'."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/bootstrap.css><script src=https://leweym.github.io/js/main.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6FPTHJ5QN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6FPTHJ5QN")</script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/posts/01-intro/>01 Intro</a> <span class=meta></span></div><div class=post><a href=/posts/02-getting-into-some-code/>02 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/posts/03-starting-the-compiler/>03 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/posts/04-testing-fuzzing-and-fixing-things/>04 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/posts/05-wildcards/>05 Wildcards</a> <span class=meta></span></div><div class=post><a href=/posts/06-pretty-vizualizations/>06 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/posts/07-branches/>07 Branches</a> <span class=meta></span></div><div class=post><a href=/posts/08-epsilons/>08 Epsilons</a> <span class=meta></span></div><div class=post><span>09 Groups</span></div><div class=post><a href=/posts/10-modifiers/>10 Modifiers</a> <span class=meta></span></div></div></div><br><div class=post-header><h1 class=title>09 Groups</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#groups>Groups</a></li><li><a href=#parsing-groups>Parsing groups</a></li><li><a href=#the-stack-parser>The Stack Parser</a></li><li><a href=#parsing-nested-structures>Parsing Nested Structures</a></li><li><a href=#compiling-groups>Compiling groups</a></li></ul></nav></aside><div class=markdown><h2 id=groups>Groups</h2><p>Regular expressions can be grouped together using the <code>'()'</code> parenthesis symbols, in the same way that arithmetic constructions such as <code>(1 + (3 * 7))</code> can be grouped. This hasn&rsquo;t been a problem yet because up until now, we&rsquo;ve only dealt with concatenation, and string concatenation is an associative operation. This means that grouping doesn&rsquo;t make a difference. For example, <code>'a' + 'b' + 'c' == 'a' + 'bc' == 'ab' + 'c' == 'abc'</code>.</p><p>However, our <code>OR '|'</code> operation is non-associative. For example, the following regular expressions are not equivalent: <code>ab|c != a(b|c)</code>.</p><p>This is the reason for the fuzzing error we&rsquo;re seeing.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>--- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	fsm_test.go:142: Mismatch - 
</span></span><span style=display:flex><span>		Regex: <span style=color:#d14>&#39;1(|)&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 31287c29<span style=color:#000;font-weight:700>)</span>, 
</span></span><span style=display:flex><span>		Input: <span style=color:#d14>&#39;0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 30<span style=color:#000;font-weight:700>)</span> 
</span></span><span style=display:flex><span>		-&gt; 
</span></span><span style=display:flex><span>		Go Regex Pkg: <span style=color:#d14>&#39;false&#39;</span>, 
</span></span><span style=display:flex><span>		Our regex result: <span style=color:#d14>&#39;true&#39;</span>
</span></span></code></pre></div><p>Our regex compiler is interpreting <code>1(|)</code> as <code>1|</code>, which produce very different outcomes. Let&rsquo;s add a test to represent this case.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestFSMAgainstGoRegexPkg(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                {&#34;branch with shared characters&#34;, &#34;dog|dot&#34;, &#34;dot&#34;},
</span></span><span style=display:flex><span>                {&#34;branch with right side empty&#34;, &#34;a|&#34;, &#34;&#34;},
</span></span><span style=display:flex><span>                {&#34;branch with left side empty&#34;, &#34;|a&#34;, &#34;&#34;},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               // group
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;word followed by group&#34;, &#34;1(|)&#34;, &#34;0&#34;},
</span></span></span></code></pre></div><p>Now let&rsquo;s fix this by taking into account the <code>()</code> symbols and breaking the regular expression into groups, starting with the parser.</p><h2 id=parsing-groups>Parsing groups</h2><p>Let&rsquo;s add a test to our parser to define what we want to produce.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestParser(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span><span style=color:#000;background-color:#dfd>+               {name: &#34;groups&#34;, input: &#34;a(b|c)&#34;, expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       CharacterLiteral{Character: &#39;a&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       &amp;Branch{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;b&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;c&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span></code></pre></div><p>This should be failing. We can see from our nicely parsed output that what is being produced is not correct.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#000;font-weight:700>===</span> RUN   TestParser/groups
</span></span><span style=display:flex><span>    parser_test.go:64: Expected:
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        --Group
</span></span><span style=display:flex><span>        ----CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;a&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        ----Branch
</span></span><span style=display:flex><span>        --------Group
</span></span><span style=display:flex><span>        ------------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;b&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        --------Group
</span></span><span style=display:flex><span>        ------------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;c&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Got:
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        --Branch
</span></span><span style=display:flex><span>        ----Group
</span></span><span style=display:flex><span>        --------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;a&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        --------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;b&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        ----Group
</span></span><span style=display:flex><span>        --------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;c&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>We can see that we&rsquo;re still creating a single branch with <code>'ab'</code> on the left and <code>'c'</code> on the right. What we want is a group with <code>'a'</code> concatenated onto a branch with <code>'b'</code> on the left and <code>'c'</code> on the right.</p><p>Fixing the parser will require some changes. Instead of using a single root <code>Node</code>, we now need to maintain multiple root <code>Nodes</code> depending on how deep we are in the nested parenthesis. In order to keep track of this, we&rsquo;re going to use a Stack.</p><h2 id=the-stack-parser>The Stack Parser</h2><p>First, let&rsquo;s add a basic stack data structure to our Parser.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> type Parser struct {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       tokens []token
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       fsmStack []CompositeNode
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       tokens   []token
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> func NewParser(tokens []token) *Parser {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       return &amp;Parser{tokens: tokens}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       return &amp;Parser{fsmStack: []CompositeNode{}, tokens: tokens}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span></code></pre></div><p>The stack is simply a Go slice of <code>CompositeNodes</code>. Stacks work by allowing us to <code>push</code> and <code>pop</code> items off of the top of the stack, you can imagine this as a like a stack of papers - you can add to the pile, or take one off the top.</p><p>Let&rsquo;s add some convenience methods to <code>pushing</code> and <code>popping</code> to our stack.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// parser.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Parser) <span style=color:#900;font-weight:700>pop</span>() CompositeNode {  
</span></span><span style=display:flex><span>   pop <span style=color:#000;font-weight:700>:=</span> p.fsmStack[<span style=color:#0086b3>len</span>(p.fsmStack)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>]  
</span></span><span style=display:flex><span>   p.fsmStack = p.fsmStack[:<span style=color:#0086b3>len</span>(p.fsmStack)<span style=color:#000;font-weight:700>-</span><span style=color:#099>1</span>]  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> pop  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Parser) <span style=color:#900;font-weight:700>push</span>(g CompositeNode) {  
</span></span><span style=display:flex><span>   p.fsmStack = <span style=color:#0086b3>append</span>(p.fsmStack, g)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now that we have a stack, let&rsquo;s refactor our original code to use this instead of the single root <code>Node</code> we had before.</p><p>In order to keep the same behaviour as before, we simply need to <code>pop</code> a node off the stack, make some change, then <code>push</code> the node back on.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (p *Parser) Parse() Node {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       var root CompositeNode
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       root = &amp;Group{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       p.pushNewGroup()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> 
</span></span><span style=display:flex><span>        for _, t := range p.tokens {
</span></span><span style=display:flex><span>                switch t.symbol {
</span></span><span style=display:flex><span>                case Character:
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       root.Append(CharacterLiteral{Character: t.letter})
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       node := p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       node.Append(CharacterLiteral{Character: t.letter})
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       p.push(node)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                case AnyCharacter:
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       root.Append(WildcardLiteral{})
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       node := p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       node.Append(WildcardLiteral{})
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       p.push(node)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                case Pipe:
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       switch b := root.(type) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       node := p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       switch b := node.(type) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                        case *Branch:
</span></span><span style=display:flex><span>                                b.Split()
</span></span><span style=display:flex><span>                        default:
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                               root = &amp;Branch{ChildNodes: []Node{root, &amp;Group{}}}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                               node = &amp;Branch{ChildNodes: []Node{node, &amp;Group{}}}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                        }
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       p.push(node)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       return root
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       return p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+}
</span></span></span></code></pre></div><p>This includes a small convenience method for <code>pushing</code> a new <code>Group</code> node to the stack.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// parser.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Parser) <span style=color:#900;font-weight:700>pushNewGroup</span>() {  
</span></span><span style=display:flex><span>   p.<span style=color:#900;font-weight:700>push</span>(<span style=color:#000;font-weight:700>&amp;</span>Group{})  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We should now have reached feature parity with our old implementation.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> You can test this out by running the tests, they should fail in the same way.</p><h2 id=parsing-nested-structures>Parsing Nested Structures</h2><p>Now that we have a stack data structure, let&rsquo;s take advantage of it to parse nested groups.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (p *Parser) Parse(tokens []token) Node {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>				for _, t := range tokens {  
</span></span><span style=display:flex><span>				   switch t.symbol {  
</span></span><span style=display:flex><span>				   case Character:  
</span></span><span style=display:flex><span>				      node := p.pop()  
</span></span><span style=display:flex><span>				      node.Append(CharacterLiteral{Character: t.letter})  
</span></span><span style=display:flex><span>				      p.push(node)  
</span></span><span style=display:flex><span>				   case AnyCharacter:  
</span></span><span style=display:flex><span>				      node := p.pop()  
</span></span><span style=display:flex><span>				      node.Append(WildcardLiteral{})  
</span></span><span style=display:flex><span>				      p.push(node)  
</span></span><span style=display:flex><span>				   case Pipe:  
</span></span><span style=display:flex><span>				      node := p.pop()  
</span></span><span style=display:flex><span>				      switch b := node.(type) {  
</span></span><span style=display:flex><span>				      case *Branch:  
</span></span><span style=display:flex><span>				         b.Split()  
</span></span><span style=display:flex><span>				      default:  
</span></span><span style=display:flex><span>				         node = &amp;Branch{ChildNodes: []Node{node, &amp;Group{}}}  
</span></span><span style=display:flex><span>				      }  
</span></span><span style=display:flex><span>				      p.push(node)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                  case LParen:
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     p.pushNewGroup()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                  case RParen:
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     inner := p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     outer := p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     outer.Append(inner)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     p.push(outer)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>Let&rsquo;s walk through these new cases.</p><p>When we encounter a <code>LParen</code> <code>'('</code> opening parenthesis symbol, we want to start a new group. In this case, we simply push a new group onto the stack. This new group will then be picked up and used when other symbols or characters are processed. You can think of this as it becoming the new root <code>Node</code>, at least temporarily.</p><p>When we encounter a <code>RParen ')'</code> closing parenthesis symbol, the case is slightly more complicated. We want to take the <code>Node</code> at the top of the stack, append it to the next <code>Node</code> in the stack, and then <code>push</code> those combined <code>Nodes</code> at back onto the stack. You can think of this as <em>reducing</em> the top two elements of the stack into a single <code>Node</code>, which will become the new root <code>Node</code>.</p><p>Let&rsquo;s look at a visual example.</p><p>We&rsquo;ll parse the expression <code>"a(b|c)"</code></p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group)
end
end
subgraph stack
root --> *outer-group
end</div><p>When we start the parser, a <code>Group</code> will be created which represents the whole expression. We&rsquo;ll call this <code>outer-group</code>. The stack will be initialized with a pointer to <code>outer-group</code>.</p><p>After processing <code>'a'</code>, the parser will look like this.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
end
subgraph stack
root --> *outer-group
end</div><p>A <code>CharacterLiteral(a)</code> is simply appended to the group on top of the stack; <code>outer-group</code>.</p><p>When an opening parenthesis <code>'('</code> symbol is encountered, a new group, which we&rsquo;ll call <code>inner-group</code>, will be created, and a pointer to it will be pushed onto the stack.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
3(inner-group)
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-group
end</div><p>Now, when <code>'b'</code> is processed, it will be appended to the new <code>inner-group</code> <code>Node</code> as it is the last <code>Node</code> on the stack.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
3(inner-group) --> 4[b]
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-group
end</div><p>The branch symbol <code>|</code> will convert the top node on the stack into a branch, add the group as a child of the branch, add a new group, and push the branch pointer onto the stack:</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
5(inner-branch) -->
3(inner-group) --> 4[b]
5(inner-branch) --> 6(inner-group-2)
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-branch
end</div><p>And now the next character symbol <code>'c'</code> will be applied to top <code>Node</code> of the stack - <code>inner-branch</code>, which will apply it to its last child - <code>inner-group-2</code></p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
5(inner-branch) -->
3(inner-group) --> 4[b]
5(inner-branch) --> 6(inner-group-2)
6 --> 7[c]
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-branch
end</div><p>Finally, we encounter the closing parenthesis symbol <code>)</code>. This will pop <code>inner-branch</code> and <code>outer-group</code> from the stack, append <code>inner-branch</code> to <code>outer-group</code>, and then push the pointer to <code>outer-group</code> back onto the stack.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
1 -->
5(inner-branch) -->
3(inner-group) --> 4[b]
5(inner-branch) --> 6(inner-group-2)
6 --> 7[c]
end
end
subgraph stack
root --> *outer-group
end</div><p>As we&rsquo;ve reached the end of the expression, we simply pop the last element off the stack - <code>outer-group</code> and return it.</p><p>The power of using the <code>stack</code> data structures should be evident here. In our example, we only went two levels deep - the outer group and the inner group - but there&rsquo;s no reason that we couldn&rsquo;t go 3, 4, or any number of levels deep.</p><p>The stack takes care of &lsquo;remembering&rsquo; the previous levels, so we only need to care about processing the innermost level, then reduce the top two levels into one when we collapse a group. Because of this behaviour, stacks are particularly useful for parsing nested structures of arbitrary depth.</p><p>That should be enough to get our test to pass!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#000;font-weight:700>===</span> RUN   TestFSMAgainstGoRegexPkg/concatenated_word_with_grouped_branch
</span></span><span style=display:flex><span>--- PASS: TestFSMAgainstGoRegexPkg <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Let&rsquo;s run our fuzzer again and see if we&rsquo;re missing something.</p><p>Our fuzzer finds an interesting error.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>fuzz: elapsed: 0s, gathering baseline coverage: 5/664 completed
</span></span><span style=display:flex><span>--- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.07s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    --- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        fsm_test.go:144: Mismatch - 
</span></span><span style=display:flex><span>            Regex: <span style=color:#d14>&#39;(((()0))0)&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 28282828293029293029<span style=color:#000;font-weight:700>)</span>, 
</span></span><span style=display:flex><span>            Input: <span style=color:#d14>&#39;0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 30<span style=color:#000;font-weight:700>)</span> 
</span></span><span style=display:flex><span>            -&gt; 
</span></span><span style=display:flex><span>            Go Regex Pkg: <span style=color:#d14>&#39;false&#39;</span>, 
</span></span><span style=display:flex><span>            Our regex result: <span style=color:#d14>&#39;true&#39;</span>
</span></span></code></pre></div><p>I think I can reduce this error into one a bit more manageable, which I&rsquo;ll add as a test case.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestFSMAgainstGoRegexPkg(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span> 
</span></span><span style=display:flex><span>                // group
</span></span><span style=display:flex><span>                {&#34;word followed by group&#34;, &#34;1(|)&#34;, &#34;0&#34;},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;empty group concatenation&#34;, &#34;(()0)0&#34;, &#34;0&#34;},
</span></span></span></code></pre></div><p>We can understand this error by looking at the <code>merge</code> function when compiling empty groups.</p><h2 id=compiling-groups>Compiling groups</h2><p>Let&rsquo;s take a look at our merge function code.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// adds the transitions of other State (s2) to this State (s).//  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// warning: do not use if State s2 has any incoming transitions.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>merge</span>(s2 <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(s2.incoming) <span style=color:#000;font-weight:700>!=</span> <span style=color:#099>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;State (%+v) cannot be merged if it has any incoming transitions. It has incoming transitions from the following states; %+v&#34;</span>, <span style=color:#000;font-weight:700>*</span>s2, s.incoming))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> s2.transitions {  
</span></span><span style=display:flex><span>      <span style=color:#998;font-style:italic>// 1. copy s2 transitions to s  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>      s.<span style=color:#900;font-weight:700>addTransition</span>(t.to, t.predicate, t.debugSymbol)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 2. remove s2  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   s2.<span style=color:#0086b3>delete</span>()  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This works by taking the transitions of <code>s2</code> and copying them all over to <code>s</code>, then <em>deleting</em> <code>s2</code>.</p><p>Let&rsquo;s remind ourselves visually of how this works.</p><div class=mermaid>graph LR
0((s)) -."merge".-1((s))
1((s2)) --"a"--> 2((a))</div><p>Becomes&mldr;</p><div class=mermaid>graph LR
10((s)) --"a"--> 20((a))
30((s2)) --"a"--> 20((a))</div><p>And then <code>State s2</code> is deleted</p><div class=mermaid>graph LR
10((s)) --"a"--> 20((a))</div><p>The problem is that we have a hidden assumption here - that <strong>s2 has one or more transitions</strong>. If <code>s2</code> doesn&rsquo;t have any transitions, then this type of merge doesn&rsquo;t work, as there are no transitions to copy. This is what&rsquo;s happening when we try to concatenate to an empty string in the regular expression <code>(()0)0</code>, the merge between <code>()</code> and <code>0</code> simply breaks down.</p><p>What we need is a way of saying &ldquo;being in state S is equivalent to being in state S2&rdquo;, and epsilons do just that.</p><p>We could modify our <code>merge</code> method to conditionally join the two states with an epsilon in the case that <code>s2</code> has no transitions. This would work for our current case, but it turns out there&rsquo;s a more general solution here. We can simply join all a <code>Groups</code> child components with epsilon transitions instead of by using the <code>merge</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (g *Group) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>		startState := State{}  
</span></span><span style=display:flex><span>		currentTail := &amp;startState
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        for _, expression := range g.ChildNodes {
</span></span><span style=display:flex><span>                nextStateHead, nextStateTail := expression.compile()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               currentTail.addEpsilon(nextStateHead)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span><span style=color:#000;background-color:#fdd>-               currentTail.merge(nextStateHead)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span>                currentTail = nextStateTail
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		return &amp;startState, currentTail
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This works because it says &ldquo;The end of <code>childNode</code> A is equivalent to the beginning of <code>childNode</code> B&rdquo;. Let&rsquo;s see what our visualizer shows us;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>go run ./... v8 draw <span style=color:#d14>&#34;abc&#34;</span> <span style=color:#d14>&#34;abc&#34;</span>  
</span></span></code></pre></div><p><img src=/img/doubled-with-epsilon-demo.gif alt=doubled-with-epsilon-demo.gif></p><p>We can see the compiled <code>childNodes</code> in our simple example.</p><ul><li><code>State 0</code> → starting state</li><li><code>State 1 - State 2</code> → compiled <code>childNode('a')</code></li><li><code>State 3 - State 4</code> → compiled <code>childNode('b')</code></li><li><code>State 5 - State 6</code> → compiled <code>childNode('c')</code></li></ul><p>When these are chained together using epsilon transitions, the effect is the equivalent of merging the states pairs <code>(0,1)</code>, <code>(2,3)</code> and <code>(4,5)</code>.</p><p>This is an <strong>excellent tool for state machine composition</strong>, because <strong>it allows us to chain together any two state machines, regardless of how they work internally</strong>. We can have two arbitrarily complex state machines, and, as long as the last state of one is joined to the first state of the other with an epsilon transition, we can consider them as one concatenated state machine.</p><p>It does, however, mess up our visualizations for simple string concatenations such as <code>'abc'</code>, so I think it&rsquo;s worth making a small exception for chaining together strings of <code>CharacterLiteral</code> nodes.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (g *Group) compile() (head *State, tail *State) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span> 
</span></span><span style=display:flex><span>        for _, expression := range g.ChildNodes {
</span></span><span style=display:flex><span>                nextStateHead, nextStateTail := expression.compile()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               _, isChar := expression.(CharacterLiteral)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               if isChar {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       currentTail.merge(nextStateHead)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               } else {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       currentTail.addEpsilon(nextStateHead)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span><span style=color:#000;background-color:#fdd>-               currentTail.merge(nextStateHead)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span>                currentTail = nextStateTail
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>This gives us a clearer picture for simple string concatenation, but our tests still pass!</p><p><img src=/img/abc-regex-demo-2.gif alt=abc-regex-demo-2.gif></p><p>So our tests are now passing, let&rsquo;s go back to our fuzzer.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>--- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.14s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    --- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        fsm_test.go:145: Mismatch - 
</span></span><span style=display:flex><span>            Regex: <span style=color:#d14>&#39;(|)1&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 287c2931<span style=color:#000;font-weight:700>)</span>, 
</span></span><span style=display:flex><span>            Input: <span style=color:#d14>&#39;0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 30<span style=color:#000;font-weight:700>)</span> 
</span></span><span style=display:flex><span>            -&gt; 
</span></span><span style=display:flex><span>            Go Regex Pkg: <span style=color:#d14>&#39;false&#39;</span>, 
</span></span><span style=display:flex><span>            Our regex result: <span style=color:#d14>&#39;true&#39;</span>
</span></span></code></pre></div><p>Interestingly, this looks very similar to our previously failing case of <code>1(|)</code>. Let&rsquo;s fix it.</p><h3 id=fixing-the-branch-compiler>Fixing the Branch compiler</h3><p>First, a test case.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestFSMAgainstGoRegexPkg(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                {&#34;branch with shared characters&#34;, &#34;dog|dot&#34;, &#34;dot&#34;},
</span></span><span style=display:flex><span>                {&#34;branch with right side empty&#34;, &#34;a|&#34;, &#34;&#34;},
</span></span><span style=display:flex><span>                {&#34;branch with left side empty&#34;, &#34;|a&#34;, &#34;&#34;},
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>                // group
</span></span><span style=display:flex><span>                {&#34;word followed by group&#34;, &#34;1(|)&#34;, &#34;0&#34;},
</span></span><span style=display:flex><span>                {&#34;empty group concatenation&#34;, &#34;(()0)0&#34;, &#34;0&#34;},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;group followed by word&#34;, &#34;(|)1&#34;, &#34;0&#34;},
</span></span></span></code></pre></div><p>Let&rsquo;s use our visualizer to check the FSM.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>go run ./... v8 draw <span style=color:#d14>&#34;(|)1&#34;</span>
</span></span></code></pre></div><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
1((1)) -."ε".-> 2((2))
1((1)) -."ε".-> 3((3))
1((1)) --"1"--> 4((4))</div><p>Well, that&rsquo;s clearly not correct. It seems that the compiled <code>CharacterLiteral</code> node for <code>'1'</code> is being added as a third branch to the compiled <code>Branch</code> node <code>'(|)'</code>.</p><p>The reason for this is in the <code>Branch</code> struct <code>compile</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go 
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (b <span style=color:#000;font-weight:700>*</span>Branch) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, expression <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> b.ChildNodes {  
</span></span><span style=display:flex><span>      nextStateHead, _ <span style=color:#000;font-weight:700>:=</span> expression.<span style=color:#900;font-weight:700>compile</span>()  
</span></span><span style=display:flex><span>      startState.<span style=color:#900;font-weight:700>addEpsilon</span>(nextStateHead)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> startState, startState  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As we can see from the <code>return</code> statement, we are not passing back the last <code>State</code> of the compiled <code>Node</code>. In fact, there is no last <code>State</code>! To illustrate the problem, which is the last <code>State</code> in the following FSM?</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
0((0)) --"b"--> 2((2))
0((0)) --"c"--> 3((3))</div><p>Both <code>States</code> 1, 2 and 3 could all be considered the last <code>State</code>, how can we decide? The answer, again, is epsilon transitions. Using epsilons, we can say that <code>State 1,2</code> and <code>3</code> are all equivalent to a new <code>State</code>, <code>State 4</code>, which is the last <code>State</code> of the FSM!</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
0((0)) --"b"--> 2((2))
0((0)) --"c"--> 3((3))
1((1)) -."ε".-> 4((4))
2((2)) -."ε".-> 4((4))
3((3)) -."ε".-> 4((4))</div><p>The behaviour is exactly the same, only the composition becomes easier.</p><p>Let&rsquo;s add this to the code.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> func (b *Branch) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startState := &amp;State{}
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       endState := &amp;State{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        for _, expression := range b.ChildNodes {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               nextStateHead, _ := expression.compile()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+               nextStateHead, tail := expression.compile()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                startState.addEpsilon(nextStateHead)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               tail.addEpsilon(endState)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       return startState, startState
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       return startState, endState
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span></code></pre></div><p>And let&rsquo;s check our generated FSM again.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>go run ./... v8 draw <span style=color:#d14>&#34;(|)1&#34;</span>
</span></span></code></pre></div><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
1((1)) -."ε".-> 2((2))
1((1)) -."ε".-> 5((5))
2((2)) -."ε".-> 3((3))
3((3)) --"1"--> 4((4))
5((5)) -."ε".-> 3((3))</div><p>That&rsquo;s better, and our tests should now be green!</p><div class="notices note"><p>It should be quite clear that the above FSM does a lot of unnecessary work. In fact, all the epsilon transitions could be eliminated and the FSM would still be correct! There are ways to reduce this unnecessary bloat, and hopefully I&rsquo;ll get around to optimization. For now, correctness is enough for me.</p></div><p>Running our fuzzer again confirms that all is well! I think it&rsquo;s worth taking some time now to play around a bit and try out some complex examples, just to see what kind of FSM we generate. For example, let&rsquo;s try the following command;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>go run ./... v8 draw <span style=color:#d14>&#34;(a(b|c|d|e)((f)|g)&#34;</span> <span style=color:#d14>&#34;acg&#34;</span>
</span></span></code></pre></div><p>We get the following visualization.</p><p><img src=/img/complex-branch-epsilon-demo.gif alt=complex-branch-epsilon-demo.gif></p><p>Try out different inputs and see what the flow of state activation looks like for each one. Notice that the epsilon transitions simply pass activation from one state to another, effectively making two states equivalent.</p><p>We can now move on to other regular expression constructs, such as modifiers!</p><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v8>here</a></p></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This is known as a &ldquo;prepartory refactor&rdquo;, in which we refactor our code in order to prepare for the additional of some feature. Tests are very useful here for validating that our refactoring didn&rsquo;t cause any changes to the logic.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p>Previous: <a href=/posts/08-epsilons/>08 Epsilons</a><span class=meta></span></p><p>Next: <a href=/posts/10-modifiers/>10 Modifiers</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>