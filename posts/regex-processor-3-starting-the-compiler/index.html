<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Regex Processor 3 Starting the compiler | Lewis Metcalf</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
 Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states.">
<meta name=generator content="Hugo 0.91.2">
<meta name=robots content="noindex, nofollow">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Regex Processor 3 Starting the compiler">
<meta property="og:description" content="Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
 Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://LeweyM.github.io/posts/regex-processor-3-starting-the-compiler/"><meta property="article:section" content="posts">
<meta itemprop=name content="Regex Processor 3 Starting the compiler">
<meta itemprop=description content="Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
 Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states.">
<meta itemprop=wordCount content="1886">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Regex Processor 3 Starting the compiler">
<meta name=twitter:description content="Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
 Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states.">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Lewis Metcalf
</a>
<div class="flex-l items-center">
<div class=ananke-socials>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Regex Processor 3 Starting the compiler</h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a <strong>compiler</strong>.</p>
<h3 id=compiling-a-finite-state-machine>Compiling a Finite State Machine</h3>
<p>We can break down the previous example of writing an FSM for the regular expression <code>abc</code> into at least 2 discrete steps;</p>
<ol>
<li>Take the string <code>abc</code> and create a linked list of <code>'states'</code> with conditional transitions to other states.</li>
<li>Process the input by moving through the states.</li>
</ol>
<p>We&rsquo;ll call these steps <code>compile</code> and <code>evaluate</code> respectively.</p>
<p>So far, we&rsquo;ve only looked at the <code>evaluate</code> step, where we take an already made FSM and process an input string by moving through its states. Now we&rsquo;ll look at the <code>compile</code> step.</p>
<p><code>compile</code> in this context, means turning a string of characters that represent a valid regular expression into a linked list of states; a finite state machine. For this, we will create a <code>Compiler</code> struct with a <code>Compile</code> method which takes a string and returns a <code>*State</code> representing the first <code>State</code> of the FSM, the <code>root</code> or <code>head</code> <code>State</code>.</p>
<p>Let&rsquo;s do even more decomposition of this problem and break the compilation step into three phases;</p>
<ol>
<li>lexing</li>
<li>parsing</li>
<li>compiling</li>
</ol>
<p>Let&rsquo;s go through these 3 steps in detail.</p>
<h3 id=lexing>Lexing</h3>
<p>Before we start turning strings into complex abstract objects, it helps to turn them into something a bit easier to work with. In the &lsquo;Lexing&rsquo; stage, that&rsquo;s what we do. We simply convert the different types of characters into <code>tokens</code> which can be more easily interpreted by our program.</p>
<h3 id=parsing>Parsing</h3>
<p>Once we have our <code>tokens</code>, we want to build something called an &lsquo;Abstract Syntax Tree&rsquo; - or an <code>AST</code> for short. The <code>AST</code> is a tree which represents the <em>hierarchical relationship</em> of the regular expression. In other words, in this stage we describe the <strong>structure</strong> of the expression.</p>
<p>An example of the structure of regular expression <code>(cat)</code> might look like this;</p>
<p><img src=/img/Pasted-image-20220807173722.png alt=Pasted-image-20220807173722.png></p>
<p>This tree shows the relationship between a <code>group</code> (whatever is inside the parenthesis) and the three <code>char</code> literals which make up the expression <code>cat</code>. To simplify things, we&rsquo;re going to imagine that all regular expressions exist inside a top-level <code>group</code>, so <code>cat</code> is equivalent to <code>(cat)</code>.</p>
<p>This hierarchy can become more complicated when things like nested groups or <code>branches</code> are involved. For example, the <code>AST</code> for <code>(ca(r|t)s)</code> looks like this;</p>
<p><img src=/img/Pasted-image-20220807173959.png alt=Pasted-image-20220807173959.png></p>
<p>The important thing to know about this step is that here we are describing the <strong>structure</strong> of the expression, and that this structure is <strong>recursive</strong>. We can isolate any node and process its children, without needing knowledge from elsewhere in the tree. In other words, each <strong>subtree</strong> can be treated in the same way as the <strong>tree</strong>, which is very useful in reducing complexity.</p>
<p>Having this structure will make our lives a lot easier in the next step.</p>
<h3 id=compile>Compile</h3>
<p>Here, we actually build the <code>States</code> from the <code>AST</code> we created in the previous step.</p>
<p>The end result should be a linked list of <code>States</code> which should represent our regular expression, and a reference to the root <code>State</code>. The way we produce this from our <code>AST</code> is by asking each node to produce an FSM, which will in-turn ask any child nodes to produce an FSM and compose them together, until we reach the leaf nodes - which have no children - and the process ends.</p>
<p>This is where we see the power of recursive structures, as each node must produce an FSM, but nested structures don&rsquo;t need to know anything about how their children produce FSMs - in fact those children might be nested structures themselves. This is a very powerful and flexible concept, and very useful for what we&rsquo;re trying to do now.</p>
<p>Now that we&rsquo;ve described our three phases, let&rsquo;s jump into some code.</p>
<h3 id=coding-the-lexer>Coding the lexer</h3>
<p>In this implementation, we&rsquo;re going to support a subset of regex special characters;</p>
<pre tabindex=0><code>().*?+|
</code></pre><p>For simplicity, we&rsquo;re not going to support escaped characters such as <code>\?</code>. Any character not in the set above is to be considered a character literal.</p>
<p>Let&rsquo;s define these special characters as <code>symbols</code>.</p>
<pre tabindex=0><code>type symbol int

const (
	AnyCharacter symbol = iota
	Pipe
	LParen
	RParen
	Character
	ZeroOrMore
	OneOrMore
	ZeroOrOne
)
</code></pre><p>Notice we also include the symbol <code>character</code> which represents any character which is not a special character.</p>
<p>Using these <code>symbols</code>, we can create a <code>token</code> struct which contains information on the type of symbol, and the character itself, if necessary.</p>
<pre tabindex=0><code>type token struct {  
   symbol symbol  
   letter rune  
}
</code></pre><p>Now we simply need to loop through the regular expression string and map the characters to our tokens.</p>
<pre tabindex=0><code>func lex(input string) []token {  
   var tokens []token  
   i := 0  
   for i &lt; len(input) {  
      tokens = append(tokens, lexRune(rune(input[i])))  
      i++  
   }  
   return tokens  
}  
  
func lexRune(r rune) token {  
   var s token  
   switch r {  
   case '(':  
      s.symbol = LParen  
   case ')':  
      s.symbol = RParen  
   case '.':  
      s.symbol = AnyCharacter  
   case '|':  
      s.symbol = Pipe  
   case '*':  
      s.symbol = ZeroOrMore  
   case '+':  
      s.symbol = OneOrMore  
   case '?':  
      s.symbol = ZeroOrOne  
   default:  
      s.symbol = Character  
      s.letter = r  
   }  
   return s  
}
</code></pre><p>That&rsquo;s really all there is to it. Now instead of a string of characters, we have our own defined <code>tokens</code> to work with.</p>
<p>We&rsquo;ll now use those <code>tokens</code> to build our <code>AST</code></p>
<h3 id=coding-the-parser>Coding the parser</h3>
<p>For our simple example of parsing the regular expression <code>abc</code>, we just need two types of <code>AST</code>node: <code>Group</code> and <code>CharacterLiteral</code>.</p>
<p>Let&rsquo;s remind ourselves quickly of how these AST nodes relate to each other with our <code>AST</code> diagram.</p>
<p><img src=/img/Pasted-image-20220807173722.png alt=Pasted-image-20220807173722.png></p>
<p>A <code>group</code> <strong>contains</strong> three child nodes. The child nodes are <code>characterLiterals</code> and are the <strong>leaf nodes</strong> of the tree.</p>
<p>Let&rsquo;s create two structs to represent these nodes.</p>
<pre tabindex=0><code>type Group struct {  
   ChildNodes []Ast  
}  
  
type CharacterLiteral struct {  
   Character rune  
}
</code></pre><p>We&rsquo;ll need a way to add child nodes to the <code>Group</code> struct, so let&rsquo;s add a simple method for that.</p>
<pre tabindex=0><code>func (g *Group) Append(node Node) {  
   g.ChildNodes = append(g.ChildNodes, node)  
}
</code></pre><p>And we want all nodes to be compilable, although we&rsquo;ll get to actually <em>how</em> to compile them a bit later. Let&rsquo;s use an interface to show that they share this functionality.</p>
<pre tabindex=0><code>type Node interface {  
   compile() (head *State, tail *State)  
}
</code></pre><p>And we&rsquo;ll leave these methods unimplemented for now</p>
<pre tabindex=0><code>func (g *Group) compile() (head *State, tail *State) {  
   panic(&quot;implement me&quot;)
}  
  
func (l *CharacterLiteral) compile() (head *State, tail *State) {  
   panic(&quot;implement me&quot;) 
}
</code></pre><p>Finally, let&rsquo;s use another interface for composite nodes - those with the ability to contain child nodes. This will make things easier when we add other types of composite nodes other than just <code>group</code>.</p>
<pre tabindex=0><code>type CompositeNode interface {  
   Node  
   Append(node Node)  
}
</code></pre><p>Ok, now we have our <code>AST</code> nodes defined, let&rsquo;s take a look at how to parse a string into a tree.</p>
<h3 id=building-the-abstract-syntax-tree>Building the Abstract Syntax Tree</h3>
<p>Building the parser is going to be one of the more complex pieces of this project, so it helps to have tests just for this. Let&rsquo;s start with a simple test to make it clear what we&rsquo;re trying to produce.</p>
<pre tabindex=0><code>func TestParser(t *testing.T) {  
   type test struct {  
      name, input    string  
      expectedResult Node  
   }  
  
   tests := []test{  
      {name: &quot;simple string&quot;, input: &quot;aBc&quot;, expectedResult: &amp;Group{  
         ChildNodes: []Node{  
            CharacterLiteral{Character: 'a'},  
            CharacterLiteral{Character: 'B'},  
            CharacterLiteral{Character: 'c'},  
         },  
      }},  
   }  
  
   for _, tt := range tests {  
      t.Run(tt.name, func(t *testing.T) {  
         p := Parser{}  
         tokens := lex(tt.input)  
  
         result := p.Parse(tokens)  
  
         if !reflect.DeepEqual(result, tt.expectedResult) {  
            t.Fatalf(&quot;Expected [%+v], got [%+v]&quot;, tt.expectedResult, result)  
         }  
      })  
   }  
}
</code></pre><p>So, in our <code>simple string</code> test, we&rsquo;re using as an input the string <code>aBc</code> and we hope to create the following <code>Group</code> struct:</p>
<pre tabindex=0><code>&amp;Group{  
	ChildNodes: []Node{  
		CharacterLiteral{Character: 'a'},  
		CharacterLiteral{Character: 'B'},  
		CharacterLiteral{Character: 'c'},  
	},  
}
</code></pre><p>Parsing such a simple example is very easy - we would simply initialize a new <code>Group</code>, then loop over the characters and append them to the <code>Group</code>. As we have no other <code>compositeNodes</code>, this will be enough for now.</p>
<pre tabindex=0><code>type Parser struct { }  
  
func NewParser() *Parser {  
   return &amp;Parser{}  
}  
  
func (p *Parser) Parse(tokens []token) Node {  
   group := Group{}
  
   for _, t := range tokens {  
      switch t.symbol {  
      case Character:    
         group.Append(CharacterLiteral{Character: t.letter})  
      }  
   }  
  
   return &amp;group  
}
</code></pre><p>As our tests are now green, let&rsquo;s leave it there and move onto the next step - there&rsquo;ll be plenty of complexity to dive into later as we introduce nested structures.</p>
<p>Now, turning an <code>AST</code> into a compiled FSM.</p>
<h3 id=our-first-compiler>Our first compiler</h3>
<p>Compiling the <code>AST</code> into <code>State</code> objects can be tricky. The trick to keeping this step simple (and it can very quickly become <strong>not</strong> simple) is to let each node of the <code>AST</code> decide how it should be compiled.</p>
<p>For our simple example of compiling the regular expression <code>abc</code>, we just need two types of <code>AST</code> node;</p>
<ol>
<li><code>CharacterLiteral</code></li>
<li><code>Group</code></li>
</ol>
<p>We saw these in the diagram above as &lsquo;group&rsquo; and &lsquo;char&rsquo; boxes. Let&rsquo;s go through them.</p>
<ol>
<li><code>CharacterLiteral</code></li>
</ol>
<p>The <code>CharacterLiteral</code> node represents a single character. It does not contain any inner nodes, so it is a leaf node of the <code>AST</code>.</p>
<p>Compiling a <code>CharacterLiteral</code> node is fairly straight forward. A character literal for the expression <code>a</code> should look like this;</p>
<p><img src=/img/Pasted-image-20220807175929.png alt=Pasted-image-20220807175929.png></p>
<p>That&rsquo;s really all there is to it. It&rsquo;s a two <code>State</code> system with a single transition between them, using the character of the <code>CharacterLiteral</code> as the transition predicate.</p>
<p>Let&rsquo;s encode this behavior in the <code>Compile</code> method of the <code>CharacterLiteral</code> node object.</p>
<pre tabindex=0><code>func (l CharacterLiteral) compile() (head *State, tail *State) {
	// create the first state
	startingState := State{} 
	
	// create the second state
	endState := State{}  
	
	// add a transition between the two states, using the character as the transition predicate
	startingState.addTransition(&amp;endState, func(input rune) bool { return input == l.Character })  
	
	// return the head and tail states of this FSM
	return &amp;startingState, &amp;endState
}
</code></pre><ol start=2>
<li><code>Group</code></li>
</ol>
<p>The <code>Group</code> node represents a collection of <code>AST</code> nodes which need to appear consecutively in the input string. For example, <code>abc</code> would be a <code>Group</code> of 3 <code>CharacterLiteral</code> nodes. The inner nodes of <code>Group</code> do not have to be <code>CharacterLiterals</code>, however. For example, <code>(()()())</code> would be a <code>Group</code> of 3 <code>Group</code> nodes.</p>
<p>Compiling a <code>Group</code> node is a case of merging together it&rsquo;s child nodes so that the last state of one child is merged with the first state of the next child.</p>
<p>Let&rsquo;s look at this visually for our example of <code>abc</code></p>
<p><img src=/img/Pasted-image-20220807181511.png alt=Pasted-image-20220807181511.png></p>
<p>The <code>group</code> contains three <code>characterLiteral</code> nodes, compiled into their two <code>State</code> form. We begin by merging the states from left to right. This means taking the tail of the first FSM and merging it with the head of the second FSM.</p>
<p><img src=/img/Pasted-image-20220807181731.png alt=Pasted-image-20220807181731.png></p>
<p>Which leaves us with;</p>
<p><img src=/img/Pasted-image-20220807181749.png alt=Pasted-image-20220807181749.png></p>
<p>We can repeat this process of merging the tail of the left-most FSM with the head of the second FSM until we are left with a single, compiled FSM.</p>
<p><img src=/img/Pasted-image-20220807181855.png alt=Pasted-image-20220807181855.png></p>
<p><img src=/img/Pasted-image-20220807181901.png alt=Pasted-image-20220807181901.png></p>
<p>And there we have it, a successfully compiled state machine!</p>
<h3 id=the-power-of-structure>The power of structure</h3>
<p>Here, I hope it starts to become clear why we separate the <code>compiling</code> from the <code>lexing</code> and <code>parsing</code> stages. Once we have the <strong>structure</strong> of the expression, it&rsquo;s much easier to decompose the compilation into leaf nodes, such as a single letter, and composing nodes which hold collections of other nodes. Once we have these two types, we can simply tell composing nodes how to group their children, and tell leaf nodes the expected compiled form.</p>
<p>Having this separation of concerns will make life a lot easier for use when we introduce more complicated structures.</p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://LeweyM.github.io>
&copy; Lewis Metcalf 2022
</a>
<div>
<div class=ananke-socials>
</div></div>
</div>
</footer>
</body>
</html>