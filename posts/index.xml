<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Lewis Metcalf</title><link>https://LeweyM.github.io/posts/</link><description>Recent content in Posts on Lewis Metcalf</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://LeweyM.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Http - A History</title><link>https://LeweyM.github.io/posts/http-a-history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/http-a-history/</guid><description>A few notes based on this great video
HTTP/1 TCP/IP The first and most simple approach, making a TCP handshake for each resource which has to be shared.
The downsides to this approach is that in order to speed up transfer rates, we want to send many resource pieces in parallel. With HTTP/1, this means doing a new TCP handshake every-time, which is costly and time consuming. This was alleviated in a later version HTTP/1.</description></item><item><title>Regex Processor 1 Intro</title><link>https://LeweyM.github.io/posts/regex-processor-1-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor-1-intro/</guid><description>So, one of the things I&amp;rsquo;ve wanted to play around with is search and regex. Searching through text for matches to a regular expression can be efficiently implemented using finite state machines.
Finite State Machines finite state machines are both simple and useful. The simplest definition I can think of is something like this;
A finite State Machine (FSM) is a series of states. The machine start in some state, then decides the next state to go to based on some input.</description></item><item><title>Regex Processor 2 Getting into some code</title><link>https://LeweyM.github.io/posts/regex-processor-2-getting-into-some-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor-2-getting-into-some-code/</guid><description>Let&amp;rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&amp;rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:</description></item><item><title>Regex Processor 3 Starting the compiler</title><link>https://LeweyM.github.io/posts/regex-processor-3-starting-the-compiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor-3-starting-the-compiler/</guid><description>Now we have a working FSM and way to process strings, let&amp;rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing a FSM for the regular expression abc into a few at least 2 discrete steps;
take abc and create a linked list of 'states' with conditional transitions to other states. process the input and move through the states.</description></item><item><title>Regex Processor 4 A bit more theory</title><link>https://LeweyM.github.io/posts/regex-processor-4-a-bit-more-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor-4-a-bit-more-theory/</guid><description>## One or more
cool, so what about a regular expression like 'a+b'?
This means &amp;ldquo;match any string that has one or more 'a's, followed by a 'b'&amp;rdquo;. So, for example:
&amp;quot;ab&amp;quot; -&amp;gt; match &amp;quot;aaaaab&amp;quot; -&amp;gt; match &amp;quot;ba&amp;quot; -&amp;gt; no match &amp;quot;&amp;quot; -&amp;gt; no match What would the FSM look like for that? Well, it would look like the following;
This is pretty straight forward, if you&amp;rsquo;re at state[1], that means &amp;ldquo;you&amp;rsquo;ve already seen 'a'&amp;rdquo;.</description></item><item><title>Regex Processor 5 Branches</title><link>https://LeweyM.github.io/posts/regex-processor-5-branches/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor-5-branches/</guid><description>## OR
Consider a regular expression like 'dog|cat', which means &amp;ldquo;match any string containing the substring dog or the substring cat&amp;rdquo;.
Hmm, although the structure is the same, we&amp;rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for &amp;quot;cat&amp;quot; that if we process a 'c' somewhere during the the states along &amp;quot;cat&amp;quot;, we need to go back to the &amp;ldquo;you&amp;rsquo;ve seen 'c'&amp;rdquo; state instead of the beginning.</description></item><item><title>The Journey of a Refactor</title><link>https://LeweyM.github.io/posts/the-journey-of-a-refactor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/the-journey-of-a-refactor/</guid><description>Basically, I was trying to do something and went down the wrong path, and when I finally saw the light it all got a lot better.
Problem I’m trying to write a test that makes sure that no other fields in the db are effected when we write to the db - only the field that we care about. The issue is that when you decode a response from the db to a go struct, you can use known fields with a struct, or unknown fields with a map, but you can’t do a mix.</description></item></channel></rss>