<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Lewis Metcalf</title><link>https://LeweyM.github.io/posts/</link><description>Recent content in Posts on Lewis Metcalf</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://LeweyM.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Http - A History</title><link>https://LeweyM.github.io/posts/http-a-history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/http-a-history/</guid><description>A few notes based on this great video
HTTP/1 TCP/IP The first and most simple approach, making a TCP handshake for each resource which has to be shared.
The downsides to this approach is that in order to speed up transfer rates, we want to send many resource pieces in parallel. With HTTP/1, this means doing a new TCP handshake every-time, which is costly and time consuming. This was alleviated in a later version HTTP/1.</description></item><item><title>Optimizing the regex parser</title><link>https://LeweyM.github.io/posts/optimizing-the-regex-parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/optimizing-the-regex-parser/</guid><description>before
... Searching 2 696948604 ns/op ➜ search git:(master) ✗ go test -bench=BenchmarkList -cpuprofile p.out ➜ search git:(master) ✗ go tool pprof -http localhost:8080 --nodecount=20 search.test p.out now a memory profile
now with tracing
noticing a growth in go routines and heap allocation
after change:
func FindAllAsync(ctx context.Context, finiteStateMachine Machine, searchString string, out chan Result) { defer close(out) lineCounter := 0 start := 0 end := 0 runes := append([]rune(searchString), 0) // we add a 'NULL' 0 rune at the End so that even empty string inputs are processed.</description></item><item><title>parallelizing a raytracer</title><link>https://LeweyM.github.io/posts/parallelizing-a-raytracer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/parallelizing-a-raytracer/</guid><description>After reading through the excellent Ultimate Go Notebook by William Kennedy and Hoanh An, I got an itching to go back to another book project, the [Ray Tracer Challenge] and make some improvements.
[[What&amp;rsquo;s in the Ultimate Go Notebook?]]</description></item><item><title>Regex Processor</title><link>https://LeweyM.github.io/posts/regex-processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor/</guid><description>So, one of the things I&amp;rsquo;ve wanted to play around with is search and regex. Regex always seemed like a bit of a mystery to me, and then one day I watched a lecture on finite state machines and it opened up a thriving vein of curiosity to follow.
Finite State Machines finite state machines are super simple and super useful. The simplest definition I can think of is something like this;</description></item><item><title>What's in the Ultimate Go Notebook?</title><link>https://LeweyM.github.io/posts/whats-in-the-ultimate-go-notebook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/whats-in-the-ultimate-go-notebook/</guid><description>There&amp;rsquo;s a whole heap of content in that book. Good content. I split it up into 4 main sections.
Chapters 1-3: Language mechanics These initial chapters take a deep dive into how go works. It talks about the differences of value and pointer semantics and the performance tradeoffs that come with them, how data structures are represented in memory in the go runtime, and touches on some of the more mysterious concepts such as escape analysis.</description></item></channel></rss>