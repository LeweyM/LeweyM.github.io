<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Regex Processor | Lewis Metcalf</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="So, one of the things I&rsquo;ve wanted to play around with is search and regex. Regex always seemed like a bit of a mystery to me, and then one day I watched a lecture on finite state machines and it opened up a thriving vein of curiosity to follow.
Finite State Machines finite state machines are super simple and super useful. The simplest definition I can think of is something like this;">
<meta name=generator content="Hugo 0.91.2">
<meta name=robots content="noindex, nofollow">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Regex Processor">
<meta property="og:description" content="So, one of the things I&rsquo;ve wanted to play around with is search and regex. Regex always seemed like a bit of a mystery to me, and then one day I watched a lecture on finite state machines and it opened up a thriving vein of curiosity to follow.
Finite State Machines finite state machines are super simple and super useful. The simplest definition I can think of is something like this;">
<meta property="og:type" content="article">
<meta property="og:url" content="https://LeweyM.github.io/posts/regex-processor/"><meta property="article:section" content="posts">
<meta itemprop=name content="Regex Processor">
<meta itemprop=description content="So, one of the things I&rsquo;ve wanted to play around with is search and regex. Regex always seemed like a bit of a mystery to me, and then one day I watched a lecture on finite state machines and it opened up a thriving vein of curiosity to follow.
Finite State Machines finite state machines are super simple and super useful. The simplest definition I can think of is something like this;">
<meta itemprop=wordCount content="1026">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Regex Processor">
<meta name=twitter:description content="So, one of the things I&rsquo;ve wanted to play around with is search and regex. Regex always seemed like a bit of a mystery to me, and then one day I watched a lecture on finite state machines and it opened up a thriving vein of curiosity to follow.
Finite State Machines finite state machines are super simple and super useful. The simplest definition I can think of is something like this;">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Lewis Metcalf
</a>
<div class="flex-l items-center">
<div class=ananke-socials>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Regex Processor</h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>So, one of the things I&rsquo;ve wanted to play around with is search and regex. Regex always seemed like a bit of a mystery to me, and then one day I watched a lecture on finite state machines and it opened up a thriving vein of curiosity to follow.</p>
<h1 id=finite-state-machines>Finite State Machines</h1>
<p>finite state machines are super simple and super useful. The simplest definition I can think of is something like this;</p>
<blockquote>
<p>You start in some state, then you decide the next state to go to based on some input. After processing all the input, you see which state you&rsquo;re in.</p>
</blockquote>
<p>One of the cool things about FSMs is that they can be drawn as lovely little circles and arrows representing <strong>states</strong> and <strong>transitions</strong></p>
<p><img src=/img/Pasted-image-20220119151322.png alt=Pasted-image-20220119151322.png></p>
<p>This is the simplest. It&rsquo;s just a single state. The red circle in the middle means that we&rsquo;re currently in that state. It doesn&rsquo;t mean much yet.</p>
<p><img src=/img/Pasted-image-20220119151437.png alt=Pasted-image-20220119151437.png></p>
<p>This is the next simplest. It&rsquo;s a two state system. From the state on the left, we&rsquo;ll call it <code>state[0]</code>, we travel to the state on the right, <code>state[1]</code>, if we process the character <code>c</code> from the input.</p>
<p>Two things to note here:</p>
<ol>
<li>What happens if we process a different character to <code>c</code>? From the picture, we don&rsquo;t know what to do. To be truly accurate, there should be an arrow for every possible input, every character in this case. For brevity, we say that if there is no arrow, it means &ldquo;go back to the starting state&rdquo;.</li>
<li>The circle on the right is blue. This means, this is an <strong>end state</strong>. If we arrive at this state, we have finished, and the FSM can return <code>true</code>.</li>
</ol>
<p>All this is lovely and everything, but what can we actually do with this? We&rsquo;re going to use these machines to solve regular expressions.</p>
<h2 id=text-search>Text search</h2>
<p>let&rsquo;s create a state machine which checks if a string matches against a simple regular expression query <code>abc</code>. This means that any string containing the substring <code>abc</code> will match. For example:</p>
<ul>
<li><code>"zabcz"</code> - match</li>
<li><code>"abc"</code> - match</li>
<li><code>"abd"</code> - no match</li>
<li><code>""</code> - no match</li>
</ul>
<p>The state machine to check for is as follows:</p>
<p><img src=/img/Pasted-image-20220119180620.png alt=Pasted-image-20220119180620.png></p>
<p>let&rsquo;s break this down a bit. Really, each state is saying something.</p>
<p>State 0 is saying: &ldquo;you have not yet seen anything interesting&rdquo;
State 1 is saying: &ldquo;you&rsquo;ve just seen <code>'a'</code>&rdquo;
State 2 is saying: &ldquo;you&rsquo;ve just seen <code>'ab'</code>&rdquo;
State 3 is saying &ldquo;you&rsquo;ve just seen <code>'abc'</code> so you&rsquo;re done!&rdquo;</p>
<p>let&rsquo;s get into these states and what they&rsquo;re saying a little more to try to understand all of these arrows.</p>
<p>At state 0, I still haven&rsquo;t seen anything interesting until I see an <code>'a'</code>, that&rsquo;s pretty straight forward.</p>
<p>At state 1, if I see another <code>'a'</code>, with the string <code>"aaabc"</code> for example, I still want to be in the state of &ldquo;you&rsquo;ve just seen <code>'a'</code>&rdquo;, therefore we need the little recursive arrow which points to itself.</p>
<p>At state 2 we&rsquo;re saying &ldquo;you&rsquo;ve just seen <code>'ab'</code>. If we&rsquo;ve seen <code>ab</code> and we then see and <code>'a'</code>, we want our state to say &ldquo;you&rsquo;ve just seen <code>'a'</code>&rdquo;, rather than &ldquo;you haven&rsquo;t seen anything interesting yet&rdquo;, so therefore we need another little arrow to go to state 1.</p>
<p>And at state 3, we know we&rsquo;ve seen <code>'abc'</code>, so we don&rsquo;t want to do anything from here!</p>
<h2 id=wildcards>Wildcards</h2>
<p>cool, so what about a regular expression like <code>'a*b'</code>. This means &ldquo;match any string that has an <code>'a'</code> followed by a <code>'b'</code>&rdquo;. What would the FSM look like for that?</p>
<p><img src=/img/Pasted-image-20220119183708.png alt=Pasted-image-20220119183708.png></p>
<p>This is pretty straight forward, if you&rsquo;re at <code>state[1]</code>, that means &ldquo;you&rsquo;ve already seen <code>'a'</code>&rdquo;. Therefore, you never go back to the previous state. Then, if you&rsquo;ve already seen <code>'a'</code> and you later see <code>'b'</code>, you&rsquo;re done!</p>
<p>Notice that this works for any number of chars between <code>a</code> and <code>b</code>, including zero.</p>
<h2 id=or>OR</h2>
<p>Consider a regular expression like <code>'dog|cat'</code>, which means &ldquo;match any string containing the substring <code>dog</code> or the substring <code>cat</code>&rdquo;.</p>
<p><img src=/img/Pasted-image-20220119185302.png alt=Pasted-image-20220119185302.png></p>
<p>Hmm, although the structure is the same, we&rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for <code>"cat"</code> that if we process a <code>'c'</code> somewhere during the the states along <code>"cat"</code>, we need to go back to the &ldquo;you&rsquo;ve seen <code>'c'</code>&rdquo; state instead of the beginning. In fact, most of the arrows point to the <code>'d'</code> and <code>'c'</code> states, the first letters of <code>cat</code> and <code>dog</code>. Let&rsquo;s think about how we can reduce some of the complexity here.</p>
<p>What&rsquo;s happening here is that we&rsquo;re trying to replicate how <code>grep</code> works, not how regular expressions work. A regular expression would just say &ldquo;the string starts with &ldquo;cat&rdquo; or &ldquo;dog&rdquo;, otherwise it doesn&rsquo;t match&rdquo;. Doing it this way simplifies our diagram quite a lot.</p>
<p><img src=/img/Pasted-image-20220128175219.png alt=Pasted-image-20220128175219.png></p>
<p>We can still use this to get grep-like behaviour by simply resetting the finite state machine every time it lands in a &ldquo;Failed&rdquo; state (or a &ldquo;Passed&rdquo; state if we want to count multiple matches).</p>
<h1 id=branches>Branches</h1>
<p>This is all hunky-dory when we know exactly where to go in our finite state machine, but that&rsquo;s not always the case. Consider the regex <code>"dog|dot"</code>. We might draw our FSM like so:</p>
<p><img src=/img/Pasted-image-20220128175308.png alt=Pasted-image-20220128175308.png></p>
<p>so, what happens when we come across our first &rsquo;d' character? Which way do we go? Having choices in our state machine makes into a Nondeterministic State Automata (NFA), and there&rsquo;s a load of study into these things, study I&rsquo;m far too lazy to actually do. What I do know, however, is that we can still use these to solve regular expression problems.</p>
<p>I&rsquo;m picking an easy way. Branching.</p>
<p>Basically, when I come across more than one path in my state machine, the runner (the little red dot in our pictures) will split in two and go down both paths. If one of the runners reaches a success state, it&rsquo;s a match. If all runners enter a fail state, no match. This does sacrifice some performance as we can no longer guarantee the finite state machine to determine a match in linear time, but it does make our diagrams simpler, which is good enough for now.</p>
<p><img src=/img/Pasted-image-20220128180045.png alt=Pasted-image-20220128180045.png></p>
<p><img src=/img/Pasted-image-20220128180055.png alt=Pasted-image-20220128180055.png></p>
<p><img src=/img/Pasted-image-20220128180104.png alt=Pasted-image-20220128180104.png></p>
<p><img src=/img/Pasted-image-20220128180114.png alt=Pasted-image-20220128180114.png></p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://LeweyM.github.io>
&copy; Lewis Metcalf 2022
</a>
<div>
<div class=ananke-socials>
</div></div>
</div>
</footer>
</body>
</html>