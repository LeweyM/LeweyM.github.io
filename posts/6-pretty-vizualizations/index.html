<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>6 Pretty Vizualizations - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="6 Pretty Vizualizations"><meta property="og:description" content="Now that we have a few features working, this is a good time to take a step back and build some things to help us see what we&rsquo;re working with. The tools we&rsquo;re going to build now will help with debugging as our features become more complex, and will give us a clearer picture of the logic of the systems we&rsquo;re working with.
As a side note, I also think it&rsquo;s worth mentioning that an important part of building a (kinda) sophisticated system is maintaining the developer infrastructure around it."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/posts/6-pretty-vizualizations/"><meta property="article:section" content="posts"><meta property="og:see_also" content="https://leweym.github.io/posts/1-intro/"><meta property="og:see_also" content="https://leweym.github.io/posts/2-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/posts/3-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/posts/4-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/posts/5-wildcards/"><meta name=twitter:card content="summary"><meta name=twitter:title content="6 Pretty Vizualizations"><meta name=twitter:description content="Now that we have a few features working, this is a good time to take a step back and build some things to help us see what we&rsquo;re working with. The tools we&rsquo;re going to build now will help with debugging as our features become more complex, and will give us a clearer picture of the logic of the systems we&rsquo;re working with.
As a side note, I also think it&rsquo;s worth mentioning that an important part of building a (kinda) sophisticated system is maintaining the developer infrastructure around it."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><script src=https://leweym.github.io/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/posts/1-intro/>1 Intro</a> <span class=meta></span></div><div class=post><a href=/posts/2-getting-into-some-code/>2 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/posts/3-starting-the-compiler/>3 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/posts/4-testing-fuzzing-and-fixing-things/>4 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/posts/5-wildcards/>5 Wildcards</a> <span class=meta></span></div><div class=post><span>6 Pretty Vizualizations</span></div></div></div><br><div class=post-header><h1 class=title>6 Pretty Vizualizations</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#visualizing-graphs>Visualizing Graphs</a></li><li><a href=#mermaidjs-for-graphs>Mermaid.js for graphs</a></li><li><a href=#traversal>Traversal</a></li><li><a href=#the-transitionset>The TransitionSet</a></li><li><a href=#generics>Generics</a></li><li><a href=#writing-the-node-traversal-algorithm>Writing the node traversal algorithm</a></li><li><a href=#a-quick-command-line-tool>A quick command line tool</a></li></ul></nav></aside><div class=markdown><p>Now that we have a few features working, this is a good time to take a step back and build some things to help us see what we&rsquo;re working with. The tools we&rsquo;re going to build now will help with debugging as our features become more complex, and will give us a clearer picture of the logic of the systems we&rsquo;re working with.</p><p>As a side note, I also think it&rsquo;s worth mentioning that an important part of building a (kinda) sophisticated system is maintaining the developer infrastructure around it. That can be anything from tests, build tools, debugging tools - anything that helps you get your head around the system and manage that complexity.</p><p>So, let&rsquo;s build something to help us <em>see</em>.</p><h2 id=visualizing-graphs>Visualizing Graphs</h2><p>The issue we have is that it&rsquo;s not very easy to visualize a set of connected nodes (a graph) using variables and text. We <em>could</em> do it, and trace the pointer hashes from one object to the next, but it&rsquo;s not going to be very fun. As our system scales in complexity, this method will get more and more tedious.</p><p>As the old adage goes, a picture tells a thousand words&mldr;</p><p>We&rsquo;re going to produce something like this:</p><div class=mermaid>graph LR
10((1)) --a-->
20((2)) --b-->
30((3)) --c-->
40((4)) --d--> 50((5))
40((4)) --e--> 60((6))</div><p>This visual representation of our FSM will give us a quick insight into whether we&rsquo;ve compiled the regular expression correctly, and let us run through the steps ourselves to check when things go wrong.</p><p>This was created using <code>mermaid.js</code>.</p><h2 id=mermaidjs-for-graphs>Mermaid.js for graphs</h2><p><code>mermaid.js</code> is a fantastic tool which allows us to write graphs in standard markdown which can be then rendered in the browser. The markdown for the above graph is the following;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>Graph LR
</span></span><span style=display:flex><span>	1((1)) --a--&gt;
</span></span><span style=display:flex><span>	2((2)) --b--&gt;
</span></span><span style=display:flex><span>	3((3)) --c--&gt;
</span></span><span style=display:flex><span>	4((4)) --d--&gt; 5((5))
</span></span><span style=display:flex><span>	4((4)) --e--&gt; 6((6))
</span></span></code></pre></div><p>Note: <code>mermaid</code> is much more powerful than this and has all sorts of wild and wonderful features. Check out <a href=https://mermaid-js.github.io/mermaid>the docs</a> and see.</p><p>This is simple enough, we just need to parse our <code>States</code> and <code>Transitions</code> into the numbers and arrows in the markdown above.</p><p>As always, let&rsquo;s start with some tests to help define our objective.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>TestState_Draw</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>      input, expected <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tests <span style=color:#000;font-weight:700>:=</span> []test{  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         input: <span style=color:#d14>&#34;abc&#34;</span>,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34;b&#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;c&#34;--&gt; 3((3))`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         input: <span style=color:#d14>&#34;a b&#34;</span>,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34; &#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;b&#34;--&gt; 3((3))`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, tt <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tests {  
</span></span><span style=display:flex><span>      t.<span style=color:#900;font-weight:700>Run</span>(tt.input, <span style=color:#000;font-weight:700>func</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>         parser <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewParser</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>         tokens <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>lex</span>(tt.input)  
</span></span><span style=display:flex><span>         ast <span style=color:#000;font-weight:700>:=</span> parser.<span style=color:#900;font-weight:700>Parse</span>(tokens)  
</span></span><span style=display:flex><span>         fsm, _ <span style=color:#000;font-weight:700>:=</span> ast.<span style=color:#900;font-weight:700>compile</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>         drawing <span style=color:#000;font-weight:700>:=</span> fsm.<span style=color:#900;font-weight:700>Draw</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>if</span> drawing <span style=color:#000;font-weight:700>!=</span> tt.expected {  
</span></span><span style=display:flex><span>            t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;Expected drawing to be \n\&#34;%s\&#34;, got\n\&#34;%s\&#34;&#34;</span>, tt.expected, drawing)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      })  
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><p>This test is pretty straight forward, let&rsquo;s just zoom in on a couple of things.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>drawing <span style=color:#000;font-weight:700>:=</span> fsm.<span style=color:#900;font-weight:700>Draw</span>()  
</span></span></code></pre></div><p>This is what we want to produce. It&rsquo;s a new method on the <code>State</code> struct, which will produce a <code>string</code> with the lines and numbers needed for our <code>mermaid</code> markdown.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>   tests <span style=color:#000;font-weight:700>:=</span> []test{  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         input: <span style=color:#d14>&#34;abc&#34;</span>,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34;b&#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;c&#34;--&gt; 3((3))`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         input: <span style=color:#d14>&#34;a b&#34;</span>,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34; &#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;b&#34;--&gt; 3((3))`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>   }  
</span></span></code></pre></div><p>Here are our test cases. They&rsquo;re quite simple also, as they show simple cases of single character transition FSMs, and also a case for whitespaces.</p><p>Now that we have some red tests, we can start implementing the <code>Draw</code> method.</p><h2 id=traversal>Traversal</h2><p>We need a line for every <code>Transition</code> in our FSM. Generically speaking, this means we need to look at every &lsquo;vertex&rsquo; in our &lsquo;directed graph&rsquo; (digraph). So, what we have here is a <strong>graph traversal problem</strong>.</p><p>There are two generic ways to traverse a graph; Breadth-First Search (BFS) and Depth-First Search (DFS). How we visit every vertex will determine the order of the lines in our <code>mermaid</code> markdown. It doesn&rsquo;t make a huge difference, but DFS should lead to longer chains of connected nodes being drawn first. Another advantage of DFS is that our traversal algorithm can be defined recursively.</p><p>Our algorithm for collecting all the <code>Transitions</code> of the FSM should look something like this;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// from the root node
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#099>1.</span> If the current node has already been visited, stop.
</span></span><span style=display:flex><span><span style=color:#099>2.</span> Add the transitions from this node to a set of transitions.
</span></span><span style=display:flex><span><span style=color:#099>3.</span> Mark the current node as visited.
</span></span><span style=display:flex><span><span style=color:#099>4.</span> Recur on the destination node of every outgoing transition.
</span></span><span style=display:flex><span><span style=color:#099>5.</span> Recur on the source node of every incoming transition.
</span></span></code></pre></div><p>The order of the recursions is important here. We want to first collect the outgoing transitions of all the nodes, and then, starting from the last node and going backwards, collect the transitions of any unvisited nodes connected by incoming transitions.</p><p>I won&rsquo;t labor the point here, as it&rsquo;s tricky to visualize what&rsquo;s going on and distracts from what we&rsquo;re trying to do here. If this is mysterious to you, try walking step by step through the call stack and see where you end up.</p><p>We&rsquo;re going to build something to make this algorithm easier, a data structure to store the set of Transitions.</p><h2 id=the-transitionset>The TransitionSet</h2><p>This object has two <strong>invariants</strong> (qualities which never change).</p><ol><li>All transitions in the set are unique.</li><li>The insertion order is maintained.</li></ol><p>Let&rsquo;s code it.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// TransitionSet maintains an ordered set of unique Transitions
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> TransitionSet <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   transitionSet  <span style=color:#000;font-weight:700>map</span>[Transition]<span style=color:#458;font-weight:700>bool</span>  
</span></span><span style=display:flex><span>   transitionList []Transition  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ll maintain two structures in parallel. The <code>map</code> will ensure that our <code>Transitions</code> are unique, and the <code>slice</code> will keep the insertion order.</p><p>We&rsquo;ll write two simple methods for checking if an element is present in the set, and another returning the ordered list of <code>Transitions</code>. We&rsquo;ll call these methods <code>has</code> and <code>list</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (ts <span style=color:#000;font-weight:700>*</span>TransitionSet) <span style=color:#900;font-weight:700>has</span>(t Transition) <span style=color:#458;font-weight:700>bool</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> ts.transitionSet[t]  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (ts <span style=color:#000;font-weight:700>*</span>TransitionSet) <span style=color:#900;font-weight:700>list</span>() []Transition {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> ts.transitionList[:]  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So far so good, all pretty simple.</p><p>Adding to the set is just a case of adding the map and appending to the list. If the <code>Transition</code> is already in the set, we do nothing. This will be the <code>add</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (ts <span style=color:#000;font-weight:700>*</span>TransitionSet) <span style=color:#900;font-weight:700>add</span>(t Transition) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> ts.transitionSet <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      ts.transitionSet = <span style=color:#0086b3>make</span>(<span style=color:#000;font-weight:700>map</span>[Transition]<span style=color:#458;font-weight:700>bool</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> !ts.transitionSet[t] {  
</span></span><span style=display:flex><span>      ts.transitionSet[t] = <span style=color:#000;font-weight:700>true</span>  
</span></span><span style=display:flex><span>      ts.transitionList = <span style=color:#0086b3>append</span>(ts.transitionList, t)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Fantastic. We also need a similar data structure for keeping track of already &lsquo;visited&rsquo; nodes, making sure we don&rsquo;t get caught in any circular loops. We also want to keep track of the order of visited nodes so that we can use that order as the number labels of the nodes.</p><p>What we actually want is a generic data structure which is a set which keeps the order of it&rsquo;s items. We&rsquo;ll call this an <code>OrderedSet</code>.</p><h2 id=generics>Generics</h2><p>We can use the new Generics features of Go 1.18 to write this generically and use the same structure for both &lsquo;visited&rsquo; <code>*States</code> and <code>Transitions</code>.</p><p>Note: Notice that we want a set of <code>State</code> pointers, and a set of concrete <code>Transitions</code>. This is because <code>Transitions</code> contain all of their identifying information, such as their <code>to</code> and <code>from</code> states, and the predicate, as fields in the struct. <code>States</code>, on the other hand, require a reference to be identified.</p><p>Before we get into the generic implementation, we need to do some refactoring of <code>Transition</code> in order to make it <code>comparable</code> in Go (not a slice, map, or function type). This means that all of its fields must also be <code>comparable</code>, and currently the <code>predicate</code> field is a function type. Let&rsquo;s change that now.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#000;background-color:#fdd>- type Predicate func(input rune) bool
</span></span></span></code></pre></div><p>Instead, let&rsquo;s use a struct which can have either a string of allowed or disallowed chars<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Predicate <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   allowedChars    <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   disallowedChars <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p Predicate) <span style=color:#900;font-weight:700>test</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> p.allowedChars <span style=color:#000;font-weight:700>!=</span> <span style=color:#d14>&#34;&#34;</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> p.disallowedChars <span style=color:#000;font-weight:700>!=</span> <span style=color:#d14>&#34;&#34;</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;must be mutually exclusive&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(p.allowedChars) &gt; <span style=color:#099>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> strings.<span style=color:#900;font-weight:700>ContainsRune</span>(p.allowedChars, input)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(p.disallowedChars) &gt; <span style=color:#099>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> !strings.<span style=color:#900;font-weight:700>ContainsRune</span>(p.disallowedChars, input)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And let&rsquo;s make a few changes so that our problem compiles.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span> func (s *State) firstMatchingTransition(input rune) destination {
</span></span><span style=display:flex><span>        for _, t := range s.transitions {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               if t.predicate.test(input) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span><span style=color:#000;background-color:#fdd>-               if t.predicate(input) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span>                        return t.to
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	return nil
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func (l CharacterLiteral) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startingState := State{}
</span></span><span style=display:flex><span>        endState := State{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       startingState.addTransition(&amp;endState, func(input rune) bool { return input == l.Character }, string(l.Character))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       startingState.addTransition(&amp;endState, Predicate{allowedChars: string(l.Character)}, string(l.Character))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return &amp;startingState, &amp;endState
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func (w WildcardLiteral) compile() (head *State, tail *State) {  
</span></span><span style=display:flex><span>   startingState := State{}  
</span></span><span style=display:flex><span>   endState := State{}  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  startingState.addTransition(&amp;endState, func(input rune) bool { return input != &#34;\n&#34; }, string(l.Character))  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+  startingState.addTransition(&amp;endState, Predicate{disallowedChars: &#34;\n&#34;}, &#34;.&#34;)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   return &amp;startingState, &amp;endState  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now, let&rsquo;s change our <code>TransitionSet</code> to be a generic <code>OrderedSet</code> struct.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#000;background-color:#fdd>- type TransitionSet struct {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-    transitionSet  map[Transition]bool  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-    transitionList []Transition  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>- }
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// OrderedSet maintains an ordered set of unique items of type &lt;T&gt;
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>type</span> OrderedSet[T comparable] <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   set       <span style=color:#000;font-weight:700>map</span>[T]<span style=color:#458;font-weight:700>int</span>  
</span></span><span style=display:flex><span>   nextIndex <span style=color:#458;font-weight:700>int</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>add</span>(t T) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> o.set <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      o.set = <span style=color:#0086b3>make</span>(<span style=color:#000;font-weight:700>map</span>[T]<span style=color:#458;font-weight:700>int</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> !o.<span style=color:#900;font-weight:700>has</span>(t) {  
</span></span><span style=display:flex><span>      o.set[t] = o.nextIndex  
</span></span><span style=display:flex><span>      o.nextIndex<span style=color:#000;font-weight:700>++</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>has</span>(t T) <span style=color:#458;font-weight:700>bool</span> {  
</span></span><span style=display:flex><span>   _, hasItem <span style=color:#000;font-weight:700>:=</span> o.set[t]  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> hasItem  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>list</span>() []T {  
</span></span><span style=display:flex><span>   size <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>len</span>(o.set)  
</span></span><span style=display:flex><span>   list <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>make</span>([]T, size)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> t, i <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> o.set {  
</span></span><span style=display:flex><span>      list[i] = t  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> list  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ve changed the implementation here slightly by storing the index in the <code>set</code> field. This makes our <code>list</code> method a little more awkward, but it makes it easier to get the index of any item in the set, which will be useful for finding the numbers of our nodes.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>getIndex</span>(t T) <span style=color:#458;font-weight:700>int</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> o.set[t]  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we have all the pieces we need for our traversal algorithm.</p><h2 id=writing-the-node-traversal-algorithm>Writing the node traversal algorithm</h2><p>Because of the useful data structures we&rsquo;ve just dreamed up, writing the traversal algorithm maps pretty simply to the pseudocode we described earlier.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>visitNodes</span>(  
</span></span><span style=display:flex><span>   node <span style=color:#000;font-weight:700>*</span>State,  
</span></span><span style=display:flex><span>   transitions <span style=color:#000;font-weight:700>*</span>OrderedSet[Transition],  
</span></span><span style=display:flex><span>   visited <span style=color:#000;font-weight:700>*</span>OrderedSet[<span style=color:#000;font-weight:700>*</span>State],  
</span></span><span style=display:flex><span>) {  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 1. If the current node has already been visited, stop.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>if</span> visited.<span style=color:#900;font-weight:700>has</span>(node) {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 2. Add the transitions from this node to a set of transitions.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>for</span> _, transition <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> node.transitions {  
</span></span><span style=display:flex><span>      transitions.<span style=color:#900;font-weight:700>add</span>(transition)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 3. Mark the current node as visited.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   visited.<span style=color:#900;font-weight:700>add</span>(node)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 4. Recur on the destination node of every outgoing transition.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>for</span> _, transition <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> node.transitions {  
</span></span><span style=display:flex><span>      destinationNode <span style=color:#000;font-weight:700>:=</span> transition.to  
</span></span><span style=display:flex><span>      <span style=color:#900;font-weight:700>visitNodes</span>(destinationNode, transitions, visited)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 5. Recur on the source node of every incoming transition.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>for</span> _, sourceNode <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> node.incoming {  
</span></span><span style=display:flex><span>      <span style=color:#900;font-weight:700>visitNodes</span>(sourceNode, transitions, visited)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s important that the <code>transitions</code> and the <code>visited</code> <code>OrderedSets</code> are passed by reference using pointers. They should be the same instance in every recursive call, as we want to collect <code>Transitions</code> and mark <code>Nodes</code> as visited across the whole graph.</p><p>Once we have collected the <code>Transitions</code>, we now just have to draw them as lines in our <code>mermaid</code> markdown.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>Draw</span>() <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// initialize sets  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   transitionSet <span style=color:#000;font-weight:700>:=</span> OrderedSet[Transition]{}  
</span></span><span style=display:flex><span>   nodeSet <span style=color:#000;font-weight:700>:=</span> OrderedSet[<span style=color:#000;font-weight:700>*</span>State]{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// collect transitions  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#900;font-weight:700>visitNodes</span>(s, <span style=color:#000;font-weight:700>&amp;</span>transitionSet, <span style=color:#000;font-weight:700>&amp;</span>nodeSet)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   output <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>string</span>{  
</span></span><span style=display:flex><span>      <span style=color:#d14>&#34;graph LR&#34;</span>,  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// draw transitions  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> transitionSet.<span style=color:#900;font-weight:700>list</span>() {  
</span></span><span style=display:flex><span>      fromId <span style=color:#000;font-weight:700>:=</span> nodeSet.<span style=color:#900;font-weight:700>getIndex</span>(t.from)  
</span></span><span style=display:flex><span>      toId <span style=color:#000;font-weight:700>:=</span> nodeSet.<span style=color:#900;font-weight:700>getIndex</span>(t.to)  
</span></span><span style=display:flex><span>      output = <span style=color:#0086b3>append</span>(output, fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;%d((%d)) --\&#34;%s\&#34;--&gt; %d((%d))&#34;</span>, fromId, fromId, t.debugSymbol, toId, toId))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> strings.<span style=color:#900;font-weight:700>Join</span>(output, <span style=color:#d14>&#34;\n&#34;</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Once all the hard work of collecting the <code>Nodes</code> and <code>Transitions</code> is done, it&rsquo;s quite simple to concatenate the strings required to build the <code>mermaid.js</code> code. I won&rsquo;t go into much more detail here, as the code seems to speak for itself.</p><p>With all this in place, let&rsquo;s run our tests.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#000;font-weight:700>===</span> RUN   <span style=color:teal>TestState_Draw</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>===</span> RUN   TestState_Draw/abc
</span></span><span style=display:flex><span>    draw_test.go:38: Expected drawing to be 
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;graph LR
</span></span></span><span style=display:flex><span><span style=color:#d14>        0((0)) --&#34;</span>a<span style=color:#d14>&#34;--&gt; 1((1))
</span></span></span><span style=display:flex><span><span style=color:#d14>        1((1)) --&#34;</span>b<span style=color:#d14>&#34;--&gt; 2((2))
</span></span></span><span style=display:flex><span><span style=color:#d14>        2((2)) --&#34;</span>c<span style=color:#d14>&#34;--&gt; 3((3))&#34;</span>, got
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;graph LR
</span></span></span><span style=display:flex><span><span style=color:#d14>        0((0)) --&#34;</span>a<span style=color:#d14>&#34;--&gt; 1((1))
</span></span></span><span style=display:flex><span><span style=color:#d14>        1((1)) --&#34;</span>b<span style=color:#d14>&#34;--&gt; 2((2))
</span></span></span><span style=display:flex><span><span style=color:#d14>        2((2)) --&#34;</span>c<span style=color:#d14>&#34;--&gt; 3((3))
</span></span></span><span style=display:flex><span><span style=color:#d14>        4((4)) --&#34;</span>c<span style=color:#d14>&#34;--&gt; 3((3))
</span></span></span><span style=display:flex><span><span style=color:#d14>        5((5)) --&#34;</span>b<span style=color:#d14>&#34;--&gt; 2((2))
</span></span></span><span style=display:flex><span><span style=color:#d14>        6((6)) --&#34;</span>a<span style=color:#d14>&#34;--&gt; 1((1))&#34;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>===</span> RUN   TestState_Draw/a_b
</span></span><span style=display:flex><span>    draw_test.go:38: Expected drawing to be 
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;graph LR
</span></span></span><span style=display:flex><span><span style=color:#d14>        0((0)) --&#34;</span>a<span style=color:#d14>&#34;--&gt; 1((1))
</span></span></span><span style=display:flex><span><span style=color:#d14>        1((1)) --&#34;</span> <span style=color:#d14>&#34;--&gt; 2((2))
</span></span></span><span style=display:flex><span><span style=color:#d14>        2((2)) --&#34;</span>b<span style=color:#d14>&#34;--&gt; 3((3))&#34;</span>, got
</span></span><span style=display:flex><span>        <span style=color:#d14>&#34;graph LR
</span></span></span><span style=display:flex><span><span style=color:#d14>        0((0)) --&#34;</span>a<span style=color:#d14>&#34;--&gt; 1((1))
</span></span></span><span style=display:flex><span><span style=color:#d14>        1((1)) --&#34;</span> <span style=color:#d14>&#34;--&gt; 2((2))
</span></span></span><span style=display:flex><span><span style=color:#d14>        2((2)) --&#34;</span>b<span style=color:#d14>&#34;--&gt; 3((3))
</span></span></span><span style=display:flex><span><span style=color:#d14>        4((4)) --&#34;</span>b<span style=color:#d14>&#34;--&gt; 3((3))
</span></span></span><span style=display:flex><span><span style=color:#d14>        5((5)) --&#34;</span> <span style=color:#d14>&#34;--&gt; 2((2))
</span></span></span><span style=display:flex><span><span style=color:#d14>        6((6)) --&#34;</span>a<span style=color:#d14>&#34;--&gt; 1((1))&#34;</span>
</span></span><span style=display:flex><span>--- FAIL: TestState_Draw <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    --- FAIL: TestState_Draw/abc <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    --- FAIL: TestState_Draw/a_b <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Hmm, interesting. Not quite what we were expecting. To see what&rsquo;s going on, let&rsquo;s plug the output graph of our <code>abc</code> test into <a href=https://mermaid.live/>mermaids live coding site</a> and see what we&rsquo;re looking at.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>graph LR
</span></span><span style=display:flex><span>        0((0)) --&#34;a&#34;--&gt; 1((1))
</span></span><span style=display:flex><span>        1((1)) --&#34;b&#34;--&gt; 2((2))
</span></span><span style=display:flex><span>        2((2)) --&#34;c&#34;--&gt; 3((3))
</span></span><span style=display:flex><span>        4((4)) --&#34;c&#34;--&gt; 3((3))
</span></span><span style=display:flex><span>        5((5)) --&#34;b&#34;--&gt; 2((2))
</span></span><span style=display:flex><span>        6((6)) --&#34;a&#34;--&gt; 1((1))
</span></span></code></pre></div><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
1((1)) --"b"--> 2((2))
2((2)) --"c"--> 3((3))
4((4)) --"c"--> 3((3))
5((5)) --"b"--> 2((2))
6((6)) --"a"--> 1((1))</div><p>That&rsquo;s certainly not right. We seem to have dangling <code>Nodes</code> which still have <code>Transitions</code> to intermediary nodes. This should not affect the accuracy of our regex engine, as <code>States</code> <code>4</code>, <code>5</code>, and <code>6</code> cannot be reached, but it does make our drawing a bit distracting.</p><p>The error here is in our <code>state.Merge</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// adds the transitions of other State (s2) to this State (s).
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>//  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// warning: do not use if State s2 has any incoming transitions.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>merge</span>(s2 <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(s2.incoming) <span style=color:#000;font-weight:700>!=</span> <span style=color:#099>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;State (%+v) cannot be merged if it has any incoming transitions. It has incoming transitions from the following states; %+v&#34;</span>, <span style=color:#000;font-weight:700>*</span>s2, s.incoming))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> s2.transitions {  
</span></span><span style=display:flex><span>      s.<span style=color:#900;font-weight:700>addTransition</span>(t.to, t.predicate, t.debugSymbol)  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s see this in a simpler example, the regex <code>a</code>.</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
2((2)) --"a"--> 1((1))</div><p>Remember how the <code>compile</code> method of a <code>Group</code> node works? First we compile the <code>CharacterLiteral(a)</code> Node into a two-state FSM. We then create a new <code>State</code>, onto the tail of which we will merge all the children FSMs</p><div class=mermaid>graph LR
0((0))
1((1)) --"a"--> 2((2))</div><p>In this simple example, there is one merge operation, during which we copy all the transitions from <code>State 1</code> onto <code>State 0</code>. So&mldr;</p><div class=mermaid>graph LR
0((0)) -."merge".->1((0))
1((1)) --"a"--> 2((2))</div><p>Becomes&mldr;</p><div class=mermaid>graph LR
10((0)) --"a"--> 20((2))
30((1)) --"a"--> 20((2))</div><p>The problem is that the transition from <code>1</code> to <code>2</code> remains, which leads to the dangling <code>State</code> <code>1</code> remaining in our drawing.</p><p>Let&rsquo;s remove those dangling transitions. When merging transitions, we want to;</p><ol><li>copy the transitions from <code>State 1</code> to <code>State 0</code></li><li>remove those transitions from <code>State 1</code></li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>// adds the transitions of other State (s2) to this State (s).//  
</span></span><span style=display:flex><span>// warning: do not use if State s2 has any incoming transitions.  
</span></span><span style=display:flex><span>func (s *State) merge(s2 *State) {  
</span></span><span style=display:flex><span>   if len(s2.incoming) != 0 {  
</span></span><span style=display:flex><span>      panic(fmt.Sprintf(&#34;State (%+v) cannot be merged if it has any incoming transitions. It has incoming transitions from the following states; %+v&#34;, *s2, s.incoming))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   for _, t := range s2.transitions {  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+     // 1. copy s2 transitions to s
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>	  s.addTransition(t.to, t.predicate, t.debugSymbol)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+     // 2. remove s2 transitions  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+     s2.removeTransition(t)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+ func (s *State) removeTransition(target Transition) {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    newTransitions := []Transition{}  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    // 1. remove the target transition from s  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    for _, transition := range s.transitions {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       if transition == target {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+          newTransitions = append(newTransitions, transition)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       }  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    }  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    s.transitions = newTransitions  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    // 2. remove s from transition destination incoming states  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    target.to.incoming = filterState(target.to.incoming, target.from)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+ }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+ func filterState(states []*State, s2 *State) []*State {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    for i, state := range states {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       if s2 == state {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+          return append(states[:i], states[i+1:]...)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       }  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    }  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+    return states  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+ }
</span></span></span></code></pre></div><p>Now, running our tests should pass, and the output of our <code>abc</code> regex FSM should look correct.</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
1((1)) --"b"--> 2((2))
2((2)) --"c"--> 3((3))</div><p>Although nothing was strictly broken in our system, I hope that this demonstrates how useful it is to have tools like this for debugging a complex system.</p><h2 id=a-quick-command-line-tool>A quick command line tool</h2><p>Let&rsquo;s add one more thing before we finish with our vizualizer. We want to be able to use it, quickly and easily, so let&rsquo;s make a command that we can run which takes a regular expression and shows us what the compiled FSM looks like.</p><p>Let&rsquo;s set up a <code>main</code> function<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>switch</span> os.Args[<span style=color:#099>1</span>] {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#34;v5&#34;</span>:  
</span></span><span style=display:flex><span>      v5.<span style=color:#900;font-weight:700>Main</span>(os.Args[<span style=color:#099>2</span>:])  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span>  
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> v5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Main just used for linking up the main functions
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Main</span>(args []<span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>switch</span> args[<span style=color:#099>0</span>] {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#34;draw&#34;</span>:  
</span></span><span style=display:flex><span>      <span style=color:#900;font-weight:700>Draw</span>(args[<span style=color:#099>1</span>])  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>default</span>:  
</span></span><span style=display:flex><span>      fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;command not recognized&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that, we can call <code>Draw</code> from our command. Let&rsquo;s test that things are set up correctly.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Draw</span>(input <span style=color:#458;font-weight:700>string</span>) {
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;Draw called with &#34;</span> <span style=color:#000;font-weight:700>+</span> input)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can run the program with <code>go run ./.. v5 draw {input}</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>➜  search git:<span style=color:#000;font-weight:700>(</span>master<span style=color:#000;font-weight:700>)</span> ✗ go run ./... v5 draw <span style=color:#d14>&#34;abc&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Draw called with abc
</span></span></code></pre></div><p>Great, now let&rsquo;s make <code>Draw()</code> open a browser and display our <code>mermaid</code> code.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Draw</span>(input <span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   tokens <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>lex</span>(input)  
</span></span><span style=display:flex><span>   parser <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewParser</span>()  
</span></span><span style=display:flex><span>   ast <span style=color:#000;font-weight:700>:=</span> parser.<span style=color:#900;font-weight:700>Parse</span>(tokens)  
</span></span><span style=display:flex><span>   head, _ <span style=color:#000;font-weight:700>:=</span> ast.<span style=color:#900;font-weight:700>compile</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   stateDrawing <span style=color:#000;font-weight:700>:=</span> head.<span style=color:#900;font-weight:700>Draw</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   t, err <span style=color:#000;font-weight:700>:=</span> template.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;graph&#34;</span>).<span style=color:#900;font-weight:700>Parse</span>(<span style=color:#d14>`  
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;script src=&#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js&#34;&gt;&lt;/script&gt;  
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;script&gt;mermaid.initialize({startOnLoad:true});  
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;/script&gt;  
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;div class=&#34;mermaid&#34;&gt;  
</span></span></span><span style=display:flex><span><span style=color:#d14>    </span><span style=color:#999;font-weight:700;font-style:italic>{{</span><span style=color:#bbb> </span><span style=color:teal>.</span><span style=color:#bbb> </span><span style=color:#999;font-weight:700;font-style:italic>}}</span><span style=color:#d14>&lt;/div&gt;  
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;div&gt;  
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;span style=&#34;white-space: pre-wrap&#34;&gt;</span><span style=color:#999;font-weight:700;font-style:italic>{{</span><span style=color:#bbb> </span><span style=color:teal>.</span><span style=color:#bbb> </span><span style=color:#999;font-weight:700;font-style:italic>}}</span><span style=color:#d14>&lt;/span&gt;  
</span></span></span><span style=display:flex><span><span style=color:#d14>&lt;/div&gt;  
</span></span></span><span style=display:flex><span><span style=color:#d14>`</span>)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(err)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   w <span style=color:#000;font-weight:700>:=</span> bytes.Buffer{}  
</span></span><span style=display:flex><span>   err = t.<span style=color:#900;font-weight:700>Execute</span>(<span style=color:#000;font-weight:700>&amp;</span>w, stateDrawing)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   reader <span style=color:#000;font-weight:700>:=</span> strings.<span style=color:#900;font-weight:700>NewReader</span>(w.<span style=color:#900;font-weight:700>String</span>())  
</span></span><span style=display:flex><span>   err = browser.<span style=color:#900;font-weight:700>OpenReader</span>(reader)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(err)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s try that again. It should now open a browser with a visualization of your compiled FSM!</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
1((1)) --"b"--> 2((2))
2((2)) --"c"--> 3((3))</div><p>That&rsquo;s better. This tool is going to come in very handy as our program grows in complexity.</p><p>That&rsquo;s enough for visualizations for now, we can now move onto adding new features to our regex engine.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This feels pretty clunky. I would have preferred a dynamic type which implements an interface, but interface fields on structs also have problems implementing the <code>comparable</code> interface. So far, generics are still tricky to make work in Go, but it&rsquo;s still early days.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>I prefer some misdirection between the main function in order to strip away unnecessary command arguments. You might prefer to simply call <code>Draw</code> from the <code>main</code> package.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p>Previous: <a href=/posts/5-wildcards/>5 Wildcards</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>