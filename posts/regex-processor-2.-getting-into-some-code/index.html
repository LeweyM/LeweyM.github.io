<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Regex Processor - 2. Getting into some code | Lewis Metcalf</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="### The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<meta name=generator content="Hugo 0.91.2">
<meta name=robots content="noindex, nofollow">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Regex Processor - 2. Getting into some code">
<meta property="og:description" content="### The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://LeweyM.github.io/posts/regex-processor-2.-getting-into-some-code/"><meta property="article:section" content="posts">
<meta itemprop=name content="Regex Processor - 2. Getting into some code">
<meta itemprop=description content="### The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<meta itemprop=wordCount content="1553">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Regex Processor - 2. Getting into some code">
<meta name=twitter:description content="### The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Lewis Metcalf
</a>
<div class="flex-l items-center">
<div class=ananke-socials>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Regex Processor - 2. Getting into some code</h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>### The FSM data structure
We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of <code>state</code> objects.</p>
<pre tabindex=0><code>type State struct {  
	connectedStates []State  
}
</code></pre><p>We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a <code>Transition</code> struct to represent this.</p>
<p>The <code>Transition</code> struct contains two things:</p>
<ol>
<li>the next state</li>
<li>the predicate that determines whether we can go to the next state</li>
</ol>
<pre tabindex=0><code>type Transition struct {  
   // to: a pointer to the next state   
   to *State  
   // predicate: a function to determine if we should move to the next state
   predicate func(input rune) bool  
}  
</code></pre><p>The <code>Predicate</code> is a simple function that takes in a character (here we&rsquo;re using <code>rune</code> to avoid multi-byte character issues).</p>
<pre tabindex=0><code>type Predicate func(input rune) bool
</code></pre><p>Putting that together;</p>
<pre tabindex=0><code>type Predicate func(input rune) bool
  
type Transition struct {  
   to          *State  
   predicate   Predicate  
}  
  
type State struct {  
   transitions []Transition  
}

</code></pre><h3 id=running-our-state-machine>Running Our State machine</h3>
<p>Inorder to use our state machine, we&rsquo;ll need something that can process a string by running through the states, and that can give information on matches. As this is an object that runs through our state machine, we&rsquo;ll call this a <strong>Runner</strong>.</p>
<pre tabindex=0><code>type runner struct {  
   head      *State  
}
</code></pre><p>For now, all our runner needs to have is a pointer to the root (or <code>head</code>) node of our FSM.</p>
<h3 id=tests-first>Tests first</h3>
<p>We&rsquo;ll be following TDD principles when convenient in order to make sure things are working as expected (and because, personally, I find it more fun). As we now have our fundamental objects mapped out, we can now start writing some tests.</p>
<p>Our first test will check the behaviour of a simple FSM which represents the regex expression <code>abc</code>. The first thing to do is contruct the FSM. We&rsquo;ll do this &lsquo;by hand&rsquo; for now, and later we&rsquo;ll work on a <strong>compiler</strong> that can take a string like <code>"abc"</code> and build an FSM automatically.</p>
<pre tabindex=0><code>func TestHandmadeFSM(t *testing.T) {
	startState := State{}  
	stateA := State{}  
	stateB := State{}  
	stateC := State{}  
	  
	startState.transitions = append(startState.transitions, Transition{  
	   to:          &amp;stateA,  
	   predicate:   func(input rune) bool { return input == 'a' },  
	})  
	  
	stateA.transitions = append(stateA.transitions, Transition{  
	   to:          &amp;stateB,  
	   predicate:   func(input rune) bool { return input == 'b' },  
	})  
	  
	stateB.transitions = append(stateB.transitions, Transition{  
	   to:          &amp;stateC,  
	   predicate:   func(input rune) bool { return input == 'c' },  
	})
}
</code></pre><p>There&rsquo;s quite a bit going on here, so let&rsquo;s break it down a bit.</p>
<p>First, let&rsquo;s remind ourselves of the FSM structure for the regex <code>abc</code></p>
<p><img src=/img/Pasted-image-20220710201842.png alt=Pasted-image-20220710201842.png></p>
<p>There are 4 states which we have to define first.</p>
<pre tabindex=0><code>	startState := State{}  
	stateA := State{}  
	stateB := State{}  
	stateC := State{} 
</code></pre><p>Once we have our states, we need to describe the transitions between them. The first is the transition from the <code>startState</code> to <code>stateA</code>. To do this, we simply append a <code>Transition</code> object to the <code>transitions</code> property of <code>startState</code>. This new transition must point to <code>stateA</code>, and take as it&rsquo;s predicate a function that returns <code>true</code> if the input rune is <code>'a'</code>.</p>
<pre tabindex=0><code>startState.transitions = append(startState.transitions, Transition{  
   to:          &amp;stateA,  
   predicate:   func(input rune) bool { return input == 'a' },  
})  
</code></pre><p>Same goes for the remaining states.</p>
<pre tabindex=0><code>	stateA.transitions = append(stateA.transitions, Transition{  
	   to:          &amp;stateB,  
	   predicate:   func(input rune) bool { return input == 'b' },  
	})  
	  
	stateB.transitions = append(stateB.transitions, Transition{  
	   to:          &amp;stateC,  
	   predicate:   func(input rune) bool { return input == 'c' },  
	})
</code></pre><p>We now have our first FSM starting at the root node <code>startState</code>. Let&rsquo;s write a test which creates a <code>runner</code> and uses this FSM to check against a few different input cases.</p>
<p>The outcome of running a string through an FSM should result in one of 3 statuses;</p>
<ol>
<li><code>Normal</code>. The FSM has not found a match yet, but neither has it found that there is no match. Another way of saying this is that the search is still &lsquo;in progress&rsquo;.
The cases we want to test are;</li>
<li><code>Success</code>. The FSM has found a match.</li>
<li><code>fail</code>. The FSM has found that the string does not match.</li>
</ol>
<p>We can define these as consts of a specific type.</p>
<pre tabindex=0><code>type Status string  
  
const (  
   Success Status = &quot;success&quot;  
   Fail           = &quot;fail&quot;  
   Normal         = &quot;normal&quot;  
)
</code></pre><p>With that in mind we can think of a few cases to test our FSM and runner logic;</p>
<p><code>""</code> -> <code>normal</code>
<code>"x"</code> -> <code>fail</code>
<code>"abc"</code> -> <code>success</code>
<code>"ab"</code> -> <code>normal</code></p>
<p>Writing these up into table-style tests we get the following;</p>
<pre tabindex=0><code>type test struct {  
   name           string  
   input          string  
   expectedStatus Status  
}  
  
tests := []test{  
   {&quot;empty string&quot;, &quot;&quot;, Normal},  
   {&quot;non matching string&quot;, &quot;x&quot;, Fail},  
   {&quot;matching string&quot;, &quot;abc&quot;, Success},  
   {&quot;partial matching string&quot;, &quot;ab&quot;, Normal},  
}
</code></pre><p>The actual tests should simply create a runner using our hand-made FSM, iterate through the runes in the <code>input</code> string, and check that the <code>Status</code> of the runner is the same as our expected status.</p>
<pre tabindex=0><code>for _, tt := range tests {  
   t.Run(tt.name, func(t *testing.T) {  
      testRunner := NewRunner(&amp;startState)  
  
      for _, character := range tt.input {  
         testRunner.Next(character)  
      }  
  
      result := testRunner.getTotalState()  
      if tt.expectedStatus != result {  
         t.Fatalf(&quot;Expected FSM to have final state of '%v', got '%v'&quot;, tt.expectedStatus, result)  
      }  
   })  
}
</code></pre><p>Notice that we had to invent a couple of methods to make this work, such as the <code>NewRunner</code>, <code>testRunner.Next</code> and <code>testRunner.getStatus</code>. This is fine, as we&rsquo;ll come back to implementing these in a moment.</p>
<p>All together, our first test looks like this;</p>
<pre tabindex=0><code>func TestHandmadeFSM(t *testing.T) {  
   // hand-made FSM
   startState := State{}  
   stateA := State{}  
   stateB := State{}  
   stateC := State{}  
  
   startState.transitions = append(startState.transitions, Transition{  
      to:        &amp;stateA,  
      predicate: func(input rune) bool { return input == 'a' },  
   })  
  
   stateA.transitions = append(stateA.transitions, Transition{  
      to:        &amp;stateB,  
      predicate: func(input rune) bool { return input == 'b' },  
   })  
  
   stateB.transitions = append(stateB.transitions, Transition{  
      to:        &amp;stateC,  
      predicate: func(input rune) bool { return input == 'c' },  
   })  
  
   type test struct {  
      name           string  
      input          string  
      expectedStatus Status  
   }  
  
   tests := []test{  
      {&quot;empty string&quot;, &quot;&quot;, Normal},  
      {&quot;non matching string&quot;, &quot;x&quot;, Fail},  
      {&quot;matching string&quot;, &quot;abc&quot;, Success},  
      {&quot;partial matching string&quot;, &quot;ab&quot;, Normal},  
   }  
  
   for _, tt := range tests {  
      t.Run(tt.name, func(t *testing.T) {  
         testRunner := NewRunner(&amp;startState)  
  
         for _, character := range tt.input {  
            testRunner.Next(character)  
         }  
  
         result := testRunner.getTotalState()  
         if tt.expectedStatus != result {  
            t.Fatalf(&quot;Expected FSM to have final state of '%v', got '%v'&quot;, tt.expectedStatus, result)  
         }  
      })  
   }  
}

</code></pre><p>Note: One might take a look at this test and say &ldquo;The states are being instantiated once and then used in every test. This is a bad practice as one test might affect the outcome of another.&rdquo; and I would totally agree. The only reason we&rsquo;re getting away with it here is because our State Machines are <strong>stateless</strong>, meaning they don&rsquo;t contain any information about the state of the process. On the other hand, our <code>runner</code> instance is <strong>stateful</strong>, so we want to create a new instance for every test case.</p>
<p>Now that we have our first test, let&rsquo;s implement the missing methods and make these tests pass.</p>
<h3 id=runner>Runner</h3>
<p>The first method we need to implement is a simple constructor function.</p>
<pre tabindex=0><code>func NewRunner(head *State) *runner {  
   r := &amp;runner{  
      head:    head,  
      current: head,  
   }  
  
   return r  
}
</code></pre><p>This is a simple constructor which requires that we store two pointers to the root <code>State</code>. The <code>head</code> state will remain constant incase we want to reset the <code>runner</code>. The <code>current</code> state will represent where we are in the FSM, as represented by the red dot in our state machine diagrams.</p>
<p>Note: This assumes that we can only be in one place at a time in our FSM, more on that later..</p>
<p>Now, the <code>Next</code> method.</p>
<pre tabindex=0><code>func (r *runner) Next(input rune) {  
   // move along transitions  
   r.current = r.current.firstMatchingTransition(input)  
}
</code></pre><p>All this does is change the <code>r.current</code> state to the state pointed to by the first matching transition of the current state. This logic is implemented on a method of the <code>State</code> struct, so let&rsquo;s implement that now.</p>
<pre tabindex=0><code>func (s *State) firstMatchingTransition(input rune) destination {  
   for _, t := range s.transitions {  
      if t.predicate(input) {  
         return t.to  
      }  
   }  
  
   return nil  
}
</code></pre><p>This is pretty simple also. The function loops over the transitions of the state and returns the <code>destination</code> state of the first transition which passes the <code>predicate</code> test function. Notice that if the state has no <code>transition</code> which matches the predicate, the function returns <code>nil</code> - this is the same as the red dot in our diagrams leaving the FSM and represents a <code>Fail</code> case.</p>
<p>Finally, we just need to determine the status of the FSM at any time.</p>
<pre tabindex=0><code>func (r *runner) GetStatus() Status {  
   // if the current state is nil, return Fail  
   if r.current == nil {  
      return Fail  
   }  
  
   // if the current state has no transitions from it, return Success  
   if r.current.isSuccessState() {  
      return Success  
   }  
  
   // else, return normal  
   return Normal  
}
</code></pre><p>Again, the logic for determining a <code>Success</code> status is implemented as a <code>State</code> struct method.</p>
<pre tabindex=0><code>func (s *State) isSuccessState() bool {  
   if len(s.transitions) == 0 {  
      return true  
   }  
  
   return false  
}
</code></pre><p>Here we&rsquo;re using an assumption. The assumption is; if a transition leads to no other states, we can consider it a success state. This is not strictly true, but it&rsquo;s useful for now.</p>
<p>If we run the tests again, they should now be green! We now have a working, although pretty simple, finite state machine regex processor!</p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://LeweyM.github.io>
&copy; Lewis Metcalf 2022
</a>
<div>
<div class=ananke-socials>
</div></div>
</div>
</footer>
</body>
</html>