<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Regex Processor 6 Branches | Lewis Metcalf</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="## OR
Consider a regular expression like 'dog|cat', which means &ldquo;match any string containing the substring dog or the substring cat&rdquo;.
Hmm, although the structure is the same, we&rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for &#34;cat&#34; that if we process a 'c' somewhere during the the states along &#34;cat&#34;, we need to go back to the &ldquo;you&rsquo;ve seen 'c'&rdquo; state instead of the beginning.">
<meta name=generator content="Hugo 0.91.2">
<meta name=robots content="noindex, nofollow">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Regex Processor 6 Branches">
<meta property="og:description" content="## OR
Consider a regular expression like 'dog|cat', which means &ldquo;match any string containing the substring dog or the substring cat&rdquo;.
Hmm, although the structure is the same, we&rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for &#34;cat&#34; that if we process a 'c' somewhere during the the states along &#34;cat&#34;, we need to go back to the &ldquo;you&rsquo;ve seen 'c'&rdquo; state instead of the beginning.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://LeweyM.github.io/posts/regex-processor-6-branches/"><meta property="article:section" content="posts">
<meta itemprop=name content="Regex Processor 6 Branches">
<meta itemprop=description content="## OR
Consider a regular expression like 'dog|cat', which means &ldquo;match any string containing the substring dog or the substring cat&rdquo;.
Hmm, although the structure is the same, we&rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for &#34;cat&#34; that if we process a 'c' somewhere during the the states along &#34;cat&#34;, we need to go back to the &ldquo;you&rsquo;ve seen 'c'&rdquo; state instead of the beginning.">
<meta itemprop=wordCount content="393">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Regex Processor 6 Branches">
<meta name=twitter:description content="## OR
Consider a regular expression like 'dog|cat', which means &ldquo;match any string containing the substring dog or the substring cat&rdquo;.
Hmm, although the structure is the same, we&rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for &#34;cat&#34; that if we process a 'c' somewhere during the the states along &#34;cat&#34;, we need to go back to the &ldquo;you&rsquo;ve seen 'c'&rdquo; state instead of the beginning.">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Lewis Metcalf
</a>
<div class="flex-l items-center">
<div class=ananke-socials>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Regex Processor 6 Branches</h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>## OR</p>
<p>Consider a regular expression like <code>'dog|cat'</code>, which means &ldquo;match any string containing the substring <code>dog</code> or the substring <code>cat</code>&rdquo;.</p>
<p><img src=/img/Pasted-image-20220119185302.png alt=Pasted-image-20220119185302.png></p>
<p>Hmm, although the structure is the same, we&rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for <code>"cat"</code> that if we process a <code>'c'</code> somewhere during the the states along <code>"cat"</code>, we need to go back to the &ldquo;you&rsquo;ve seen <code>'c'</code>&rdquo; state instead of the beginning. In fact, most of the arrows point to the <code>'d'</code> and <code>'c'</code> states, the first letters of <code>cat</code> and <code>dog</code>. Let&rsquo;s think about how we can reduce some of the complexity here.</p>
<p>What&rsquo;s happening here is that we&rsquo;re trying to replicate how <code>grep</code> works, not how regular expressions work. A regular expression would just say &ldquo;the string starts with &ldquo;cat&rdquo; or &ldquo;dog&rdquo;, otherwise it doesn&rsquo;t match&rdquo;. Doing it this way simplifies our diagram quite a lot.</p>
<p><img src=/img/Pasted-image-20220128175219.png alt=Pasted-image-20220128175219.png></p>
<p>We can still use this to get grep-like behaviour by simply resetting the finite state machine every time it lands in a &ldquo;Failed&rdquo; state (or a &ldquo;Passed&rdquo; state if we want to count multiple matches).</p>
<h3 id=branches>Branches</h3>
<p>This is all hunky-dory when we know exactly where to go in our finite state machine, but that&rsquo;s not always the case. Consider the regex <code>"dog|dot"</code>. We might draw our FSM like so:</p>
<p><img src=/img/Pasted-image-20220128175308.png alt=Pasted-image-20220128175308.png></p>
<p>so, what happens when we come across our first &rsquo;d' character? Which way do we go? Having choices in our state machine makes into a Nondeterministic State Automata (NFA), and there&rsquo;s a load of study into these things, study I&rsquo;m far too lazy to actually do. What I do know, however, is that we can still use these to solve regular expression problems.</p>
<p>I&rsquo;m picking an easy way. Branching.</p>
<p>Basically, when I come across more than one path in my state machine, the runner (the little red dot in our pictures) will split in two and go down both paths. If one of the runners reaches a success state, it&rsquo;s a match. If all runners enter a fail state, no match. This does sacrifice some performance as we can no longer guarantee the finite state machine to determine a match in linear time, but it does make our diagrams simpler, which is good enough for now.</p>
<p><img src=/img/Pasted-image-20220128180045.png alt=Pasted-image-20220128180045.png></p>
<p><img src=/img/Pasted-image-20220128180055.png alt=Pasted-image-20220128180055.png></p>
<p><img src=/img/Pasted-image-20220128180104.png alt=Pasted-image-20220128180104.png></p>
<p><img src=/img/Pasted-image-20220128180114.png alt=Pasted-image-20220128180114.png></p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://LeweyM.github.io>
&copy; Lewis Metcalf 2022
</a>
<div>
<div class=ananke-socials>
</div></div>
</div>
</footer>
</body>
</html>