<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Regex Processor 4 testing and fuzzing | Lewis Metcalf</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="We can spend some time here doing some interesting things to our tests, which should make our lives a bit easier down the road.
Testing against the Go regex package As Go includes its own regex package, we can use this to validate our own implementation. Let&rsquo;s add a test which compares the results from our own FSM and the Go regex library.
func TestFSMAgainstGoRegexPkg(t *testing.T) { type test struct { name string regex string input string } tests := []test{ {&#34;empty string&#34;, &#34;abc&#34;, &#34;&#34;}, {&#34;non matching string&#34;, &#34;abc&#34;, &#34;xxx&#34;}, {&#34;matching string&#34;, &#34;abc&#34;, &#34;abc&#34;}, {&#34;partial matching string&#34;, &#34;abc&#34;, &#34;ab&#34;}, } for _, tt := range tests { t.">
<meta name=generator content="Hugo 0.91.2">
<meta name=robots content="noindex, nofollow">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Regex Processor 4 testing and fuzzing">
<meta property="og:description" content="We can spend some time here doing some interesting things to our tests, which should make our lives a bit easier down the road.
Testing against the Go regex package As Go includes its own regex package, we can use this to validate our own implementation. Let&rsquo;s add a test which compares the results from our own FSM and the Go regex library.
func TestFSMAgainstGoRegexPkg(t *testing.T) { type test struct { name string regex string input string } tests := []test{ {&#34;empty string&#34;, &#34;abc&#34;, &#34;&#34;}, {&#34;non matching string&#34;, &#34;abc&#34;, &#34;xxx&#34;}, {&#34;matching string&#34;, &#34;abc&#34;, &#34;abc&#34;}, {&#34;partial matching string&#34;, &#34;abc&#34;, &#34;ab&#34;}, } for _, tt := range tests { t.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://LeweyM.github.io/posts/regex-processor-4-testing-and-fuzzing/"><meta property="article:section" content="posts">
<meta itemprop=name content="Regex Processor 4 testing and fuzzing">
<meta itemprop=description content="We can spend some time here doing some interesting things to our tests, which should make our lives a bit easier down the road.
Testing against the Go regex package As Go includes its own regex package, we can use this to validate our own implementation. Let&rsquo;s add a test which compares the results from our own FSM and the Go regex library.
func TestFSMAgainstGoRegexPkg(t *testing.T) { type test struct { name string regex string input string } tests := []test{ {&#34;empty string&#34;, &#34;abc&#34;, &#34;&#34;}, {&#34;non matching string&#34;, &#34;abc&#34;, &#34;xxx&#34;}, {&#34;matching string&#34;, &#34;abc&#34;, &#34;abc&#34;}, {&#34;partial matching string&#34;, &#34;abc&#34;, &#34;ab&#34;}, } for _, tt := range tests { t.">
<meta itemprop=wordCount content="1273">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Regex Processor 4 testing and fuzzing">
<meta name=twitter:description content="We can spend some time here doing some interesting things to our tests, which should make our lives a bit easier down the road.
Testing against the Go regex package As Go includes its own regex package, we can use this to validate our own implementation. Let&rsquo;s add a test which compares the results from our own FSM and the Go regex library.
func TestFSMAgainstGoRegexPkg(t *testing.T) { type test struct { name string regex string input string } tests := []test{ {&#34;empty string&#34;, &#34;abc&#34;, &#34;&#34;}, {&#34;non matching string&#34;, &#34;abc&#34;, &#34;xxx&#34;}, {&#34;matching string&#34;, &#34;abc&#34;, &#34;abc&#34;}, {&#34;partial matching string&#34;, &#34;abc&#34;, &#34;ab&#34;}, } for _, tt := range tests { t.">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Lewis Metcalf
</a>
<div class="flex-l items-center">
<div class=ananke-socials>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Regex Processor 4 testing and fuzzing</h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>We can spend some time here doing some interesting things to our tests, which should make our lives a bit easier down the road.</p>
<h3 id=testing-against-the-go-regex-package>Testing against the Go regex package</h3>
<p>As Go includes its own <code>regex</code> package, we can use this to validate our own implementation. Let&rsquo;s add a test which compares the results from our own FSM and the Go regex library.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestFSMAgainstGoRegexPkg</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {  
   <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>test</span> <span style=color:#66d9ef>struct</span> {  
      <span style=color:#a6e22e>name</span>  <span style=color:#66d9ef>string</span>  
      <span style=color:#a6e22e>regex</span> <span style=color:#66d9ef>string</span>  
      <span style=color:#a6e22e>input</span> <span style=color:#66d9ef>string</span>  
   }  
  
   <span style=color:#a6e22e>tests</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>test</span>{  
      {<span style=color:#e6db74>&#34;empty string&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>},  
      {<span style=color:#e6db74>&#34;non matching string&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;xxx&#34;</span>},  
      {<span style=color:#e6db74>&#34;matching string&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>},  
      {<span style=color:#e6db74>&#34;partial matching string&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;ab&#34;</span>},  
   }  
  
   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>tt</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tests</span> {  
      <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>name</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {  
         <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>matchRegex</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>input</span>)  
  
         <span style=color:#a6e22e>goRegexMatch</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>regexp</span>.<span style=color:#a6e22e>MustCompile</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>regex</span>).<span style=color:#a6e22e>MatchString</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>input</span>)  
  
         <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Success</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>goRegexMatch</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>Success</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>goRegexMatch</span>) {  
            <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Mismatch - Regex: &#39;%s&#39;, Input: &#39;%s&#39; -&gt; Go Regex Pkg: &#39;%t&#39;, Our regex result: &#39;%v&#39;&#34;</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>goRegexMatch</span>, <span style=color:#a6e22e>result</span>)  
         }  
      })  
   }  
}
</code></pre></div><p>Most of the testing logic is in the <code>matchRegex</code> function, so let&rsquo;s define that also.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>matchRegex</span>(<span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>Status</span> {  
   <span style=color:#a6e22e>parser</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewParser</span>()  
   <span style=color:#a6e22e>tokens</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lex</span>(<span style=color:#a6e22e>regex</span>)  
   <span style=color:#a6e22e>ast</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>parser</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>tokens</span>)  
   <span style=color:#a6e22e>startState</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ast</span>.<span style=color:#a6e22e>compile</span>()  
   <span style=color:#a6e22e>testRunner</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewRunner</span>(<span style=color:#a6e22e>startState</span>)  
  
   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>character</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>input</span> {  
      <span style=color:#a6e22e>testRunner</span>.<span style=color:#a6e22e>Next</span>(<span style=color:#a6e22e>character</span>)  
   }  
  
   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>testRunner</span>.<span style=color:#a6e22e>GetStatus</span>()  
}
</code></pre></div><p>All we&rsquo;re doing here is setting up our lexer, parser, compiler and runner, then running through each character in the input. After running through the input string, we return the status.</p>
<p>Our tests should still be green.</p>
<p>Let&rsquo;s compare the test structs between this and our previous tests.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// old tests
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>test</span> <span style=color:#66d9ef>struct</span> {  
   <span style=color:#a6e22e>name</span>           <span style=color:#66d9ef>string</span>  
   <span style=color:#a6e22e>input</span>          <span style=color:#66d9ef>string</span>  
   <span style=color:#a6e22e>expectedStatus</span> <span style=color:#a6e22e>Status</span>  
}

<span style=color:#75715e>// new tests
</span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>test</span> <span style=color:#66d9ef>struct</span> {  
  <span style=color:#a6e22e>name</span>  <span style=color:#66d9ef>string</span>  
  <span style=color:#a6e22e>regex</span> <span style=color:#66d9ef>string</span>  
  <span style=color:#a6e22e>input</span> <span style=color:#66d9ef>string</span>  
}  
</code></pre></div><p>Notice that we no longer require the <code>Status</code> field. This is because we no longer need to specify the result, as the Go library does that for us!</p>
<p>Adding a new test case is pretty simple, we just need the inputs and the test is ready to go;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>tests := []test{  
   {&#34;empty string&#34;, &#34;abc&#34;, &#34;&#34;},  
   {&#34;non matching string&#34;, &#34;abc&#34;, &#34;xxx&#34;},  
   {&#34;matching string&#34;, &#34;abc&#34;, &#34;abc&#34;},  
   {&#34;partial matching string&#34;, &#34;abc&#34;, &#34;ab&#34;},  
<span style=color:#a6e22e>+  {&#34;nested expressions&#34;, &#34;a(b(d))c&#34;, &#34;abdc&#34;},  
</span><span style=color:#a6e22e></span>}
</code></pre></div><p>Having a way of automatically computing the desired output for a test not only makes writing the tests less work, but also open up some interesting possibilities, such as Fuzzing.</p>
<h3 id=fuzzing>Fuzzing</h3>
<p>Go 1.18 introduced <a href=https://go.dev/doc/fuzz/>fuzzing</a> to its standard library, which is an automated way of barraging your code with semi-random input to try to find hidden errors.</p>
<p>Let&rsquo;s write a simple fuzz test.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>FuzzFSM</span>(<span style=color:#a6e22e>f</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>F</span>) {  
   <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>)  
   <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)  
   <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;xxx&#34;</span>)  
   <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;ca(t)(s)&#34;</span>, <span style=color:#e6db74>&#34;dog&#34;</span>)  
  
   <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Fuzz</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span> <span style=color:#66d9ef>string</span>) {  
      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ContainsAny</span>(<span style=color:#a6e22e>regex</span>, <span style=color:#e6db74>&#34;$^|*+?.\\&#34;</span>) {  
         <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Skip</span>()  
      }  
  
      <span style=color:#a6e22e>compiledGoRegex</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>regexp</span>.<span style=color:#a6e22e>Compile</span>(<span style=color:#a6e22e>regex</span>)  
      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
         <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Skip</span>()  
      }  
  
      <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>matchRegex</span>(<span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span>)  
      <span style=color:#a6e22e>goRegexMatch</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>compiledGoRegex</span>.<span style=color:#a6e22e>MatchString</span>(<span style=color:#a6e22e>input</span>)  
  
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Success</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>goRegexMatch</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Fail</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>goRegexMatch</span>) {  
         <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Mismatch - Regex: &#39;%s&#39;, Input: &#39;%s&#39; -&gt; Go Regex Pkg: &#39;%t&#39;, Our regex result: &#39;%v&#39;&#34;</span>, <span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>goRegexMatch</span>, <span style=color:#a6e22e>result</span>)  
      }  
   })  
}
</code></pre></div><p>Let&rsquo;s step through this a bit. First, we need to add a few examples of input to our test function so that Go can seed the test corpus.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>)  
<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>)  
<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#e6db74>&#34;xxx&#34;</span>)  
<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#e6db74>&#34;ca(t)(s)&#34;</span>, <span style=color:#e6db74>&#34;dog&#34;</span>)  
</code></pre></div><p>Now for the test function;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Fuzz</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>, <span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span> <span style=color:#66d9ef>string</span>) {  
      <span style=color:#a6e22e>compiledGoRegex</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>regexp</span>.<span style=color:#a6e22e>Compile</span>(<span style=color:#a6e22e>regex</span>)  
      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {  
         <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Skip</span>()  
      }  
  
      <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>matchRegex</span>(<span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span>)  
      <span style=color:#a6e22e>goRegexMatch</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>compiledGoRegex</span>.<span style=color:#a6e22e>MatchString</span>(<span style=color:#a6e22e>input</span>)  
  
      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Success</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>goRegexMatch</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Fail</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>goRegexMatch</span>) {  
         <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Mismatch - Regex: &#39;%s&#39;, Input: &#39;%s&#39; -&gt; Go Regex Pkg: &#39;%t&#39;, Our regex result: &#39;%v&#39;&#34;</span>, <span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>goRegexMatch</span>, <span style=color:#a6e22e>result</span>)  
      }  
   })  
</code></pre></div><p>First, we only want to test valid regex statements, so any invalid statements we can simply ignore.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>ContainsAny</span>(<span style=color:#a6e22e>regex</span>, <span style=color:#e6db74>&#34;$^|*+?.\\&#34;</span>) {  
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Skip</span>()  
}  
</code></pre></div><p>After that, we can simply test in the same way as in our previous test.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>matchRegex</span>(<span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span>)  
<span style=color:#a6e22e>goRegexMatch</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>compiledGoRegex</span>.<span style=color:#a6e22e>MatchString</span>(<span style=color:#a6e22e>input</span>)  

<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Success</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>goRegexMatch</span>) <span style=color:#f92672>||</span> (<span style=color:#a6e22e>result</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>Fail</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>goRegexMatch</span>) {  
	<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Mismatch - Regex: &#39;%s&#39;, Input: &#39;%s&#39; -&gt; Go Regex Pkg: &#39;%t&#39;, Our regex result: &#39;%v&#39;&#34;</span>, <span style=color:#a6e22e>regex</span>, <span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>goRegexMatch</span>, <span style=color:#a6e22e>result</span>)  
}  
</code></pre></div><p>Let&rsquo;s see what happens when we run this fuzz test. Use the following command line instruction;</p>
<pre tabindex=0><code>go test ./src/v3/... -fuzz ^FuzzFSM$
</code></pre><p>Note: Your path might be different, use the path of the package with the test and FSM implementation.</p>
<p>We found an error!</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>➜  search git:<span style=color:#f92672>(</span>master<span style=color:#f92672>)</span> ✗ go test ./src/v3/... -fuzz ^FuzzFSM$

fuzz: elapsed: 0s, gathering baseline coverage: 0/1110 completed
failure <span style=color:#66d9ef>while</span> testing seed corpus entry: FuzzFSM/08fa440d20a250cf53d6090f036f15915901b50eb6d2958bb4b00ce71de7ec7a
fuzz: elapsed: 0s, gathering baseline coverage: 3/1110 completed
--- FAIL: FuzzFSM <span style=color:#f92672>(</span>0.21s<span style=color:#f92672>)</span>
    --- FAIL: FuzzFSM <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
        v3_test.go:106: Mismatch - Regex: <span style=color:#e6db74>&#39;aA&#39;</span>, Input: <span style=color:#e6db74>&#39;aaA&#39;</span> -&gt; Go Regex Pkg: <span style=color:#e6db74>&#39;true&#39;</span>, Our regex result: <span style=color:#e6db74>&#39;fail&#39;</span>

</code></pre></div><p>It seems that passing <code>aaA</code> to the regex <code>aA</code> fails for our implementation, but passes for the Go implementation. This makes sense, because the Go regex package <code>MatchString</code> method we&rsquo;re using will look for a match anywhere in the string, whereas we&rsquo;re looking only at the beginning of the string.</p>
<p>Let&rsquo;s modify our test function to reset our FSM if there is a failure. That way, we will find matches at any point in the string, not just the beginning.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>func matchRegex(regex, input string) Status {  
   parser := NewParser()  
   tokens := lex(regex)  
   ast := parser.Parse(tokens)  
   startState, _ := ast.compile()  
   testRunner := NewRunner(startState)  
  
   for _, character := range input {  
      testRunner.Next(character)  
<span style=color:#a6e22e>+     status := testRunner.GetStatus()  
</span><span style=color:#a6e22e>+	  if status == Fail {  
</span><span style=color:#a6e22e>+	    testRunner.Reset()  
</span><span style=color:#a6e22e>+       continue  
</span><span style=color:#a6e22e>+     }  
</span><span style=color:#a6e22e>+  
</span><span style=color:#a6e22e>+	  if status != Normal {  
</span><span style=color:#a6e22e>+	     return status  
</span><span style=color:#a6e22e>+	  }
</span><span style=color:#a6e22e></span>   }  
  
   return testRunner.GetStatus()  
}
</code></pre></div><p>Let&rsquo;s run the fuzzer again.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>➜  search git:<span style=color:#f92672>(</span>master<span style=color:#f92672>)</span> ✗ go test ./src/v3/... -fuzz ^FuzzFSM$

fuzz: elapsed: 0s, gathering baseline coverage: 0/1110 completed
failure <span style=color:#66d9ef>while</span> testing seed corpus entry: FuzzFSM/95ebf188425a8fea7bfa9c05c938a499ff954ba884b7ef41c853b245b4b85cb4
fuzz: elapsed: 0s, gathering baseline coverage: 12/1110 completed
--- FAIL: FuzzFSM <span style=color:#f92672>(</span>0.22s<span style=color:#f92672>)</span>
    --- FAIL: FuzzFSM <span style=color:#f92672>(</span>0.00s<span style=color:#f92672>)</span>
        v3_test.go:105: Mismatch - Regex: <span style=color:#e6db74>&#39;.&#39;</span>, Input: <span style=color:#e6db74>&#39;&#39;</span> -&gt; Go Regex Pkg: <span style=color:#e6db74>&#39;false&#39;</span>, Our regex result: <span style=color:#e6db74>&#39;success&#39;</span>
    
FAIL

</code></pre></div><p>We&rsquo;re now failing when using the regex <code>.</code> and an input string. This makes sense too because we haven&rsquo;t implemented the wildcard character <code>.</code> (yet). For now, let&rsquo;s ignore these special characters in our fuzz tests.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>f.Fuzz(func(t *testing.T, regex, input string) {  
<span style=color:#a6e22e>+     if strings.ContainsAny(regex, &#34;$^|*+?.\\&#34;) {  
</span><span style=color:#a6e22e>+        t.Skip()  
</span><span style=color:#a6e22e>+     }  
</span><span style=color:#a6e22e></span>  
      compiledGoRegex, err := regexp.Compile(regex)  
      if err != nil {  
         t.Skip()  
      }  
  
      result := matchRegex(regex, input)  
      goRegexMatch := compiledGoRegex.MatchString(input)  
  
      if (result == Success &amp;&amp; !goRegexMatch) || (result == Fail &amp;&amp; goRegexMatch) {  
         t.Fatalf(&#34;Mismatch - Regex: &#39;%s&#39;, Input: &#39;%s&#39; -&gt; Go Regex Pkg: &#39;%t&#39;, Our regex result: &#39;%v&#39;&#34;, regex, input, goRegexMatch, result)  
      }  
   })  
</code></pre></div><p>If we run the fuzzer now, we see something like this;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh>➜  search git:<span style=color:#f92672>(</span>master<span style=color:#f92672>)</span> ✗ go test ./src/v3/... -fuzz ^FuzzFSM$

fuzz: elapsed: 0s, gathering baseline coverage: 0/1110 completed
fuzz: elapsed: 0s, gathering baseline coverage: 1110/1110 completed, now fuzzing with <span style=color:#ae81ff>8</span> workers
fuzz: elapsed: 3s, execs: <span style=color:#ae81ff>481830</span> <span style=color:#f92672>(</span>160569/sec<span style=color:#f92672>)</span>, new interesting: <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>total: 1110<span style=color:#f92672>)</span>
fuzz: elapsed: 6s, execs: <span style=color:#ae81ff>1041643</span> <span style=color:#f92672>(</span>186630/sec<span style=color:#f92672>)</span>, new interesting: <span style=color:#ae81ff>0</span> <span style=color:#f92672>(</span>total: 1110<span style=color:#f92672>)</span>
fuzz: elapsed: 9s, execs: <span style=color:#ae81ff>1540600</span> <span style=color:#f92672>(</span>166326/sec<span style=color:#f92672>)</span>, new interesting: <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>total: 1111<span style=color:#f92672>)</span>
fuzz: elapsed: 12s, execs: <span style=color:#ae81ff>1997730</span> <span style=color:#f92672>(</span>152333/sec<span style=color:#f92672>)</span>, new interesting: <span style=color:#ae81ff>1</span> <span style=color:#f92672>(</span>total: 1111<span style=color:#f92672>)</span>
fuzz: elapsed: 15s, execs: <span style=color:#ae81ff>2593993</span> <span style=color:#f92672>(</span>198784/sec<span style=color:#f92672>)</span>, new interesting: <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>total: 1112<span style=color:#f92672>)</span>
fuzz: elapsed: 18s, execs: <span style=color:#ae81ff>3120415</span> <span style=color:#f92672>(</span>175505/sec<span style=color:#f92672>)</span>, new interesting: <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>total: 1112<span style=color:#f92672>)</span>
fuzz: elapsed: 21s, execs: <span style=color:#ae81ff>3654537</span> <span style=color:#f92672>(</span>178003/sec<span style=color:#f92672>)</span>, new interesting: <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>total: 1112<span style=color:#f92672>)</span>
</code></pre></div><p>Fuzzing won&rsquo;t give us a green light like tests will. Fuzzing is an <a href="https://www.synopsys.com/blogs/software-security/fuzzing-test-cases-not-all-random/#:~:text=Fuzzing%20is%20an%20infinite%20space%20problem.%20For%20any%20piece%20of%20software%2C%20you%20can%20create%20an%20infinite%20number%20of%20malformed%20inputs.%20To%20get%20useful%20results%20in%20a%20reasonable%20amount%20of%20time%2C%20the%20trick%20is%20to%20select%20inputs%20that%20are%20most%20likely%20to%20cause%20failures%20in%20the%20target%20software.">infinite space problem</a>, meaning that it will never &lsquo;finish&rsquo;, but if we run it long enough we can be fairly confident that our algorithm is pretty error-proof. I let it run for a few minutes before I declared it a success.</p>
<p>Great! Let&rsquo;s move onto adding some more functionality to our FSM.</p>
<p>Next:<a href=https://LeweyM.github.io/posts/regex-processor-5-a-bit-more-theory/>Regex Processor 5 A bit more theory</a></p>
<p>Prev:<a href=https://LeweyM.github.io/posts/regex-processor-3-starting-the-compiler/>Regex Processor 3 Starting the compiler</a></p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://LeweyM.github.io>
&copy; Lewis Metcalf 2022
</a>
<div>
<div class=ananke-socials>
</div></div>
</div>
</footer>
</body>
</html>