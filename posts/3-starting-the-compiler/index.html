<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>3 Starting the compiler - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="3 Starting the compiler"><meta property="og:description" content="Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/posts/3-starting-the-compiler/"><meta property="article:section" content="posts"><meta property="og:see_also" content="https://leweym.github.io/posts/1-intro/"><meta property="og:see_also" content="https://leweym.github.io/posts/2-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/posts/4-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/posts/5-wildcards/"><meta property="og:see_also" content="https://leweym.github.io/posts/6-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="3 Starting the compiler"><meta name=twitter:description content="Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><script src=https://leweym.github.io/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/posts/1-intro/>1 Intro</a> <span class=meta></span></div><div class=post><a href=/posts/2-getting-into-some-code/>2 Getting into some code</a> <span class=meta></span></div><div class=post><span>3 Starting the compiler</span></div><div class=post><a href=/posts/4-testing-fuzzing-and-fixing-things/>4 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/posts/5-wildcards/>5 Wildcards</a> <span class=meta></span></div><div class=post><a href=/posts/6-pretty-vizualizations/>6 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/posts/7-branches/>7 Branches</a> <span class=meta></span></div><div class=post><a href=/posts/8-epsilons/>8 Epsilons</a> <span class=meta></span></div><div class=post><a href=/posts/9-groups/>9 Groups</a> <span class=meta></span></div></div></div><br><div class=post-header><h1 class=title>3 Starting the compiler</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#compiling-a-finite-state-machine>Compiling a Finite State Machine</a></li><li><a href=#lexing>Lexing</a></li><li><a href=#parsing>Parsing</a></li><li><a href=#compile>Compile</a></li><li><a href=#coding-the-lexer>Coding the lexer</a></li><li><a href=#coding-the-parser>Coding the parser</a></li><li><a href=#building-the-abstract-syntax-tree>Building the Abstract Syntax Tree</a></li><li><a href=#our-first-compiler>Our first compiler</a></li><li><a href=#the-power-of-structure>The power of structure</a></li><li><a href=#changing-our-tests>Changing our tests</a></li></ul></nav></aside><div class=markdown><p>Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a <strong>compiler</strong>.</p><h2 id=compiling-a-finite-state-machine>Compiling a Finite State Machine</h2><p>We can break down the previous example of writing an FSM for the regular expression <code>abc</code> into at least 2 discrete steps;</p><ol><li>Take the string <code>abc</code> and create a linked list of <code>'states'</code> with conditional transitions to other states.</li><li>Process the input by moving through the states.</li></ol><p>We&rsquo;ll call these steps <code>compile</code> and <code>evaluate</code> respectively.</p><p>So far, we&rsquo;ve only looked at the <code>evaluate</code> step, where we take an already made FSM and process an input string by moving through its states. Now we&rsquo;ll look at the <code>compile</code> step.</p><p><code>compile</code> in this context, means turning a string of characters that represent a valid regular expression into a linked list of states; a finite state machine. For this, we will create a <code>Compiler</code> struct with a <code>Compile</code> method which takes a string and returns a <code>*State</code> representing the first <code>State</code> of the FSM, the <code>root</code> or <code>head</code> <code>State</code>.</p><p>Let&rsquo;s do even more decomposition of this problem and break the compilation step into three phases;</p><ol><li>lexing</li><li>parsing</li><li>compiling</li></ol><p>Let&rsquo;s go through these 3 steps in detail.</p><h2 id=lexing>Lexing</h2><p>Before we start turning strings into complex abstract objects, it helps to turn them into something a bit easier to work with. In the &lsquo;Lexing&rsquo; stage, that&rsquo;s what we do. We simply convert the different types of characters into <code>tokens</code> which can be more easily interpreted by our program.</p><h2 id=parsing>Parsing</h2><p>Once we have our <code>tokens</code>, we want to build something called an &lsquo;Abstract Syntax Tree&rsquo; - or an <code>AST</code> for short. The <code>AST</code> is a tree which represents the <em>hierarchical relationship</em> of the regular expression. In other words, in this stage we describe the <strong>structure</strong> of the expression.</p><p>An example of the structure of regular expression <code>(cat)</code> might look like this;</p><div class=mermaid>graph TD
0(Group) --> 1[c]
0(Group) --> 2[a]
0(Group) --> 3[t]</div><p>This tree shows the relationship between a <code>group</code> (whatever is inside the parenthesis) and the three <code>char</code> literals which make up the expression <code>cat</code>. To simplify things, we&rsquo;re going to imagine that all regular expressions exist inside a top-level <code>group</code>, so <code>cat</code> is equivalent to <code>(cat)</code>.</p><p>This hierarchy can become more complicated when things like nested groups or <code>branches</code> are involved. For example, the <code>AST</code> for <code>(ca(r|t)s)</code> looks like this;</p><div class=mermaid>graph TD
10(Group) --> 11[c]
10(Group) --> 21[a]
10(Group) --> 31(Group)
31(Group) --> 32(Branch)
32 --> 41[r]
32 --> 42[t]
10(Group) --> 51[s]</div><p>The important thing to know about this step is that here we are describing the <strong>structure</strong> of the expression, and that this structure is <strong>recursive</strong>. We can isolate any node and process its children, without needing knowledge from elsewhere in the tree. In other words, each <strong>subtree</strong> can be treated in the same way as the <strong>tree</strong>, which is very useful in reducing complexity.</p><p>Having this structure will make our lives a lot easier in the next step.</p><h2 id=compile>Compile</h2><p>Here, we actually build the <code>States</code> from the <code>AST</code> we created in the previous step.</p><p>The end result should be a linked list of <code>States</code> which should represent our regular expression, and a reference to the root <code>State</code>. The way we produce this from our <code>AST</code> is by asking each node to produce an FSM, which will in-turn ask any child nodes to produce an FSM and compose them together, until we reach the leaf nodes - which have no children - and the process ends.</p><p>This is where we see the power of recursive structures, as each node must produce an FSM, but nested structures don&rsquo;t need to know anything about how their children produce FSMs - in fact those children might be nested structures themselves. This is a very powerful and flexible concept, and very useful for what we&rsquo;re trying to do now.</p><p>Now that we&rsquo;ve described our three phases, let&rsquo;s jump into some code.</p><h2 id=coding-the-lexer>Coding the lexer</h2><p>In this implementation, we&rsquo;re going to support a subset of regex special characters;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>().<span style=color:#000;font-weight:700>*</span><span style=color:#a61717;background-color:#e3d2d2>?</span><span style=color:#000;font-weight:700>+</span>|
</span></span></code></pre></div><p>For simplicity, we&rsquo;re not going to support escaped characters such as <code>\?</code>. Any character not in the set above is to be considered a character literal.</p><p>Let&rsquo;s define these special characters as <code>symbols</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// lexer.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> symbol <span style=color:#458;font-weight:700>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> (
</span></span><span style=display:flex><span>	AnyCharacter symbol = <span style=color:#000;font-weight:700>iota</span>
</span></span><span style=display:flex><span>	Pipe
</span></span><span style=display:flex><span>	LParen
</span></span><span style=display:flex><span>	RParen
</span></span><span style=display:flex><span>	Character
</span></span><span style=display:flex><span>	ZeroOrMore
</span></span><span style=display:flex><span>	OneOrMore
</span></span><span style=display:flex><span>	ZeroOrOne
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>Notice we also include the symbol <code>character</code> which represents any character which is not a special character.</p><p>Using these <code>symbols</code>, we can create a <code>token</code> struct which contains information on the type of symbol, and the character itself, if necessary.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// lexer.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> token <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   symbol symbol  
</span></span><span style=display:flex><span>   letter <span style=color:#458;font-weight:700>rune</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we simply need to loop through the regular expression string and map the characters to our tokens.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// lexer.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>lex</span>(input <span style=color:#458;font-weight:700>string</span>) []token {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>var</span> tokens []token  
</span></span><span style=display:flex><span>   i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> i &lt; <span style=color:#0086b3>len</span>(input) {  
</span></span><span style=display:flex><span>      tokens = <span style=color:#0086b3>append</span>(tokens, <span style=color:#900;font-weight:700>lexRune</span>(<span style=color:#0086b3>rune</span>(input[i])))  
</span></span><span style=display:flex><span>      i<span style=color:#000;font-weight:700>++</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> tokens  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>lexRune</span>(r <span style=color:#458;font-weight:700>rune</span>) token {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>var</span> s token  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>switch</span> r {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#39;(&#39;</span>:  
</span></span><span style=display:flex><span>      s.symbol = LParen  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#39;)&#39;</span>:  
</span></span><span style=display:flex><span>      s.symbol = RParen  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#39;.&#39;</span>:  
</span></span><span style=display:flex><span>      s.symbol = AnyCharacter  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#39;|&#39;</span>:  
</span></span><span style=display:flex><span>      s.symbol = Pipe  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#39;*&#39;</span>:  
</span></span><span style=display:flex><span>      s.symbol = ZeroOrMore  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#39;+&#39;</span>:  
</span></span><span style=display:flex><span>      s.symbol = OneOrMore  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#39;?&#39;</span>:  
</span></span><span style=display:flex><span>      s.symbol = ZeroOrOne  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>default</span>:  
</span></span><span style=display:flex><span>      s.symbol = Character  
</span></span><span style=display:flex><span>      s.letter = r  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> s  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s really all there is to it. Now instead of a string of characters, we have our own defined <code>tokens</code> to work with.</p><p>We&rsquo;ll now use those <code>tokens</code> to build our <code>AST</code></p><h2 id=coding-the-parser>Coding the parser</h2><p>For our simple example of parsing the regular expression <code>abc</code>, we just need two types of <code>AST</code>node: <code>Group</code> and <code>CharacterLiteral</code>.</p><p>Let&rsquo;s remind ourselves quickly of how these AST nodes relate to each other with our <code>AST</code> diagram.</p><div class=mermaid>graph TD
0(Group) --> 1[c]
0(Group) --> 2[a]
0(Group) --> 3[t]</div><p>A <code>group</code> <strong>contains</strong> three child nodes. The child nodes are <code>characterLiterals</code> and are the <strong>leaf nodes</strong> of the tree.</p><p>Let&rsquo;s create two structs to represent these nodes.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Group <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   ChildNodes []Node  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> CharacterLiteral <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   Character <span style=color:#458;font-weight:700>rune</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ll need a way to add child nodes to the <code>Group</code> struct, so let&rsquo;s add a simple method for that.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (g <span style=color:#000;font-weight:700>*</span>Group) <span style=color:#900;font-weight:700>Append</span>(node Node) {  
</span></span><span style=display:flex><span>   g.ChildNodes = <span style=color:#0086b3>append</span>(g.ChildNodes, node)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we want all nodes to be compilable, although we&rsquo;ll get to actually <em>how</em> to compile them a bit later. Let&rsquo;s use an interface to show that they share this functionality.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Node <span style=color:#000;font-weight:700>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we&rsquo;ll leave these methods unimplemented for now</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (g <span style=color:#000;font-weight:700>*</span>Group) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;implement me&#34;</span>)
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (l CharacterLiteral) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;implement me&#34;</span>) 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, let&rsquo;s use another interface for composite nodes - those with the ability to contain child nodes. This will make things easier when we add other types of composite nodes other than just <code>Group</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> CompositeNode <span style=color:#000;font-weight:700>interface</span> {  
</span></span><span style=display:flex><span>   Node  
</span></span><span style=display:flex><span>   <span style=color:#900;font-weight:700>Append</span>(node Node)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Ok, now we have our <code>AST</code> nodes defined, let&rsquo;s take a look at how to parse a string into a tree.</p><h2 id=building-the-abstract-syntax-tree>Building the Abstract Syntax Tree</h2><p>Building the parser is going to be one of the more complex pieces of this project, so it helps to have tests just for this. Let&rsquo;s start with a simple test to make it clear what we&rsquo;re trying to produce.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// parser_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>TestParser</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>      name, input    <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>      expectedResult Node  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tests <span style=color:#000;font-weight:700>:=</span> []test{  
</span></span><span style=display:flex><span>      {name: <span style=color:#d14>&#34;simple string&#34;</span>, input: <span style=color:#d14>&#34;aBc&#34;</span>, expectedResult: <span style=color:#000;font-weight:700>&amp;</span>Group{  
</span></span><span style=display:flex><span>         ChildNodes: []Node{  
</span></span><span style=display:flex><span>            CharacterLiteral{Character: <span style=color:#d14>&#39;a&#39;</span>},  
</span></span><span style=display:flex><span>            CharacterLiteral{Character: <span style=color:#d14>&#39;B&#39;</span>},  
</span></span><span style=display:flex><span>            CharacterLiteral{Character: <span style=color:#d14>&#39;c&#39;</span>},  
</span></span><span style=display:flex><span>         },  
</span></span><span style=display:flex><span>      }},  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, tt <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tests {  
</span></span><span style=display:flex><span>      t.<span style=color:#900;font-weight:700>Run</span>(tt.name, <span style=color:#000;font-weight:700>func</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>		  tokens <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>lex</span>(tt.input)  
</span></span><span style=display:flex><span>		  p <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewParser</span>(tokens)  
</span></span><span style=display:flex><span>		  result <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>Parse</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		 <span style=color:#000;font-weight:700>if</span> !reflect.<span style=color:#900;font-weight:700>DeepEqual</span>(result, tt.expectedResult) {  
</span></span><span style=display:flex><span>			t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;Expected:\n%+v\n\nGot:\n%+v\n&#34;</span>, tt.expectedResult, result)
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      })  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So, in our <code>simple string</code> test, we&rsquo;re using as an input the string <code>aBc</code> and we hope to create the following <code>Group</code> struct:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// parser_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>&amp;</span>Group{  
</span></span><span style=display:flex><span>	ChildNodes: []Node{  
</span></span><span style=display:flex><span>		CharacterLiteral{Character: <span style=color:#d14>&#39;a&#39;</span>},  
</span></span><span style=display:flex><span>		CharacterLiteral{Character: <span style=color:#d14>&#39;B&#39;</span>},  
</span></span><span style=display:flex><span>		CharacterLiteral{Character: <span style=color:#d14>&#39;c&#39;</span>},  
</span></span><span style=display:flex><span>	},  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Parsing such a simple example is very easy - we would simply initialize a new <code>Group</code>, then loop over the characters and append them to the <code>Group</code>. This <code>Group</code> will be our root <code>Node</code>, and will a pointer to it can simply be returned after all the tokens have been processed.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// parser.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Parser <span style=color:#000;font-weight:700>struct</span>{  
</span></span><span style=display:flex><span>   tokens   []token  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>NewParser</span>(tokens []token) <span style=color:#000;font-weight:700>*</span>Parser {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>&amp;</span>Parser{tokens: tokens}  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Parser) <span style=color:#900;font-weight:700>Parse</span>() Node {  
</span></span><span style=display:flex><span>   root <span style=color:#000;font-weight:700>:=</span> Group{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> p.tokens {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>switch</span> t.symbol {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>case</span> Character:  
</span></span><span style=display:flex><span>         root.<span style=color:#900;font-weight:700>Append</span>(CharacterLiteral{Character: t.letter})  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>&amp;</span>root
</span></span></code></pre></div><p>As our tests are now green, let&rsquo;s leave it there and move onto the next step - there&rsquo;ll be plenty of complexity to dive into later as we introduce nested structures.</p><p>Now, turning an <code>AST</code> into a compiled FSM.</p><h2 id=our-first-compiler>Our first compiler</h2><p>Compiling the <code>AST</code> into <code>State</code> objects can be tricky. The trick to keeping this step simple (and it can very quickly become <strong>not</strong> simple) is to let each node of the <code>AST</code> decide how it should be compiled.</p><p>For our simple example of compiling the regular expression <code>abc</code>, we just need two types of <code>AST</code> node;</p><ol><li><code>CharacterLiteral</code></li><li><code>Group</code></li></ol><p>We saw these in the diagram above as &lsquo;group&rsquo; and &lsquo;char&rsquo; boxes. Let&rsquo;s go through them.</p><ol><li><code>CharacterLiteral</code></li></ol><p>The <code>CharacterLiteral</code> node represents a single character. It does not contain any inner nodes, so it is a leaf node of the <code>AST</code>.</p><p>Compiling a <code>CharacterLiteral</code> node is fairly straight forward. A character literal for the expression <code>a</code> should look like this;</p><p><img src=/img/Pasted-image-20220807175929.png alt=Pasted-image-20220807175929.png></p><p>That&rsquo;s really all there is to it. It&rsquo;s a two <code>State</code> system with a single transition between them, using the character of the <code>CharacterLiteral</code> as the transition predicate.</p><p>Let&rsquo;s encode this behavior in the <code>Compile</code> method of the <code>CharacterLiteral</code> node object.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (l CharacterLiteral) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// create the first state
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	startingState <span style=color:#000;font-weight:700>:=</span> State{} 
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// create the second state
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	endState <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// add a transition between the two states, using the character as the transition predicate
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	startingState.<span style=color:#900;font-weight:700>addTransition</span>(<span style=color:#000;font-weight:700>&amp;</span>endState, <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> l.Character })  
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// return the head and tail states of this FSM
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>&amp;</span>startingState, <span style=color:#000;font-weight:700>&amp;</span>endState
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li><code>Group</code></li></ol><p>The <code>Group</code> node represents a collection of <code>AST</code> nodes which need to appear consecutively in the input string. For example, <code>abc</code> would be a <code>Group</code> of 3 <code>CharacterLiteral</code> nodes. The inner nodes of <code>Group</code> do not have to be <code>CharacterLiterals</code>, however. For example, <code>(()()())</code> would be a <code>Group</code> of 3 <code>Group</code> nodes.</p><p>Compiling a <code>Group</code> node is a case of merging together it&rsquo;s child nodes so that the last state of one child is merged with the first state of the next child.</p><p>Let&rsquo;s look at this visually for our example of <code>abc</code></p><p><img src=/img/Pasted-image-20220807181511.png alt=Pasted-image-20220807181511.png></p><p>The <code>group</code> contains three <code>characterLiteral</code> nodes, compiled into their two <code>State</code> form. We begin by merging the states from left to right. This means taking the tail of the first FSM and merging it with the head of the second FSM.</p><p><img src=/img/Pasted-image-20220807181731.png alt=Pasted-image-20220807181731.png></p><p>Which leaves us with;</p><p><img src=/img/Pasted-image-20220807181749.png alt=Pasted-image-20220807181749.png></p><p>We can repeat this process of merging the tail of the left-most FSM with the head of the second FSM until we are left with a single, compiled FSM.</p><p><img src=/img/Pasted-image-20220807181855.png alt=Pasted-image-20220807181855.png></p><p><img src=/img/Pasted-image-20220807181901.png alt=Pasted-image-20220807181901.png></p><p>Let&rsquo;s add this to the <code>Compile</code> method of the <code>Group</code> struct. This will be a bit more tricky than the <code>CharacterLiteral</code> node.</p><p>First, let&rsquo;s build a starting <code>State</code> for this FSM.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (g <span style=color:#000;font-weight:700>*</span>Group) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   startState <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// [...]
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>} 
</span></span></code></pre></div><p>Next, we want to loop over the child nodes and do the following;</p><ol><li>compile the child node</li><li>merge the tail of the first node with the head of the second node</li><li>mark the tail of the second node as the new tail</li></ol><p>The third step is important as it tells us which state we need to merge next in the iteration, and allows the FSM to grow to the right, as in the diagrams.</p><p>Putting this all together, we have the following <code>Compile</code> function;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (g <span style=color:#000;font-weight:700>*</span>Group) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   startState <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>   currentTail <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>startState  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, expression <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> g.ChildNodes {  
</span></span><span style=display:flex><span>      nextStateHead, nextStateTail <span style=color:#000;font-weight:700>:=</span> expression.<span style=color:#900;font-weight:700>compile</span>()  
</span></span><span style=display:flex><span>      currentTail.<span style=color:#900;font-weight:700>merge</span>(nextStateHead)  
</span></span><span style=display:flex><span>      currentTail = nextStateTail  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>&amp;</span>startState, currentTail  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=the-power-of-structure>The power of structure</h2><p>Here, I hope it starts to become clear why we separate the <code>compiling</code> from the <code>lexing</code> and <code>parsing</code> stages. Once we have the <strong>structure</strong> of the expression, it&rsquo;s much easier to decompose the compilation into leaf nodes, such as a single letter, and composing nodes which hold collections of other nodes. Once we have these two types, we can simply tell composing nodes how to group their children, and tell leaf nodes the expected compiled form.</p><p>Having this separation of concerns will make life a lot easier for use when we introduce more complicated structures.</p><h2 id=changing-our-tests>Changing our tests</h2><p>Before we get ahead of ourselves, let&rsquo;s modify our tests to use our new lexer, parser, and compile methods to generate our FSM, instead of using the hand-made FSM from our previous tests.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>- func TestHandmadeFSM(t *testing.T) {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+ func TestCompiledFSM(t *testing.T) {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span><span style=color:#000;background-color:#fdd>-  // handMade
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  startState := State{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  stateA := State{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  stateB := State{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  stateC := State{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>- 
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  startState.transitions = append(startState.transitions, Transition{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-          to:        &amp;stateA,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-          predicate: func(input rune) bool { return input == &#39;a&#39; },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>- 
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  stateA.transitions = append(stateA.transitions, Transition{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-          to:        &amp;stateB,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-          predicate: func(input rune) bool { return input == &#39;b&#39; },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  stateB.transitions = append(stateB.transitions, Transition{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-          to:        &amp;stateC,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-          predicate: func(input rune) bool { return input == &#39;c&#39; },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+  // compiled
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+  tokens := lex(&#34;abc&#34;)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+  parser := NewParser(tokens)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+  ast := parser.Parse()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+  startState, _ := ast.compile()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>  
</span></span><span style=display:flex><span>   type test struct {  
</span></span><span style=display:flex><span>      name           string  
</span></span><span style=display:flex><span>      input          string  
</span></span><span style=display:flex><span>      expectedStatus Status  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tests := []test{  
</span></span><span style=display:flex><span>      {&#34;empty string&#34;, &#34;&#34;, Normal},  
</span></span><span style=display:flex><span>      {&#34;non matching string&#34;, &#34;xxx&#34;, Fail},  
</span></span><span style=display:flex><span>      {&#34;matching string&#34;, &#34;abc&#34;, Success},  
</span></span><span style=display:flex><span>      {&#34;partial matching string&#34;, &#34;ab&#34;, Normal},  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   for _, tt := range tests {  
</span></span><span style=display:flex><span>      t.Run(tt.name, func(t *testing.T) {  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-        testRunner := NewRunner(&amp;startState)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+        testRunner := NewRunner(startState)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>  
</span></span><span style=display:flex><span>         for _, character := range tt.input {  
</span></span><span style=display:flex><span>            testRunner.Next(character)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>         result := testRunner.GetStatus()  
</span></span><span style=display:flex><span>         if tt.expectedStatus != result {  
</span></span><span style=display:flex><span>            t.Fatalf(&#34;Expected FSM to have final state of &#39;%v&#39;, got &#39;%v&#39;&#34;, tt.expectedStatus, result)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      })  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And with that, our tests should be green!</p><p>We&rsquo;ve now created a fully compiled - although very limited - state machine. Congrats!</p><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v2>here</a></p></div></div><p>Previous: <a href=/posts/2-getting-into-some-code/>2 Getting into some code</a><span class=meta></span></p><p>Next: <a href=/posts/4-testing-fuzzing-and-fixing-things/>4 Testing, Fuzzing, and fixing things</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>