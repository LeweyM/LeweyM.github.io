<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>2 Getting into some code - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="2 Getting into some code"><meta property="og:description" content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
// state.go type State struct { connectedStates []*State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/posts/2-getting-into-some-code/"><meta property="article:section" content="posts"><meta property="og:see_also" content="https://leweym.github.io/posts/1-intro/"><meta property="og:see_also" content="https://leweym.github.io/posts/3-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/posts/4-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/posts/5-wildcards/"><meta property="og:see_also" content="https://leweym.github.io/posts/6-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="2 Getting into some code"><meta name=twitter:description content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
// state.go type State struct { connectedStates []*State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><script src=https://leweym.github.io/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/posts/1-intro/>1 Intro</a> <span class=meta></span></div><div class=post><span>2 Getting into some code</span></div><div class=post><a href=/posts/3-starting-the-compiler/>3 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/posts/4-testing-fuzzing-and-fixing-things/>4 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/posts/5-wildcards/>5 Wildcards</a> <span class=meta></span></div><div class=post><a href=/posts/6-pretty-vizualizations/>6 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/posts/7-branches/>7 Branches</a> <span class=meta></span></div><div class=post><a href=/posts/8-epsilons/>8 Epsilons</a> <span class=meta></span></div><div class=post><a href=/posts/9-groups/>9 Groups</a> <span class=meta></span></div></div></div><br><div class=post-header><h1 class=title>2 Getting into some code</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#the-fsm-data-structure>The FSM data structure</a></li><li><a href=#running-our-state-machine>Running Our State machine</a></li><li><a href=#tests-first>Tests first</a></li><li><a href=#runner>Runner</a></li></ul></nav></aside><div class=markdown><p>Let&rsquo;s start coding.</p><h2 id=the-fsm-data-structure>The FSM data structure</h2><p>We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of <code>state</code> objects.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> State <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>	connectedStates []<span style=color:#000;font-weight:700>*</span>State  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a <code>Transition</code> struct to represent this.</p><p>The <code>Transition</code> struct contains two things:</p><ol><li>the next state</li><li>the predicate that determines whether we can go to the next state</li></ol><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Transition <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// to: a pointer to the next state   
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   to <span style=color:#000;font-weight:700>*</span>State  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// predicate: a function to determine if we should move to the next state
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   predicate <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>The <code>Predicate</code> is a simple function that takes in a character.</p><div class="notices note"><p>here we&rsquo;re using <a href=https://go.dev/blog/strings><code>rune</code></a> to avoid <a href=https://www.geeksforgeeks.org/rune-in-golang/>multi-byte character issues</a>.</p></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Predicate <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span>
</span></span></code></pre></div><p>To put this all together, let&rsquo;s make some changes to our <code>State</code> struct definition in order to use our <code>Predicate</code> and <code>Transition</code> types.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Predicate <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Transition <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   to          <span style=color:#000;font-weight:700>*</span>State  
</span></span><span style=display:flex><span>   predicate   Predicate  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> State <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   transitions []Transition  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=running-our-state-machine>Running Our State machine</h2><p>In order to use our state machine, we&rsquo;ll need something that can process a string by running through the states, and that can give information on matches. As this is an object that runs through our state machine, we&rsquo;ll call this a <strong>Runner</strong>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// runner.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> runner <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   head      <span style=color:#000;font-weight:700>*</span>State  
</span></span><span style=display:flex><span>   current   <span style=color:#000;font-weight:700>*</span>State  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For now, all our runner needs to have is a pointer to the root (or <code>head</code>) node of our FSM, as well as another pointer which tracks where we are in the state machine (the red dot in our diagrams).</p><h2 id=tests-first>Tests first</h2><p>We&rsquo;ll be following TDD principles when convenient in order to make sure things are working as expected (and because, personally, I find it more fun). As we now have our fundamental objects mapped out, we can now start writing some tests.</p><p>Our first test will check the behaviour of a simple FSM which represents the regex expression <code>abc</code>. The first thing to do is construct the FSM. We&rsquo;ll do this &lsquo;by hand&rsquo; for now, and later we&rsquo;ll work on a <strong>compiler</strong> that can take a string like <code>"abc"</code> and build an FSM automatically.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>TestHandmadeFSM</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {
</span></span><span style=display:flex><span>	startState <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	stateA <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	stateB <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	stateC <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	startState.transitions = <span style=color:#0086b3>append</span>(startState.transitions, Transition{  
</span></span><span style=display:flex><span>	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateA,  
</span></span><span style=display:flex><span>	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;a&#39;</span> },  
</span></span><span style=display:flex><span>	})  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	stateA.transitions = <span style=color:#0086b3>append</span>(stateA.transitions, Transition{  
</span></span><span style=display:flex><span>	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateB,  
</span></span><span style=display:flex><span>	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;b&#39;</span> },  
</span></span><span style=display:flex><span>	})  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	stateB.transitions = <span style=color:#0086b3>append</span>(stateB.transitions, Transition{  
</span></span><span style=display:flex><span>	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateC,  
</span></span><span style=display:flex><span>	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;c&#39;</span> },  
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There&rsquo;s quite a bit going on here, so let&rsquo;s break it down a bit.</p><p>First, let&rsquo;s remind ourselves of the FSM structure for the regex <code>abc</code></p><p><img src=/img/Pasted-image-20220710201842.png alt=Pasted-image-20220710201842.png></p><p>There are 4 states which we have to define first.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	startState <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	stateA <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	stateB <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>	stateC <span style=color:#000;font-weight:700>:=</span> State{} 
</span></span></code></pre></div><p>Once we have our states, we need to describe the transitions between them. The first is the transition from the <code>startState</code> to <code>stateA</code>. To do this, we simply append a <code>Transition</code> object to the <code>transitions</code> property of <code>startState</code>. This new transition must point to <code>stateA</code>, and take as it&rsquo;s predicate a function that returns <code>true</code> if the input rune is <code>'a'</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>startState.transitions = <span style=color:#0086b3>append</span>(startState.transitions, Transition{  
</span></span><span style=display:flex><span>   to:          <span style=color:#000;font-weight:700>&amp;</span>stateA,  
</span></span><span style=display:flex><span>   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;a&#39;</span> },  
</span></span><span style=display:flex><span>})  
</span></span></code></pre></div><p>The same goes for the remaining states.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span>	stateA.transitions = <span style=color:#0086b3>append</span>(stateA.transitions, Transition{  
</span></span><span style=display:flex><span>	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateB,  
</span></span><span style=display:flex><span>	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;b&#39;</span> },  
</span></span><span style=display:flex><span>	})  
</span></span><span style=display:flex><span>	  
</span></span><span style=display:flex><span>	stateB.transitions = <span style=color:#0086b3>append</span>(stateB.transitions, Transition{  
</span></span><span style=display:flex><span>	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateC,  
</span></span><span style=display:flex><span>	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;c&#39;</span> },  
</span></span><span style=display:flex><span>	})
</span></span></code></pre></div><p>We now have our first FSM starting at the root node <code>startState</code>. Let&rsquo;s write a test which creates a <code>runner</code> and uses this FSM to check against a few different input cases.</p><p>The outcome of running a string through an FSM should result in one of 3 statuses;</p><ol><li><code>Normal</code>. The FSM has not found a match yet, but neither has it found that there is no match. Another way of saying this is that the search is still &lsquo;in progress&rsquo;.</li><li><code>Success</code>. The FSM has found a match.</li><li><code>fail</code>. The FSM has found that the string does not match.</li></ol><p>We can define these as constants of a specific type.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Status <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> (  
</span></span><span style=display:flex><span>   Success Status = <span style=color:#d14>&#34;success&#34;</span>  
</span></span><span style=display:flex><span>   Fail           = <span style=color:#d14>&#34;fail&#34;</span>  
</span></span><span style=display:flex><span>   Normal         = <span style=color:#d14>&#34;normal&#34;</span>  
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><p>With that in mind, we can think of a few cases to test our FSM and runner logic;</p><ul><li><code>""</code> → <code>normal</code></li><li><code>"xxx"</code> → <code>fail</code></li><li><code>"abc"</code> → <code>success</code></li><li><code>"ab"</code> → <code>normal</code></li></ul><p>Writing these up into table-style tests, we get the following;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   name           <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   input          <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   expectedStatus Status  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>tests <span style=color:#000;font-weight:700>:=</span> []test{  
</span></span><span style=display:flex><span>   {<span style=color:#d14>&#34;empty string&#34;</span>, <span style=color:#d14>&#34;&#34;</span>, Normal},  
</span></span><span style=display:flex><span>   {<span style=color:#d14>&#34;non matching string&#34;</span>, <span style=color:#d14>&#34;x&#34;</span>, Fail},  
</span></span><span style=display:flex><span>   {<span style=color:#d14>&#34;matching string&#34;</span>, <span style=color:#d14>&#34;abc&#34;</span>, Success},  
</span></span><span style=display:flex><span>   {<span style=color:#d14>&#34;partial matching string&#34;</span>, <span style=color:#d14>&#34;ab&#34;</span>, Normal},  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The actual tests should simply create a runner using our hand-made FSM, iterate through the runes in the <code>input</code> string, and check that the <code>Status</code> of the runner is the same as our expected status.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>for</span> _, tt <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tests {  
</span></span><span style=display:flex><span>   t.<span style=color:#900;font-weight:700>Run</span>(tt.name, <span style=color:#000;font-weight:700>func</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>      testRunner <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewRunner</span>(<span style=color:#000;font-weight:700>&amp;</span>startState)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>for</span> _, character <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tt.input {  
</span></span><span style=display:flex><span>         testRunner.<span style=color:#900;font-weight:700>Next</span>(character)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>      result <span style=color:#000;font-weight:700>:=</span> testRunner.<span style=color:#900;font-weight:700>getStatus</span>()  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>if</span> tt.expectedStatus <span style=color:#000;font-weight:700>!=</span> result {  
</span></span><span style=display:flex><span>         t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;Expected FSM to have final state of &#39;%v&#39;, got &#39;%v&#39;&#34;</span>, tt.expectedStatus, result)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   })  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice that we had to invent a couple of methods to make this work, such as the <code>NewRunner</code>, <code>testRunner.Next</code> and <code>testRunner.getStatus</code>. This is fine, as we&rsquo;ll come back to implementing these in a moment.</p><p>All together, our first test looks like this;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>TestHandmadeFSM</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// hand-made FSM
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   startState <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>   stateA <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>   stateB <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>   stateC <span style=color:#000;font-weight:700>:=</span> State{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   startState.transitions = <span style=color:#0086b3>append</span>(startState.transitions, Transition{  
</span></span><span style=display:flex><span>      to:        <span style=color:#000;font-weight:700>&amp;</span>stateA,  
</span></span><span style=display:flex><span>      predicate: <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;a&#39;</span> },  
</span></span><span style=display:flex><span>   })  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   stateA.transitions = <span style=color:#0086b3>append</span>(stateA.transitions, Transition{  
</span></span><span style=display:flex><span>      to:        <span style=color:#000;font-weight:700>&amp;</span>stateB,  
</span></span><span style=display:flex><span>      predicate: <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;b&#39;</span> },  
</span></span><span style=display:flex><span>   })  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   stateB.transitions = <span style=color:#0086b3>append</span>(stateB.transitions, Transition{  
</span></span><span style=display:flex><span>      to:        <span style=color:#000;font-weight:700>&amp;</span>stateC,  
</span></span><span style=display:flex><span>      predicate: <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;c&#39;</span> },  
</span></span><span style=display:flex><span>   })  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>      name           <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>      input          <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>      expectedStatus Status  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tests <span style=color:#000;font-weight:700>:=</span> []test{  
</span></span><span style=display:flex><span>      {<span style=color:#d14>&#34;empty string&#34;</span>, <span style=color:#d14>&#34;&#34;</span>, Normal},  
</span></span><span style=display:flex><span>      {<span style=color:#d14>&#34;non matching string&#34;</span>, <span style=color:#d14>&#34;xxx, Fail},  
</span></span></span><span style=display:flex><span><span style=color:#d14>      {&#34;</span>matching <span style=color:#458;font-weight:700>string</span><span style=color:#d14>&#34;, &#34;</span>abc<span style=color:#d14>&#34;, Success},  
</span></span></span><span style=display:flex><span><span style=color:#d14>      {&#34;</span>partial matching <span style=color:#458;font-weight:700>string</span><span style=color:#d14>&#34;, &#34;</span>ab<span style=color:#d14>&#34;, Normal},  
</span></span></span><span style=display:flex><span><span style=color:#d14>   }  
</span></span></span><span style=display:flex><span><span style=color:#d14>  
</span></span></span><span style=display:flex><span><span style=color:#d14>   for _, tt := range tests {  
</span></span></span><span style=display:flex><span><span style=color:#d14>      t.Run(tt.name, func(t *testing.T) {  
</span></span></span><span style=display:flex><span><span style=color:#d14>         testRunner := NewRunner(&amp;startState)  
</span></span></span><span style=display:flex><span><span style=color:#d14>  
</span></span></span><span style=display:flex><span><span style=color:#d14>         for _, character := range tt.input {  
</span></span></span><span style=display:flex><span><span style=color:#d14>            testRunner.Next(character)  
</span></span></span><span style=display:flex><span><span style=color:#d14>         }  
</span></span></span><span style=display:flex><span><span style=color:#d14>  
</span></span></span><span style=display:flex><span><span style=color:#d14>         result := testRunner.getStatus()  
</span></span></span><span style=display:flex><span><span style=color:#d14>         if tt.expectedStatus != result {  
</span></span></span><span style=display:flex><span><span style=color:#d14>            t.Fatalf(&#34;</span>Expected FSM to have final state of <span style=color:#a61717;background-color:#e3d2d2>&#39;</span><span style=color:#000;font-weight:700>%</span>v<span style=color:#a61717;background-color:#e3d2d2>&#39;</span>, got <span style=color:#a61717;background-color:#e3d2d2>&#39;</span><span style=color:#000;font-weight:700>%</span>v<span style=color:#a61717;background-color:#e3d2d2>&#39;&#34;</span>, tt.expectedStatus, result)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      })  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="notices note"><p>One might take a look at this test and say, &ldquo;The states are being instantiated once and then used in every test. This is a bad practice as one test might affect the outcome of another.&rdquo; and I would totally agree. The only reason we&rsquo;re getting away with it here is because our State Machines are <strong>stateless</strong>, meaning they don&rsquo;t contain any information about the state of the process. On the other hand, our <code>runner</code> instance is <strong>stateful</strong>, so we want to create a new instance for every test case.</p></div><p>Now that we have our first test, let&rsquo;s implement the missing methods and make these tests pass.</p><h2 id=runner>Runner</h2><p>The first method we need to implement is a simple constructor function.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// runner.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>NewRunner</span>(head <span style=color:#000;font-weight:700>*</span>State) <span style=color:#000;font-weight:700>*</span>runner {  
</span></span><span style=display:flex><span>   r <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>runner{  
</span></span><span style=display:flex><span>      head:    head,  
</span></span><span style=display:flex><span>      current: head,  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> r  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a simple constructor which requires that we store two pointers to the root <code>State</code>. The <code>head</code> state will remain constant in case we want to reset the <code>runner</code>. The <code>current</code> state will represent where we are in the FSM, as represented by the red dot in our state machine diagrams.</p><div class="notices note"><p>This assumes that we can only be in one place at a time in our FSM, more on that later..</p></div><p>Now, the <code>Next</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// runner.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (r <span style=color:#000;font-weight:700>*</span>runner) <span style=color:#900;font-weight:700>Next</span>(input <span style=color:#458;font-weight:700>rune</span>) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> r.current <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// move to next matching transition  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   r.current = r.current.<span style=color:#900;font-weight:700>firstMatchingTransition</span>(input)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All this does is change the <code>r.current</code> state to the state pointed to by the first matching transition of the current state. If <code>r.current</code> is <code>nil</code>, that means that the FSM has already fallen into a <code>fail</code> state, and so should do nothing.</p><p>The logic for finding the first matching transition is implemented on a method of the <code>State</code> struct, so let&rsquo;s implement that now.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>firstMatchingTransition</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#000;font-weight:700>*</span>State {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> s.transitions {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>if</span> t.<span style=color:#900;font-weight:700>predicate</span>(input) {  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>return</span> t.to  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is also pretty simple. The function loops over the transitions of the state and returns the <code>to</code> state of the first transition, which passes the <code>predicate</code> test function. Notice that if the state has no <code>transition</code> which matches the predicate, the function returns <code>nil</code> - this is the same as the red dot in our diagrams leaving the FSM and represents a <code>Fail</code> case.</p><p>Finally, we just need to determine the status of the FSM at any time.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// runner.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (r <span style=color:#000;font-weight:700>*</span>runner) <span style=color:#900;font-weight:700>GetStatus</span>() Status {  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// if the current state is nil, return Fail  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>if</span> r.current <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> Fail  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// if the current state has no transitions from it, return Success  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>if</span> r.current.<span style=color:#900;font-weight:700>isSuccessState</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> Success  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// else, return normal  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>return</span> Normal  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Again, the logic for determining a <code>Success</code> status is implemented as a <code>State</code> struct method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>isSuccessState</span>() <span style=color:#458;font-weight:700>bool</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(s.transitions) <span style=color:#000;font-weight:700>==</span> <span style=color:#099>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we&rsquo;re making an assumption; if a transition leads to no other states, we can consider it a success state. This is not strictly true, but it&rsquo;s useful for now.</p><p>If we run the tests again, they should now be green! We now have a working, although pretty simple, finite state machine regex processor!</p><div class="notices tip"><p>Check out this part of the project on github <a href=https://github.com/LeweyM/search/tree/master/src/v1>here</a></p></div></div><p>Previous: <a href=/posts/1-intro/>1 Intro</a><span class=meta></span></p><p>Next: <a href=/posts/3-starting-the-compiler/>3 Starting the compiler</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div></body></html>