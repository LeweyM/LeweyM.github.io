<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>9 Groups - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="9 Groups"><meta property="og:description" content="Groups Regular expressions can be grouped together using the '()' parenthesis symbols, in the same way that arithmetic constructions such as (1 + (3 * 7)) can be grouped. This hasn&rsquo;t been a problem yet because up until now, we&rsquo;ve only dealt with concatenation, and string concatenation is an associative operation. This means that grouping doesn&rsquo;t make a difference. For example, 'a' + 'b' + 'c' == 'a' + 'bc' == 'ab' + 'c' == 'abc'."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/posts/9-groups/"><meta property="article:section" content="posts"><meta property="og:see_also" content="https://leweym.github.io/posts/1-intro/"><meta property="og:see_also" content="https://leweym.github.io/posts/2-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/posts/3-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/posts/4-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/posts/5-wildcards/"><meta property="og:see_also" content="https://leweym.github.io/posts/6-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="9 Groups"><meta name=twitter:description content="Groups Regular expressions can be grouped together using the '()' parenthesis symbols, in the same way that arithmetic constructions such as (1 + (3 * 7)) can be grouped. This hasn&rsquo;t been a problem yet because up until now, we&rsquo;ve only dealt with concatenation, and string concatenation is an associative operation. This means that grouping doesn&rsquo;t make a difference. For example, 'a' + 'b' + 'c' == 'a' + 'bc' == 'ab' + 'c' == 'abc'."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><script src=https://leweym.github.io/js/main.js></script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/posts/1-intro/>1 Intro</a> <span class=meta></span></div><div class=post><a href=/posts/2-getting-into-some-code/>2 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/posts/3-starting-the-compiler/>3 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/posts/4-testing-fuzzing-and-fixing-things/>4 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/posts/5-wildcards/>5 Wildcards</a> <span class=meta></span></div><div class=post><a href=/posts/6-pretty-vizualizations/>6 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/posts/7-branches/>7 Branches</a> <span class=meta></span></div><div class=post><a href=/posts/8-epsilons/>8 Epsilons</a> <span class=meta></span></div><div class=post><span>9 Groups</span></div></div></div><br><div class=post-header><h1 class=title>9 Groups</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#groups>Groups</a></li><li><a href=#parsing-groups>Parsing groups</a></li><li><a href=#compiling-groups>Compiling groups</a></li></ul></nav></aside><div class=markdown><h2 id=groups>Groups</h2><p>Regular expressions can be grouped together using the <code>'()'</code> parenthesis symbols, in the same way that arithmetic constructions such as <code>(1 + (3 * 7))</code> can be grouped. This hasn&rsquo;t been a problem yet because up until now, we&rsquo;ve only dealt with concatenation, and string concatenation is an associative operation. This means that grouping doesn&rsquo;t make a difference. For example, <code>'a' + 'b' + 'c' == 'a' + 'bc' == 'ab' + 'c' == 'abc'</code>.</p><p>However, our <code>OR '|'</code> operation is non-associative. For example, the following regular expressions are not equivalent: <code>ab|c != a(b|c)</code>.</p><p>This is the reason for the fuzzing error we&rsquo;re seeing.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>--- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	fsm_test.go:142: Mismatch - 
</span></span><span style=display:flex><span>		Regex: <span style=color:#d14>&#39;1(|)&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 31287c29<span style=color:#000;font-weight:700>)</span>, 
</span></span><span style=display:flex><span>		Input: <span style=color:#d14>&#39;0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 30<span style=color:#000;font-weight:700>)</span> 
</span></span><span style=display:flex><span>		-&gt; 
</span></span><span style=display:flex><span>		Go Regex Pkg: <span style=color:#d14>&#39;false&#39;</span>, 
</span></span><span style=display:flex><span>		Our regex result: <span style=color:#d14>&#39;true&#39;</span>
</span></span></code></pre></div><p>Our regex compiler is interpreting <code>1(|)</code> as <code>1|</code>, which produce very different outcomes. Let&rsquo;s add a test to represent this case.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestFSMAgainstGoRegexPkg(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                {&#34;branch with shared characters&#34;, &#34;dog|dot&#34;, &#34;dot&#34;},
</span></span><span style=display:flex><span>                {&#34;branch with right side empty&#34;, &#34;a|&#34;, &#34;&#34;},
</span></span><span style=display:flex><span>                {&#34;branch with left side empty&#34;, &#34;|a&#34;, &#34;&#34;},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               // group
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;word followed by group&#34;, &#34;1(|)&#34;, &#34;0&#34;},
</span></span></span></code></pre></div><p>Now let&rsquo;s fix this by taking into account the <code>()</code> symbols and breaking the regular expression into groups, starting with the parser.</p><h2 id=parsing-groups>Parsing groups</h2><p>Let&rsquo;s add a test to our parser to define what we want to produce.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestParser(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span><span style=color:#000;background-color:#dfd>+               {name: &#34;groups&#34;, input: &#34;a(b|c)&#34;, expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       CharacterLiteral{Character: &#39;a&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       &amp;Branch{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;b&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;c&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span></code></pre></div><p>This should be failing. We can see from our nicely parsed output that what is being produced is not correct.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#000;font-weight:700>===</span> RUN   TestParser/groups
</span></span><span style=display:flex><span>    parser_test.go:64: Expected:
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Group
</span></span><span style=display:flex><span>        --CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;a&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        --Branch
</span></span><span style=display:flex><span>        ------Group
</span></span><span style=display:flex><span>        ----------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;b&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        ------Group
</span></span><span style=display:flex><span>        ----------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;c&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Got:
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        Branch
</span></span><span style=display:flex><span>        --Group
</span></span><span style=display:flex><span>        ------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;a&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        ------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;b&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        --Group
</span></span><span style=display:flex><span>        ------CharacterLiteral<span style=color:#000;font-weight:700>(</span><span style=color:#d14>&#39;c&#39;</span><span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>We can see that we&rsquo;re still creating a single branch with <code>'ab'</code> on the left and <code>'c'</code> on the right. What we want is a group with <code>'a'</code> concatenated onto a branch with <code>'b'</code> on the left and <code>'c'</code> on the right.</p><p>Fixing the parser should be fairly straightforward, and it will finally make use of the stack data structure.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (p *Parser) Parse(tokens []token) Node {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>				for _, t := range tokens {  
</span></span><span style=display:flex><span>				   switch t.symbol {  
</span></span><span style=display:flex><span>				   case Character:  
</span></span><span style=display:flex><span>				      node := p.pop()  
</span></span><span style=display:flex><span>				      node.Append(CharacterLiteral{Character: t.letter})  
</span></span><span style=display:flex><span>				      p.push(node)  
</span></span><span style=display:flex><span>				   case AnyCharacter:  
</span></span><span style=display:flex><span>				      node := p.pop()  
</span></span><span style=display:flex><span>				      node.Append(WildcardLiteral{})  
</span></span><span style=display:flex><span>				      p.push(node)  
</span></span><span style=display:flex><span>				   case Pipe:  
</span></span><span style=display:flex><span>				      node := p.pop()  
</span></span><span style=display:flex><span>				      switch b := node.(type) {  
</span></span><span style=display:flex><span>				      case *Branch:  
</span></span><span style=display:flex><span>				         b.Split()  
</span></span><span style=display:flex><span>				      default:  
</span></span><span style=display:flex><span>				         node = &amp;Branch{ChildNodes: []Node{node, &amp;Group{}}}  
</span></span><span style=display:flex><span>				      }  
</span></span><span style=display:flex><span>				      p.push(node)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                  case LParen:
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     p.pushNewGroup()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                  case RParen:
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     inner := p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     outer := p.pop()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     outer.Append(inner)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                     p.push(outer)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>Let&rsquo;s walk through these new cases.</p><p>When we encounter a <code>LParen</code> <code>(</code> opening parenthesis symbol, we want to start a new group. In this case, we simply push a new group onto the stack. This new group will then be picked up and used when other symbols or characters are processed.</p><p>When we encounter a <code>RParen )</code> closing parenthesis symbol, the case is slightly more complicated. We want to take the <code>Node</code> at the top of the stack, append it to the next <code>Node</code> down in the stack, and then put those combined <code>Nodes</code> at the top of the stack again. You can think of this as &lsquo;reducing&rsquo; the top two elements of the stack into a single <code>Node</code>.</p><p>Let&rsquo;s look at a visual example. We&rsquo;ll parse the expression <code>"a(b|c)"</code></p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group)
end
end
subgraph stack
root --> *outer-group
end</div><p>When we start the parser, a <code>Group</code> will be created which represents the whole expression. We&rsquo;ll call this <code>outer-group</code>. The stack will be initialized with a pointer to <code>outer-group</code>.</p><p>After processing <code>'a'</code>, the parser will look like this.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
end
subgraph stack
root --> *outer-group
end</div><p>A <code>CharacterLiteral(a)</code> is simply appended to the group on top of the stack; <code>outer-group</code>.</p><p>When an opening parenthesis <code>'('</code> symbol is encountered, a new group <code>inner-group</code> will be created and a pointer will be pushed onto the stack.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
3(inner-group)
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-group
end</div><p>Now, when <code>'b'</code> is processed, it will be appended to the new <code>inner-group</code> <code>Node</code> as it is the last <code>Node</code> on the stack.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
3(inner-group) --> 4[b]
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-group
end</div><p>The branch symbol <code>|</code> will convert the top node on the stack into a branch, add the group as a child of the branch, add a new group, and push the branch pointer onto the stack:</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
5(inner-branch) -->
3(inner-group) --> 4[b]
5(inner-branch) --> 6(inner-group-2)
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-branch
end</div><p>And now the next character symbol <code>'c'</code> will be applied to top <code>Node</code> of the stack - <code>inner-branch</code>, which will apply it to its last child - <code>inner-group-2</code></p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
end
subgraph "inner"
5(inner-branch) -->
3(inner-group) --> 4[b]
5(inner-branch) --> 6(inner-group-2)
6 --> 7[c]
end
end
subgraph stack
root --> *outer-group
*outer-group --> *inner-branch
end</div><p>Finally, we encounter the closing parenthesis symbol <code>)</code>. This will pop <code>inner-branch</code> and <code>outer-group</code> from the stack, append <code>inner-branch</code> to <code>outer-group</code>, and then push <code>outer-group</code> back onto the stack.</p><div class=mermaid>graph TD
subgraph " "
subgraph "outer"
1(outer-group) --> 2[a]
1 -->
5(inner-branch) -->
3(inner-group) --> 4[b]
5(inner-branch) --> 6(inner-group-2)
6 --> 7[c]
end
end
subgraph stack
root --> *outer-group
end</div><p>As we&rsquo;ve reached the end of the expression, we simply pop the last element off the stack - <code>outer-group</code> and return it.</p><p>The power of using the <code>stack</code> data structures should be evident here. In our example, we only went two levels deep - the outer group and the inner group - but there&rsquo;s no reason that we couldn&rsquo;t go 3, 4, or any number of levels deep.</p><p>The stack takes care of &lsquo;remembering&rsquo; the previous levels, so we only need to care about processing the inmost level, then reduce the top two levels into one when we collapse a group. Because of this behaviour, stacks are particularly useful for parsing nested structures of arbitrary depth.</p><p>That should actually be enough to get our test to pass!</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span><span style=color:#000;font-weight:700>===</span> RUN   TestFSMAgainstGoRegexPkg/concatenated_word_with_grouped_branch
</span></span><span style=display:flex><span>--- PASS: TestFSMAgainstGoRegexPkg <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span></code></pre></div><p>Let&rsquo;s run our fuzzer again and see if we&rsquo;re missing something.</p><p>Our fuzzer finds an interesting error.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>fuzz: elapsed: 0s, gathering baseline coverage: 5/664 completed
</span></span><span style=display:flex><span>--- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.07s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>    --- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>        fsm_test.go:144: Mismatch - 
</span></span><span style=display:flex><span>            Regex: <span style=color:#d14>&#39;(((()0))0)&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 28282828293029293029<span style=color:#000;font-weight:700>)</span>, 
</span></span><span style=display:flex><span>            Input: <span style=color:#d14>&#39;0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 30<span style=color:#000;font-weight:700>)</span> 
</span></span><span style=display:flex><span>            -&gt; 
</span></span><span style=display:flex><span>            Go Regex Pkg: <span style=color:#d14>&#39;false&#39;</span>, 
</span></span><span style=display:flex><span>            Our regex result: <span style=color:#d14>&#39;true&#39;</span>
</span></span></code></pre></div><p>I think I can reduce this error into one a bit more manageable, while I&rsquo;ll add as a test case.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestFSMAgainstGoRegexPkg(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span> 
</span></span><span style=display:flex><span>                // group
</span></span><span style=display:flex><span>                {&#34;word followed by group&#34;, &#34;1(|)&#34;, &#34;0&#34;},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;empty group concatenation&#34;, &#34;(()0)0&#34;, &#34;0&#34;},
</span></span></span></code></pre></div><p>This is simply the inverse of our previous test NOT SURE ABOUT THIS&mldr;</p><h2 id=compiling-groups>Compiling groups</h2><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v7>here</a></p></div></div><p>Previous: <a href=/posts/8-epsilons/>8 Epsilons</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>