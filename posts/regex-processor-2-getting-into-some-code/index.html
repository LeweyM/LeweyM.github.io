<!doctype html><html lang=en-us>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<title>Regex Processor 2 Getting into some code | Lewis Metcalf</title>
<meta name=viewport content="width=device-width,minimum-scale=1">
<meta name=description content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<meta name=generator content="Hugo 0.91.2">
<meta name=robots content="noindex, nofollow">
<link rel=stylesheet href=/ananke/css/main.min.css>
<meta property="og:title" content="Regex Processor 2 Getting into some code">
<meta property="og:description" content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://LeweyM.github.io/posts/regex-processor-2-getting-into-some-code/"><meta property="article:section" content="posts">
<meta itemprop=name content="Regex Processor 2 Getting into some code">
<meta itemprop=description content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<meta itemprop=wordCount content="1605">
<meta itemprop=keywords content><meta name=twitter:card content="summary">
<meta name=twitter:title content="Regex Processor 2 Getting into some code">
<meta name=twitter:description content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
</head>
<body class="ma0 avenir bg-near-white">
<header>
<div class=bg-black>
<nav class="pv3 ph3 ph4-ns" role=navigation>
<div class="flex-l justify-between items-center center">
<a href=/ class="f3 fw2 hover-white no-underline white-90 dib">
Lewis Metcalf
</a>
<div class="flex-l items-center">
<div class=ananke-socials>
</div>
</div>
</div>
</nav>
</div>
</header>
<main class=pb7 role=main>
<article class="flex-l flex-wrap justify-between mw8 center ph3">
<header class="mt4 w-100">
<aside class="instapaper_ignoref b helvetica tracked">
POSTS
</aside>
<div id=sharing class="mt3 ananke-socials">
</div>
<h1 class="f1 athelas mt3 mb1">Regex Processor 2 Getting into some code</h1>
</header>
<div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Let&rsquo;s start coding.</p>
<h3 id=the-fsm-data-structure>The FSM data structure</h3>
<p>We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of <code>state</code> objects.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>State</span> <span style=color:#66d9ef>struct</span> {  
	<span style=color:#a6e22e>connectedStates</span> []<span style=color:#a6e22e>State</span>  
}
</code></pre></div><p>We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a <code>Transition</code> struct to represent this.</p>
<p>The <code>Transition</code> struct contains two things:</p>
<ol>
<li>the next state</li>
<li>the predicate that determines whether we can go to the next state</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Transition</span> <span style=color:#66d9ef>struct</span> {  
   <span style=color:#75715e>// to: a pointer to the next state   
</span><span style=color:#75715e></span>   <span style=color:#a6e22e>to</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>State</span>  
   <span style=color:#75715e>// predicate: a function to determine if we should move to the next state
</span><span style=color:#75715e></span>   <span style=color:#a6e22e>predicate</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span>  
}  
</code></pre></div><p>The <code>Predicate</code> is a simple function that takes in a character (here we&rsquo;re using <code>rune</code> to avoid multi-byte character issues).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Predicate</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span>
</code></pre></div><p>Putting that together;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Predicate</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span>
  
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Transition</span> <span style=color:#66d9ef>struct</span> {  
   <span style=color:#a6e22e>to</span>          <span style=color:#f92672>*</span><span style=color:#a6e22e>State</span>  
   <span style=color:#a6e22e>predicate</span>   <span style=color:#a6e22e>Predicate</span>  
}  
  
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>State</span> <span style=color:#66d9ef>struct</span> {  
   <span style=color:#a6e22e>transitions</span> []<span style=color:#a6e22e>Transition</span>  
}

</code></pre></div><h3 id=running-our-state-machine>Running Our State machine</h3>
<p>Inorder to use our state machine, we&rsquo;ll need something that can process a string by running through the states, and that can give information on matches. As this is an object that runs through our state machine, we&rsquo;ll call this a <strong>Runner</strong>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>runner</span> <span style=color:#66d9ef>struct</span> {  
   <span style=color:#a6e22e>head</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>State</span>  
}
</code></pre></div><p>For now, all our runner needs to have is a pointer to the root (or <code>head</code>) node of our FSM.</p>
<h3 id=tests-first>Tests first</h3>
<p>We&rsquo;ll be following TDD principles when convenient in order to make sure things are working as expected (and because, personally, I find it more fun). As we now have our fundamental objects mapped out, we can now start writing some tests.</p>
<p>Our first test will check the behaviour of a simple FSM which represents the regex expression <code>abc</code>. The first thing to do is contruct the FSM. We&rsquo;ll do this &lsquo;by hand&rsquo; for now, and later we&rsquo;ll work on a <strong>compiler</strong> that can take a string like <code>"abc"</code> and build an FSM automatically.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestHandmadeFSM</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
	<span style=color:#a6e22e>startState</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
	<span style=color:#a6e22e>stateA</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
	<span style=color:#a6e22e>stateB</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
	<span style=color:#a6e22e>stateC</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
	  
	<span style=color:#a6e22e>startState</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>startState</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
	   <span style=color:#a6e22e>to</span>:          <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateA</span>,  
	   <span style=color:#a6e22e>predicate</span>:   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;a&#39;</span> },  
	})  
	  
	<span style=color:#a6e22e>stateA</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>stateA</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
	   <span style=color:#a6e22e>to</span>:          <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateB</span>,  
	   <span style=color:#a6e22e>predicate</span>:   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;b&#39;</span> },  
	})  
	  
	<span style=color:#a6e22e>stateB</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>stateB</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
	   <span style=color:#a6e22e>to</span>:          <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateC</span>,  
	   <span style=color:#a6e22e>predicate</span>:   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;c&#39;</span> },  
	})
}
</code></pre></div><p>There&rsquo;s quite a bit going on here, so let&rsquo;s break it down a bit.</p>
<p>First, let&rsquo;s remind ourselves of the FSM structure for the regex <code>abc</code></p>
<p><img src=/img/Pasted-image-20220710201842.png alt=Pasted-image-20220710201842.png></p>
<p>There are 4 states which we have to define first.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>startState</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
	<span style=color:#a6e22e>stateA</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
	<span style=color:#a6e22e>stateB</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
	<span style=color:#a6e22e>stateC</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{} 
</code></pre></div><p>Once we have our states, we need to describe the transitions between them. The first is the transition from the <code>startState</code> to <code>stateA</code>. To do this, we simply append a <code>Transition</code> object to the <code>transitions</code> property of <code>startState</code>. This new transition must point to <code>stateA</code>, and take as it&rsquo;s predicate a function that returns <code>true</code> if the input rune is <code>'a'</code>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>startState</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>startState</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
   <span style=color:#a6e22e>to</span>:          <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateA</span>,  
   <span style=color:#a6e22e>predicate</span>:   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;a&#39;</span> },  
})  
</code></pre></div><p>Same goes for the remaining states.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>stateA</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>stateA</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
	   <span style=color:#a6e22e>to</span>:          <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateB</span>,  
	   <span style=color:#a6e22e>predicate</span>:   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;b&#39;</span> },  
	})  
	  
	<span style=color:#a6e22e>stateB</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>stateB</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
	   <span style=color:#a6e22e>to</span>:          <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateC</span>,  
	   <span style=color:#a6e22e>predicate</span>:   <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;c&#39;</span> },  
	})
</code></pre></div><p>We now have our first FSM starting at the root node <code>startState</code>. Let&rsquo;s write a test which creates a <code>runner</code> and uses this FSM to check against a few different input cases.</p>
<p>The outcome of running a string through an FSM should result in one of 3 statuses;</p>
<ol>
<li><code>Normal</code>. The FSM has not found a match yet, but neither has it found that there is no match. Another way of saying this is that the search is still &lsquo;in progress&rsquo;.</li>
<li><code>Success</code>. The FSM has found a match.</li>
<li><code>fail</code>. The FSM has found that the string does not match.</li>
</ol>
<p>We can define these as consts of a specific type.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Status</span> <span style=color:#66d9ef>string</span>  
  
<span style=color:#66d9ef>const</span> (  
   <span style=color:#a6e22e>Success</span> <span style=color:#a6e22e>Status</span> = <span style=color:#e6db74>&#34;success&#34;</span>  
   <span style=color:#a6e22e>Fail</span>           = <span style=color:#e6db74>&#34;fail&#34;</span>  
   <span style=color:#a6e22e>Normal</span>         = <span style=color:#e6db74>&#34;normal&#34;</span>  
)
</code></pre></div><p>With that in mind we can think of a few cases to test our FSM and runner logic;</p>
<ul>
<li><code>""</code> -> <code>normal</code></li>
<li><code>"xxx"</code> -> <code>fail</code></li>
<li><code>"abc"</code> -> <code>success</code></li>
<li><code>"ab"</code> -> <code>normal</code></li>
</ul>
<p>Writing these up into table-style tests we get the following;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>test</span> <span style=color:#66d9ef>struct</span> {  
   <span style=color:#a6e22e>name</span>           <span style=color:#66d9ef>string</span>  
   <span style=color:#a6e22e>input</span>          <span style=color:#66d9ef>string</span>  
   <span style=color:#a6e22e>expectedStatus</span> <span style=color:#a6e22e>Status</span>  
}  
  
<span style=color:#a6e22e>tests</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>test</span>{  
   {<span style=color:#e6db74>&#34;empty string&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>Normal</span>},  
   {<span style=color:#e6db74>&#34;non matching string&#34;</span>, <span style=color:#e6db74>&#34;x&#34;</span>, <span style=color:#a6e22e>Fail</span>},  
   {<span style=color:#e6db74>&#34;matching string&#34;</span>, <span style=color:#e6db74>&#34;abc&#34;</span>, <span style=color:#a6e22e>Success</span>},  
   {<span style=color:#e6db74>&#34;partial matching string&#34;</span>, <span style=color:#e6db74>&#34;ab&#34;</span>, <span style=color:#a6e22e>Normal</span>},  
}
</code></pre></div><p>The actual tests should simply create a runner using our hand-made FSM, iterate through the runes in the <code>input</code> string, and check that the <code>Status</code> of the runner is the same as our expected status.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>tt</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tests</span> {  
   <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>name</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {  
      <span style=color:#a6e22e>testRunner</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewRunner</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>startState</span>)  
  
      <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>character</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>input</span> {  
         <span style=color:#a6e22e>testRunner</span>.<span style=color:#a6e22e>Next</span>(<span style=color:#a6e22e>character</span>)  
      }  
  
      <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>testRunner</span>.<span style=color:#a6e22e>getTotalState</span>()  
      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>expectedStatus</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>result</span> {  
         <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Expected FSM to have final state of &#39;%v&#39;, got &#39;%v&#39;&#34;</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>expectedStatus</span>, <span style=color:#a6e22e>result</span>)  
      }  
   })  
}
</code></pre></div><p>Notice that we had to invent a couple of methods to make this work, such as the <code>NewRunner</code>, <code>testRunner.Next</code> and <code>testRunner.getStatus</code>. This is fine, as we&rsquo;ll come back to implementing these in a moment.</p>
<p>All together, our first test looks like this;</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestHandmadeFSM</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {  
   <span style=color:#75715e>// hand-made FSM
</span><span style=color:#75715e></span>   <span style=color:#a6e22e>startState</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
   <span style=color:#a6e22e>stateA</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
   <span style=color:#a6e22e>stateB</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
   <span style=color:#a6e22e>stateC</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>State</span>{}  
  
   <span style=color:#a6e22e>startState</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>startState</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
      <span style=color:#a6e22e>to</span>:        <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateA</span>,  
      <span style=color:#a6e22e>predicate</span>: <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;a&#39;</span> },  
   })  
  
   <span style=color:#a6e22e>stateA</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>stateA</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
      <span style=color:#a6e22e>to</span>:        <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateB</span>,  
      <span style=color:#a6e22e>predicate</span>: <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;b&#39;</span> },  
   })  
  
   <span style=color:#a6e22e>stateB</span>.<span style=color:#a6e22e>transitions</span> = append(<span style=color:#a6e22e>stateB</span>.<span style=color:#a6e22e>transitions</span>, <span style=color:#a6e22e>Transition</span>{  
      <span style=color:#a6e22e>to</span>:        <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>stateC</span>,  
      <span style=color:#a6e22e>predicate</span>: <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;c&#39;</span> },  
   })  
  
   <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>test</span> <span style=color:#66d9ef>struct</span> {  
      <span style=color:#a6e22e>name</span>           <span style=color:#66d9ef>string</span>  
      <span style=color:#a6e22e>input</span>          <span style=color:#66d9ef>string</span>  
      <span style=color:#a6e22e>expectedStatus</span> <span style=color:#a6e22e>Status</span>  
   }  
  
   <span style=color:#a6e22e>tests</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>test</span>{  
      {<span style=color:#e6db74>&#34;empty string&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>Normal</span>},  
      {<span style=color:#e6db74>&#34;non matching string&#34;</span>, <span style=color:#e6db74>&#34;xxx, Fail},  
</span><span style=color:#e6db74>      {&#34;</span><span style=color:#a6e22e>matching</span> <span style=color:#66d9ef>string</span><span style=color:#e6db74>&#34;, &#34;</span><span style=color:#a6e22e>abc</span><span style=color:#e6db74>&#34;, Success},  
</span><span style=color:#e6db74>      {&#34;</span><span style=color:#a6e22e>partial</span> <span style=color:#a6e22e>matching</span> <span style=color:#66d9ef>string</span><span style=color:#e6db74>&#34;, &#34;</span><span style=color:#a6e22e>ab</span><span style=color:#e6db74>&#34;, Normal},  
</span><span style=color:#e6db74>   }  
</span><span style=color:#e6db74>  
</span><span style=color:#e6db74>   for _, tt := range tests {  
</span><span style=color:#e6db74>      t.Run(tt.name, func(t *testing.T) {  
</span><span style=color:#e6db74>         testRunner := NewRunner(&amp;startState)  
</span><span style=color:#e6db74>  
</span><span style=color:#e6db74>         for _, character := range tt.input {  
</span><span style=color:#e6db74>            testRunner.Next(character)  
</span><span style=color:#e6db74>         }  
</span><span style=color:#e6db74>  
</span><span style=color:#e6db74>         result := testRunner.getTotalState()  
</span><span style=color:#e6db74>         if tt.expectedStatus != result {  
</span><span style=color:#e6db74>            t.Fatalf(&#34;</span><span style=color:#a6e22e>Expected</span> <span style=color:#a6e22e>FSM</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>have</span> <span style=color:#a6e22e>final</span> <span style=color:#a6e22e>state</span> <span style=color:#a6e22e>of</span> <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#f92672>%</span><span style=color:#a6e22e>v</span><span style=color:#960050;background-color:#1e0010>&#39;</span>, <span style=color:#a6e22e>got</span> <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#f92672>%</span><span style=color:#a6e22e>v</span><span style=color:#960050;background-color:#1e0010>&#39;&#34;</span>, <span style=color:#a6e22e>tt</span>.<span style=color:#a6e22e>expectedStatus</span>, <span style=color:#a6e22e>result</span>)  
         }  
      })  
   }  
}

</code></pre></div><p>Note: One might take a look at this test and say &ldquo;The states are being instantiated once and then used in every test. This is a bad practice as one test might affect the outcome of another.&rdquo; and I would totally agree. The only reason we&rsquo;re getting away with it here is because our State Machines are <strong>stateless</strong>, meaning they don&rsquo;t contain any information about the state of the process. On the other hand, our <code>runner</code> instance is <strong>stateful</strong>, so we want to create a new instance for every test case.</p>
<p>Now that we have our first test, let&rsquo;s implement the missing methods and make these tests pass.</p>
<h3 id=runner>Runner</h3>
<p>The first method we need to implement is a simple constructor function.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewRunner</span>(<span style=color:#a6e22e>head</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>State</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>runner</span> {  
   <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>runner</span>{  
      <span style=color:#a6e22e>head</span>:    <span style=color:#a6e22e>head</span>,  
      <span style=color:#a6e22e>current</span>: <span style=color:#a6e22e>head</span>,  
   }  
  
   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>  
}
</code></pre></div><p>This is a simple constructor which requires that we store two pointers to the root <code>State</code>. The <code>head</code> state will remain constant incase we want to reset the <code>runner</code>. The <code>current</code> state will represent where we are in the FSM, as represented by the red dot in our state machine diagrams.</p>
<p>Note: This assumes that we can only be in one place at a time in our FSM, more on that later..</p>
<p>Now, the <code>Next</code> method.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>runner</span>) <span style=color:#a6e22e>Next</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) {  
   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
      <span style=color:#66d9ef>return</span>  
   }  
  
   <span style=color:#75715e>// move to next matching transition  
</span><span style=color:#75715e></span>   <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>current</span> = <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>firstMatchingTransition</span>(<span style=color:#a6e22e>input</span>)  
}
</code></pre></div><p>All this does is change the <code>r.current</code> state to the state pointed to by the first matching transition of the current state. If <code>r.current</code> is <code>nil</code>, that means that the FSM has already fallen into a <code>fail</code> state, and so should do nothing.</p>
<p>The logic for finding the first matching transition is implemented on a method of the <code>State</code> struct, so let&rsquo;s implement that now.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>State</span>) <span style=color:#a6e22e>firstMatchingTransition</span>(<span style=color:#a6e22e>input</span> <span style=color:#66d9ef>rune</span>) <span style=color:#a6e22e>destination</span> {  
   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>transitions</span> {  
      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>predicate</span>(<span style=color:#a6e22e>input</span>) {  
         <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>to</span>  
      }  
   }  
  
   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>  
}
</code></pre></div><p>This is pretty simple also. The function loops over the transitions of the state and returns the <code>destination</code> state of the first transition which passes the <code>predicate</code> test function. Notice that if the state has no <code>transition</code> which matches the predicate, the function returns <code>nil</code> - this is the same as the red dot in our diagrams leaving the FSM and represents a <code>Fail</code> case.</p>
<p>Finally, we just need to determine the status of the FSM at any time.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>runner</span>) <span style=color:#a6e22e>GetStatus</span>() <span style=color:#a6e22e>Status</span> {  
   <span style=color:#75715e>// if the current state is nil, return Fail  
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>current</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {  
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Fail</span>  
   }  
  
   <span style=color:#75715e>// if the current state has no transitions from it, return Success  
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>current</span>.<span style=color:#a6e22e>isSuccessState</span>() {  
      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Success</span>  
   }  
  
   <span style=color:#75715e>// else, return normal  
</span><span style=color:#75715e></span>   <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>Normal</span>  
}
</code></pre></div><p>Again, the logic for determining a <code>Success</code> status is implemented as a <code>State</code> struct method.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>State</span>) <span style=color:#a6e22e>isSuccessState</span>() <span style=color:#66d9ef>bool</span> {  
   <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>transitions</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {  
      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>  
   }  
  
   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>  
}
</code></pre></div><p>Here we&rsquo;re using an assumption. The assumption is; if a transition leads to no other states, we can consider it a success state. This is not strictly true, but it&rsquo;s useful for now.</p>
<p>If we run the tests again, they should now be green! We now have a working, although pretty simple, finite state machine regex processor!</p>
<p>Note: Check out this part of the project on github <a href=https://github.com/LeweyM/search/tree/master/src/v1>here</a></p>
<p>Next:<a href=https://LeweyM.github.io/posts/regex-processor-3-starting-the-compiler/>Regex Processor 3 Starting the compiler</a></p>
<p>Prev:<a href=https://LeweyM.github.io/posts/regex-processor-1-intro/>Regex Processor 1 Intro</a></p>
<ul class=pa0>
</ul>
<div class="mt6 instapaper_ignoref">
</div>
</div>
<aside class="w-30-l mt6-l">
</aside>
</article>
</main>
<footer class="bg-black bottom-0 w-100 pa3" role=contentinfo>
<div class="flex justify-between">
<a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://LeweyM.github.io>
&copy; Lewis Metcalf 2022
</a>
<div>
<div class=ananke-socials>
</div></div>
</div>
</footer>
</body>
</html>