<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Regex Processor 2 Getting into some code - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta property="og:title" content="Regex Processor 2 Getting into some code">
<meta property="og:description" content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leweym.github.io/posts/regex-processor-2-getting-into-some-code/"><meta property="article:section" content="posts">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Regex Processor 2 Getting into some code">
<meta name=twitter:description content="Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:">
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet>
<link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css>
<script src=https://leweym.github.io/js/main.js></script>
</head>
<body>
<div class="container wrapper post">
<div class=header>
<base href=https://leweym.github.io/>
<h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1>
<div class=site-description><nav class="nav social">
<ul class=flat></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
</ul>
</nav>
</div>
<div class=post-header>
<h1 class=title>Regex Processor 2 Getting into some code</h1>
<div class=meta></div>
</div>
<div class=markdown>
<p>Let&rsquo;s start coding.</p>
<h3 id=the-fsm-data-structure>The FSM data structure</h3>
<p>We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of <code>state</code> objects.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>type</span> State <span style=color:#000;font-weight:700>struct</span> {  
	connectedStates []State  
}
</code></pre></div><p>We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a <code>Transition</code> struct to represent this.</p>
<p>The <code>Transition</code> struct contains two things:</p>
<ol>
<li>the next state</li>
<li>the predicate that determines whether we can go to the next state</li>
</ol>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>type</span> Transition <span style=color:#000;font-weight:700>struct</span> {  
   <span style=color:#998;font-style:italic>// to: a pointer to the next state   
</span><span style=color:#998;font-style:italic></span>   to <span style=color:#000;font-weight:700>*</span>State  
   <span style=color:#998;font-style:italic>// predicate: a function to determine if we should move to the next state
</span><span style=color:#998;font-style:italic></span>   predicate <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span>  
}  
</code></pre></div><p>The <code>Predicate</code> is a simple function that takes in a character (here we&rsquo;re using <code>rune</code> to avoid multi-byte character issues).</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>type</span> Predicate <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span>
</code></pre></div><p>Putting that together;</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>type</span> Predicate <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span>
  
<span style=color:#000;font-weight:700>type</span> Transition <span style=color:#000;font-weight:700>struct</span> {  
   to          <span style=color:#000;font-weight:700>*</span>State  
   predicate   Predicate  
}  
  
<span style=color:#000;font-weight:700>type</span> State <span style=color:#000;font-weight:700>struct</span> {  
   transitions []Transition  
}

</code></pre></div><h3 id=running-our-state-machine>Running Our State machine</h3>
<p>Inorder to use our state machine, we&rsquo;ll need something that can process a string by running through the states, and that can give information on matches. As this is an object that runs through our state machine, we&rsquo;ll call this a <strong>Runner</strong>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>type</span> runner <span style=color:#000;font-weight:700>struct</span> {  
   head      <span style=color:#000;font-weight:700>*</span>State  
}
</code></pre></div><p>For now, all our runner needs to have is a pointer to the root (or <code>head</code>) node of our FSM.</p>
<h3 id=tests-first>Tests first</h3>
<p>We&rsquo;ll be following TDD principles when convenient in order to make sure things are working as expected (and because, personally, I find it more fun). As we now have our fundamental objects mapped out, we can now start writing some tests.</p>
<p>Our first test will check the behaviour of a simple FSM which represents the regex expression <code>abc</code>. The first thing to do is contruct the FSM. We&rsquo;ll do this &lsquo;by hand&rsquo; for now, and later we&rsquo;ll work on a <strong>compiler</strong> that can take a string like <code>"abc"</code> and build an FSM automatically.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>TestHandmadeFSM</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {
	startState <span style=color:#000;font-weight:700>:=</span> State{}  
	stateA <span style=color:#000;font-weight:700>:=</span> State{}  
	stateB <span style=color:#000;font-weight:700>:=</span> State{}  
	stateC <span style=color:#000;font-weight:700>:=</span> State{}  
	  
	startState.transitions = <span style=color:#0086b3>append</span>(startState.transitions, Transition{  
	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateA,  
	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;a&#39;</span> },  
	})  
	  
	stateA.transitions = <span style=color:#0086b3>append</span>(stateA.transitions, Transition{  
	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateB,  
	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;b&#39;</span> },  
	})  
	  
	stateB.transitions = <span style=color:#0086b3>append</span>(stateB.transitions, Transition{  
	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateC,  
	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;c&#39;</span> },  
	})
}
</code></pre></div><p>There&rsquo;s quite a bit going on here, so let&rsquo;s break it down a bit.</p>
<p>First, let&rsquo;s remind ourselves of the FSM structure for the regex <code>abc</code></p>
<p><img src=/img/Pasted-image-20220710201842.png alt=Pasted-image-20220710201842.png></p>
<p>There are 4 states which we have to define first.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	startState <span style=color:#000;font-weight:700>:=</span> State{}  
	stateA <span style=color:#000;font-weight:700>:=</span> State{}  
	stateB <span style=color:#000;font-weight:700>:=</span> State{}  
	stateC <span style=color:#000;font-weight:700>:=</span> State{} 
</code></pre></div><p>Once we have our states, we need to describe the transitions between them. The first is the transition from the <code>startState</code> to <code>stateA</code>. To do this, we simply append a <code>Transition</code> object to the <code>transitions</code> property of <code>startState</code>. This new transition must point to <code>stateA</code>, and take as it&rsquo;s predicate a function that returns <code>true</code> if the input rune is <code>'a'</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>startState.transitions = <span style=color:#0086b3>append</span>(startState.transitions, Transition{  
   to:          <span style=color:#000;font-weight:700>&amp;</span>stateA,  
   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;a&#39;</span> },  
})  
</code></pre></div><p>Same goes for the remaining states.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	stateA.transitions = <span style=color:#0086b3>append</span>(stateA.transitions, Transition{  
	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateB,  
	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;b&#39;</span> },  
	})  
	  
	stateB.transitions = <span style=color:#0086b3>append</span>(stateB.transitions, Transition{  
	   to:          <span style=color:#000;font-weight:700>&amp;</span>stateC,  
	   predicate:   <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;c&#39;</span> },  
	})
</code></pre></div><p>We now have our first FSM starting at the root node <code>startState</code>. Let&rsquo;s write a test which creates a <code>runner</code> and uses this FSM to check against a few different input cases.</p>
<p>The outcome of running a string through an FSM should result in one of 3 statuses;</p>
<ol>
<li><code>Normal</code>. The FSM has not found a match yet, but neither has it found that there is no match. Another way of saying this is that the search is still &lsquo;in progress&rsquo;.</li>
<li><code>Success</code>. The FSM has found a match.</li>
<li><code>fail</code>. The FSM has found that the string does not match.</li>
</ol>
<p>We can define these as consts of a specific type.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>type</span> Status <span style=color:#458;font-weight:700>string</span>  
  
<span style=color:#000;font-weight:700>const</span> (  
   Success Status = <span style=color:#d14>&#34;success&#34;</span>  
   Fail           = <span style=color:#d14>&#34;fail&#34;</span>  
   Normal         = <span style=color:#d14>&#34;normal&#34;</span>  
)
</code></pre></div><p>With that in mind we can think of a few cases to test our FSM and runner logic;</p>
<ul>
<li><code>""</code> -> <code>normal</code></li>
<li><code>"xxx"</code> -> <code>fail</code></li>
<li><code>"abc"</code> -> <code>success</code></li>
<li><code>"ab"</code> -> <code>normal</code></li>
</ul>
<p>Writing these up into table-style tests we get the following;</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
   name           <span style=color:#458;font-weight:700>string</span>  
   input          <span style=color:#458;font-weight:700>string</span>  
   expectedStatus Status  
}  
  
tests <span style=color:#000;font-weight:700>:=</span> []test{  
   {<span style=color:#d14>&#34;empty string&#34;</span>, <span style=color:#d14>&#34;&#34;</span>, Normal},  
   {<span style=color:#d14>&#34;non matching string&#34;</span>, <span style=color:#d14>&#34;x&#34;</span>, Fail},  
   {<span style=color:#d14>&#34;matching string&#34;</span>, <span style=color:#d14>&#34;abc&#34;</span>, Success},  
   {<span style=color:#d14>&#34;partial matching string&#34;</span>, <span style=color:#d14>&#34;ab&#34;</span>, Normal},  
}
</code></pre></div><p>The actual tests should simply create a runner using our hand-made FSM, iterate through the runes in the <code>input</code> string, and check that the <code>Status</code> of the runner is the same as our expected status.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>for</span> _, tt <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tests {  
   t.<span style=color:#900;font-weight:700>Run</span>(tt.name, <span style=color:#000;font-weight:700>func</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
      testRunner <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewRunner</span>(<span style=color:#000;font-weight:700>&amp;</span>startState)  
  
      <span style=color:#000;font-weight:700>for</span> _, character <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tt.input {  
         testRunner.<span style=color:#900;font-weight:700>Next</span>(character)  
      }  
  
      result <span style=color:#000;font-weight:700>:=</span> testRunner.<span style=color:#900;font-weight:700>getTotalState</span>()  
      <span style=color:#000;font-weight:700>if</span> tt.expectedStatus <span style=color:#000;font-weight:700>!=</span> result {  
         t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;Expected FSM to have final state of &#39;%v&#39;, got &#39;%v&#39;&#34;</span>, tt.expectedStatus, result)  
      }  
   })  
}
</code></pre></div><p>Notice that we had to invent a couple of methods to make this work, such as the <code>NewRunner</code>, <code>testRunner.Next</code> and <code>testRunner.getStatus</code>. This is fine, as we&rsquo;ll come back to implementing these in a moment.</p>
<p>All together, our first test looks like this;</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>TestHandmadeFSM</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
   <span style=color:#998;font-style:italic>// hand-made FSM
</span><span style=color:#998;font-style:italic></span>   startState <span style=color:#000;font-weight:700>:=</span> State{}  
   stateA <span style=color:#000;font-weight:700>:=</span> State{}  
   stateB <span style=color:#000;font-weight:700>:=</span> State{}  
   stateC <span style=color:#000;font-weight:700>:=</span> State{}  
  
   startState.transitions = <span style=color:#0086b3>append</span>(startState.transitions, Transition{  
      to:        <span style=color:#000;font-weight:700>&amp;</span>stateA,  
      predicate: <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;a&#39;</span> },  
   })  
  
   stateA.transitions = <span style=color:#0086b3>append</span>(stateA.transitions, Transition{  
      to:        <span style=color:#000;font-weight:700>&amp;</span>stateB,  
      predicate: <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;b&#39;</span> },  
   })  
  
   stateB.transitions = <span style=color:#0086b3>append</span>(stateB.transitions, Transition{  
      to:        <span style=color:#000;font-weight:700>&amp;</span>stateC,  
      predicate: <span style=color:#000;font-weight:700>func</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> { <span style=color:#000;font-weight:700>return</span> input <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#39;c&#39;</span> },  
   })  
  
   <span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
      name           <span style=color:#458;font-weight:700>string</span>  
      input          <span style=color:#458;font-weight:700>string</span>  
      expectedStatus Status  
   }  
  
   tests <span style=color:#000;font-weight:700>:=</span> []test{  
      {<span style=color:#d14>&#34;empty string&#34;</span>, <span style=color:#d14>&#34;&#34;</span>, Normal},  
      {<span style=color:#d14>&#34;non matching string&#34;</span>, <span style=color:#d14>&#34;xxx, Fail},  
</span><span style=color:#d14>      {&#34;</span>matching <span style=color:#458;font-weight:700>string</span><span style=color:#d14>&#34;, &#34;</span>abc<span style=color:#d14>&#34;, Success},  
</span><span style=color:#d14>      {&#34;</span>partial matching <span style=color:#458;font-weight:700>string</span><span style=color:#d14>&#34;, &#34;</span>ab<span style=color:#d14>&#34;, Normal},  
</span><span style=color:#d14>   }  
</span><span style=color:#d14>  
</span><span style=color:#d14>   for _, tt := range tests {  
</span><span style=color:#d14>      t.Run(tt.name, func(t *testing.T) {  
</span><span style=color:#d14>         testRunner := NewRunner(&amp;startState)  
</span><span style=color:#d14>  
</span><span style=color:#d14>         for _, character := range tt.input {  
</span><span style=color:#d14>            testRunner.Next(character)  
</span><span style=color:#d14>         }  
</span><span style=color:#d14>  
</span><span style=color:#d14>         result := testRunner.getTotalState()  
</span><span style=color:#d14>         if tt.expectedStatus != result {  
</span><span style=color:#d14>            t.Fatalf(&#34;</span>Expected FSM to have final state of <span style=color:#a61717;background-color:#e3d2d2>&#39;</span><span style=color:#000;font-weight:700>%</span>v<span style=color:#a61717;background-color:#e3d2d2>&#39;</span>, got <span style=color:#a61717;background-color:#e3d2d2>&#39;</span><span style=color:#000;font-weight:700>%</span>v<span style=color:#a61717;background-color:#e3d2d2>&#39;&#34;</span>, tt.expectedStatus, result)  
         }  
      })  
   }  
}

</code></pre></div><p>Note: One might take a look at this test and say &ldquo;The states are being instantiated once and then used in every test. This is a bad practice as one test might affect the outcome of another.&rdquo; and I would totally agree. The only reason we&rsquo;re getting away with it here is because our State Machines are <strong>stateless</strong>, meaning they don&rsquo;t contain any information about the state of the process. On the other hand, our <code>runner</code> instance is <strong>stateful</strong>, so we want to create a new instance for every test case.</p>
<p>Now that we have our first test, let&rsquo;s implement the missing methods and make these tests pass.</p>
<h3 id=runner>Runner</h3>
<p>The first method we need to implement is a simple constructor function.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>NewRunner</span>(head <span style=color:#000;font-weight:700>*</span>State) <span style=color:#000;font-weight:700>*</span>runner {  
   r <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>runner{  
      head:    head,  
      current: head,  
   }  
  
   <span style=color:#000;font-weight:700>return</span> r  
}
</code></pre></div><p>This is a simple constructor which requires that we store two pointers to the root <code>State</code>. The <code>head</code> state will remain constant incase we want to reset the <code>runner</code>. The <code>current</code> state will represent where we are in the FSM, as represented by the red dot in our state machine diagrams.</p>
<p>Note: This assumes that we can only be in one place at a time in our FSM, more on that later..</p>
<p>Now, the <code>Next</code> method.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>func</span> (r <span style=color:#000;font-weight:700>*</span>runner) <span style=color:#900;font-weight:700>Next</span>(input <span style=color:#458;font-weight:700>rune</span>) {  
   <span style=color:#000;font-weight:700>if</span> r.current <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {  
      <span style=color:#000;font-weight:700>return</span>  
   }  
  
   <span style=color:#998;font-style:italic>// move to next matching transition  
</span><span style=color:#998;font-style:italic></span>   r.current = r.current.<span style=color:#900;font-weight:700>firstMatchingTransition</span>(input)  
}
</code></pre></div><p>All this does is change the <code>r.current</code> state to the state pointed to by the first matching transition of the current state. If <code>r.current</code> is <code>nil</code>, that means that the FSM has already fallen into a <code>fail</code> state, and so should do nothing.</p>
<p>The logic for finding the first matching transition is implemented on a method of the <code>State</code> struct, so let&rsquo;s implement that now.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>firstMatchingTransition</span>(input <span style=color:#458;font-weight:700>rune</span>) destination {  
   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> s.transitions {  
      <span style=color:#000;font-weight:700>if</span> t.<span style=color:#900;font-weight:700>predicate</span>(input) {  
         <span style=color:#000;font-weight:700>return</span> t.to  
      }  
   }  
  
   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>nil</span>  
}
</code></pre></div><p>This is pretty simple also. The function loops over the transitions of the state and returns the <code>destination</code> state of the first transition which passes the <code>predicate</code> test function. Notice that if the state has no <code>transition</code> which matches the predicate, the function returns <code>nil</code> - this is the same as the red dot in our diagrams leaving the FSM and represents a <code>Fail</code> case.</p>
<p>Finally, we just need to determine the status of the FSM at any time.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>func</span> (r <span style=color:#000;font-weight:700>*</span>runner) <span style=color:#900;font-weight:700>GetStatus</span>() Status {  
   <span style=color:#998;font-style:italic>// if the current state is nil, return Fail  
</span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>if</span> r.current <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {  
      <span style=color:#000;font-weight:700>return</span> Fail  
   }  
  
   <span style=color:#998;font-style:italic>// if the current state has no transitions from it, return Success  
</span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>if</span> r.current.<span style=color:#900;font-weight:700>isSuccessState</span>() {  
      <span style=color:#000;font-weight:700>return</span> Success  
   }  
  
   <span style=color:#998;font-style:italic>// else, return normal  
</span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>return</span> Normal  
}
</code></pre></div><p>Again, the logic for determining a <code>Success</code> status is implemented as a <code>State</code> struct method.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>isSuccessState</span>() <span style=color:#458;font-weight:700>bool</span> {  
   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(s.transitions) <span style=color:#000;font-weight:700>==</span> <span style=color:#099>0</span> {  
      <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>  
   }  
  
   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>  
}
</code></pre></div><p>Here we&rsquo;re using an assumption. The assumption is; if a transition leads to no other states, we can consider it a success state. This is not strictly true, but it&rsquo;s useful for now.</p>
<p>If we run the tests again, they should now be green! We now have a working, although pretty simple, finite state machine regex processor!</p>
<p>Note: Check out this part of the project on github <a href=https://github.com/LeweyM/search/tree/master/src/v1>here</a></p>
<p>Next:<a href=https://leweym.github.io/posts/regex-processor-3-starting-the-compiler/>Regex Processor 3 Starting the compiler</a></p>
<p>Prev:<a href=https://leweym.github.io/posts/regex-processor-1-intro/>Regex Processor 1 Intro</a></p>
</div>
<div class=post-tags>
</div>
</div>
<div class="footer wrapper">
<nav class=nav>
<div> <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
</body>
</html>