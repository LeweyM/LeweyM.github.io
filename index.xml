<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lewis Metcalf</title><link>https://LeweyM.github.io/</link><description>Recent content on Lewis Metcalf</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://LeweyM.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Http - A History</title><link>https://LeweyM.github.io/posts/http-a-history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/http-a-history/</guid><description>A few notes based on this great video
HTTP/1 TCP/IP The first and most simple approach, making a TCP handshake for each resource which has to be shared.
The downsides to this approach is that in order to speed up transfer rates, we want to send many resource pieces in parallel. With HTTP/1, this means doing a new TCP handshake every-time, which is costly and time consuming. This was alleviated in a later version HTTP/1.</description></item><item><title>Regex Processor</title><link>https://LeweyM.github.io/posts/regex-processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor/</guid><description>So, one of the things I&amp;rsquo;ve wanted to play around with is search and regex. Searching through text for matches to a regular expression can be efficiently implemented using finite state machines.
Finite State Machines finite state machines are both simple and useful. The simplest definition I can think of is something like this;
A finite State Machine (FSM) is a series of states. The machine start in some state, then decides the next state to go to based on some input.</description></item><item><title>Regex Processor - Part 2</title><link>https://LeweyM.github.io/posts/regex-processor-part-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor-part-2/</guid><description>## One or more
cool, so what about a regular expression like 'a+b'?
This means &amp;ldquo;match any string that has one or more 'a's, followed by a 'b'&amp;rdquo;. So, for example:
&amp;quot;ab&amp;quot; -&amp;gt; match &amp;quot;aaaaab&amp;quot; -&amp;gt; match &amp;quot;ba&amp;quot; -&amp;gt; no match &amp;quot;&amp;quot; -&amp;gt; no match What would the FSM look like for that? Well, it would look like the following;
This is pretty straight forward, if you&amp;rsquo;re at state[1], that means &amp;ldquo;you&amp;rsquo;ve already seen 'a'&amp;rdquo;.</description></item><item><title>Regex Processor - Part 3</title><link>https://LeweyM.github.io/posts/regex-processor-part-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor-part-3/</guid><description>## OR
Consider a regular expression like 'dog|cat', which means &amp;ldquo;match any string containing the substring dog or the substring cat&amp;rdquo;.
Hmm, although the structure is the same, we&amp;rsquo;re starting to see some complexity here. It looks like most of the complexity comes from the cross arrows running between the upper and lower states. Also, we need to remember in our regex for &amp;quot;cat&amp;quot; that if we process a 'c' somewhere during the the states along &amp;quot;cat&amp;quot;, we need to go back to the &amp;ldquo;you&amp;rsquo;ve seen 'c'&amp;rdquo; state instead of the beginning.</description></item><item><title>The Journey of a Refactor</title><link>https://LeweyM.github.io/posts/the-journey-of-a-refactor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/the-journey-of-a-refactor/</guid><description>Basically, I was trying to do something and went down the wrong path, and when I finally saw the light it all got a lot better.
Problem I’m trying to write a test that makes sure that no other fields in the db are effected when we write to the db - only the field that we care about. The issue is that when you decode a response from the db to a go struct, you can use known fields with a struct, or unknown fields with a map, but you can’t do a mix.</description></item></channel></rss>