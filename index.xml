<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lewis Metcalf</title><link>https://leweym.github.io/</link><description>Recent content on Lewis Metcalf</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://leweym.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>01 Intro</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/01-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/01-intro/</guid><description>So, one of the things I&amp;rsquo;ve wanted to play around with is search and regex. Searching through text for matches to a regular expression can be efficiently implemented using finite state machines.
Finite State Machines Finite state machines are both simple and useful. The simplest definition I can think of is something like this:
A finite State Machine (FSM) is a series of states. The machine start in some state, then decides the next state to go to based on some input.</description></item><item><title>02 Getting into some code</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/02-getting-into-some-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/02-getting-into-some-code/</guid><description>Let&amp;rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
// state.go type State struct { connectedStates []*State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&amp;rsquo;ll use a Transition struct to represent this.</description></item><item><title>03 Starting the compiler</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/03-starting-the-compiler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/03-starting-the-compiler/</guid><description>Now we have a working FSM and way to process strings, let&amp;rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states.</description></item><item><title>04 Testing, Fuzzing, and fixing things</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/</guid><description>We can spend some time here doing some interesting things to our tests, which should make our lives a bit easier down the road.
Testing against the Go regex package As Go includes its own regex package, we can use this to validate our own implementation. Let&amp;rsquo;s add a test which compares the results from our own FSM and the Go regex library.
// fsm_test.go func TestFSMAgainstGoRegexPkg(t *testing.T) { type test struct { name string regex string input string } tests := []test{ {&amp;#34;empty string&amp;#34;, &amp;#34;abc&amp;#34;, &amp;#34;&amp;#34;}, {&amp;#34;non matching string&amp;#34;, &amp;#34;abc&amp;#34;, &amp;#34;xxx&amp;#34;}, {&amp;#34;matching string&amp;#34;, &amp;#34;abc&amp;#34;, &amp;#34;abc&amp;#34;}, {&amp;#34;partial matching string&amp;#34;, &amp;#34;abc&amp;#34;, &amp;#34;ab&amp;#34;}, } for _, tt := range tests { t.</description></item><item><title>05 Wildcards</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/05-wildcards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/05-wildcards/</guid><description>Let&amp;rsquo;s start adding some special regex characters, starting with the '.' wildcard regular expression.
Wildcards The . character in a regular expression will match any character. To make this clear, here are a few example cases for the regular expression ab.;
abc -&amp;gt; success ab -&amp;gt; normal So, let&amp;rsquo;s add these as test cases in our code.
@@ // fsm_test.go {&amp;#34;nested expressions&amp;#34;, &amp;#34;a(b(d))c&amp;#34;, &amp;#34;abdc&amp;#34;}, {&amp;#34;substring match with reset needed&amp;#34;, &amp;#34;aA&amp;#34;, &amp;#34;aaA&amp;#34;}, {&amp;#34;substring match without reset needed&amp;#34;, &amp;#34;B&amp;#34;, &amp;#34;ABA&amp;#34;}, {&amp;#34;multibyte characters&amp;#34;, &amp;#34;Ȥ&amp;#34;, &amp;#34;Ȥ&amp;#34;}, { &amp;#34;complex multibyte characters&amp;#34;, string([]byte{0xef, 0xbf, 0xbd, 0x30}), string([]byte{0xcc, 0x87, 0x30}), }, + // wildcard + {&amp;#34;wildcard regex matching&amp;#34;, &amp;#34;ab.</description></item><item><title>06 Pretty Vizualizations</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/</guid><description>Now that we have a few features working, this is a good time to take a step back and build some things to help us see what we&amp;rsquo;re working with. The tools we&amp;rsquo;re going to build now will help with debugging as our features become more complex, and will give us a clearer picture of the logic of the systems we&amp;rsquo;re working with.
As a side note, I also think it&amp;rsquo;s worth mentioning that an important part of building a (kinda) sophisticated system is maintaining the developer infrastructure around it.</description></item><item><title>07 Branches</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/07-branches/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/07-branches/</guid><description>The OR expression It&amp;rsquo;s very useful to use a regular expression to match against multiple different possible substrings. For example, to check that a file is an image type, you might use the regular expression &amp;quot;png|jpge|gif&amp;quot; on the file extension. This would tell you if the file was png OR jpeg OR gif. The options of the OR expression are determined by the separating them with a pipe symbol (&amp;quot;|&amp;quot;).</description></item><item><title>08 Epsilons</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/08-epsilons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/08-epsilons/</guid><description>The empty string So, we have a regex engine that can handle branches, but our handy fuzzer has found something we can&amp;rsquo;t process correctly; The regular expression '1|'.
This is the same as saying &amp;ldquo;match the regex '1' OR match the regex ''&amp;rdquo;, but what does it mean to match the regex ''? This is the empty string case, and it&amp;rsquo;s something we&amp;rsquo;re going to start dealing with.
Semantically, the regular expression '' should always match, because every string, including the empty string itself, contains within it the empty string.</description></item><item><title>09 Groups</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/09-groups/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/09-groups/</guid><description>Groups Regular expressions can be grouped together using the '()' parenthesis symbols, in the same way that arithmetic constructions such as (1 + (3 * 7)) can be grouped. This hasn&amp;rsquo;t been a problem yet because up until now, we&amp;rsquo;ve only dealt with concatenation, and string concatenation is an associative operation. This means that grouping doesn&amp;rsquo;t make a difference. For example, 'a' + 'b' + 'c' == 'a' + 'bc' == 'ab' + 'c' == 'abc'.</description></item><item><title>10 Modifiers</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/10-modifiers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/10-modifiers/</guid><description>Modifiers Regular Expression modifiers are special characters which change how sub-expressions of the regex are interpreted. The three modifiers we&amp;rsquo;ll be implementing will be the '?', '+', and '*' modifiers.
Expected Behavior of Modifiers Zero or One The '?' symbol is the &amp;lsquo;Zero or One&amp;rsquo; modifier. It says that the regex should match an expression if it appears zero or once. For example, the regular expression ab?c has the following match profile;</description></item><item><title>11 Reducing Epsilon NFA to NFA</title><link>https://leweym.github.io/series/making-regex-from-scratch-in-go/11-reducing-epsilon-nfa-to-nfa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series/making-regex-from-scratch-in-go/11-reducing-epsilon-nfa-to-nfa/</guid><description>Reducing Epsilon NFA to NFA Having spent so long building up state machines using epsilon transitions, it now seems slightly perverse that we&amp;rsquo;re going to spend this chapter ripping them out! However, we&amp;rsquo;re still going to use them to compose our regular expression FSMs. The idea is to compose using epsilons, because it&amp;rsquo;s easier, and then reduce the epsilon-NFA to a normal NFA.
The benefits of doing so are mainly for performance, although we haven&amp;rsquo;t been particularly performance conscious up until now, and there are plenty of optimisations we could make before this one.</description></item><item><title>Http - A History</title><link>https://leweym.github.io/posts/http---a-history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/posts/http---a-history/</guid><description>A few notes based on this great video HTTP/1 TCP/IP The first and most simple approach, making a TCP handshake for each resource which has to be shared.
The downsides to this approach is that in order to speed up transfer rates, we want to send many resource pieces in parallel. With HTTP/1, this means doing a new TCP handshake every-time, which is costly and time consuming. This was alleviated in a later version HTTP/1.</description></item><item><title>making regex from scratch in GO</title><link>https://leweym.github.io/series-descriptions/making-regex-from-scratch-in-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/series-descriptions/making-regex-from-scratch-in-go/</guid><description>This series is a step by step guide to creating an (almost) fully fledged Regex engine using Go. It explores the basics of Finite State Automata, incrementally creates a parser and compiler for turning strings into state machines, walks through the setup of a visualizer for the FSM node graph. All of the development is structured as a TDD project, and uses modern Go features such as fuzzing, generics, and profiling.</description></item><item><title>The Journey of a Refactor</title><link>https://leweym.github.io/posts/the-journey-of-a-refactor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://leweym.github.io/posts/the-journey-of-a-refactor/</guid><description>Basically, I was trying to do something and went down the wrong path, and when I finally saw the light it all got a lot better.
Problem I’m trying to write a test that makes sure that no other fields in the db are effected when we write to the db - only the field that we care about. The issue is that when you decode a response from the db to a go struct, you can use known fields with a struct, or unknown fields with a map, but you can’t do a mix.</description></item></channel></rss>