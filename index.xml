<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lewis Metcalf</title><link>https://LeweyM.github.io/</link><description>Recent content on Lewis Metcalf</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://LeweyM.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Http - A History</title><link>https://LeweyM.github.io/posts/http-a-history/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/http-a-history/</guid><description>A few notes based on this great video
HTTP/1 TCP/IP The first and most simple approach, making a TCP handshake for each resource which has to be shared.
The downsides to this approach is that in order to speed up transfer rates, we want to send many resource pieces in parallel. With HTTP/1, this means doing a new TCP handshake every-time, which is costly and time consuming. This was alleviated in a later version HTTP/1.</description></item><item><title>Regex Processor</title><link>https://LeweyM.github.io/posts/regex-processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/regex-processor/</guid><description>So, one of the things I&amp;rsquo;ve wanted to play around with is search and regex. Regex always seemed like a bit of a mystery to me, and then one day I watched a lecture on finite state machines and it opened up a thriving vein of curiosity to follow.
Finite State Machines finite state machines are super simple and super useful. The simplest definition I can think of is something like this;</description></item><item><title>The Journey of a Refactor</title><link>https://LeweyM.github.io/posts/the-journey-of-a-refactor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://LeweyM.github.io/posts/the-journey-of-a-refactor/</guid><description>Basically, I was trying to do something and went down the wrong path, and when I finally saw the light it all got a lot better.
Problem I’m trying to write a test that makes sure that no other fields in the db are effected when we write to the db - only the field that we care about. The issue is that when you decode a response from the db to a go struct, you can use known fields with a struct, or unknown fields with a map, but you can’t do a mix.</description></item></channel></rss>