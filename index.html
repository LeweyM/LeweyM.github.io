<!doctype html><html>
<head>
<meta name=generator content="Hugo 0.91.2">
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Lewis Metcalf </title><meta name=viewport content="width=device-width,initial-scale=1">
<link rel=alternate type=application/rss+xml href=https://leweym.github.io/index.xml title="Lewis Metcalf">
<meta property="og:title" content="Lewis Metcalf">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="https://leweym.github.io/">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Lewis Metcalf">
<meta name=twitter:description content>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet>
<link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css>
<script src=https://leweym.github.io/js/main.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<base href=https://leweym.github.io/>
<h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1>
<div class=site-description><nav class="nav social">
<ul class=flat></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
</ul>
</nav>
</div>
<div class="recent-posts section">
<h2 class=section-header>
Recent posts
</h2>
<div class=posts>
<div class=post>
<div class=meta></div>
<a class=title href=/posts/http-a-history/>Http - A History</a> &mdash;
<span class=description>
A few notes based on this great video
HTTP/1 TCP/IP The first and most simple approach, making a TCP handshake for each resource which has to be shared.
The downsides to this approach is that in order to speed up transfer rates, we want to send many resource pieces in parallel. With HTTP/1, this means doing a new TCP handshake every-time, which is costly and time consuming. This was alleviated in a later version HTTP/1.&mldr;
</span>
</div>
<div class=post>
<div class=meta></div>
<a class=title href=/posts/regex-processor-1-intro/>Regex Processor 1 Intro</a> &mdash;
<span class=description>
So, one of the things I&rsquo;ve wanted to play around with is search and regex. Searching through text for matches to a regular expression can be efficiently implemented using finite state machines.
Finite State Machines finite state machines are both simple and useful. The simplest definition I can think of is something like this;
A finite State Machine (FSM) is a series of states. The machine start in some state, then decides the next state to go to based on some input.&mldr;
</span>
</div>
<div class=post>
<div class=meta></div>
<a class=title href=/posts/regex-processor-2-getting-into-some-code/>Regex Processor 2 Getting into some code</a> &mdash;
<span class=description>
Let&rsquo;s start coding.
The FSM data structure We can first think about our core data structures to represent the FSM. The FSM is essentially a linked list of state objects.
type State struct { connectedStates []State } We need a bit more information, however, as we need to know which character allows us to go from one state to another. We&rsquo;ll use a Transition struct to represent this.
The Transition struct contains two things:&mldr;
</span>
</div>
<div class=post>
<div class=meta></div>
<a class=title href=/posts/regex-processor-3-starting-the-compiler/>Regex Processor 3 Starting the compiler</a> &mdash;
<span class=description>
Now we have a working FSM and way to process strings, let&rsquo;s take a look at building FSMs automatically from regular expressions using a compiler.
Compiling a Finite State Machine We can break down the previous example of writing an FSM for the regular expression abc into at least 2 discrete steps;
Take the string abc and create a linked list of 'states' with conditional transitions to other states. Process the input by moving through the states.&mldr;
</span>
</div>
<div class=post>
<div class=meta></div>
<a class=title href=/posts/regex-processor-4-testing-fuzzing-and-fixing-things/>Regex Processor 4 Testing, Fuzzing, and fixing things</a> &mdash;
<span class=description>
We can spend some time here doing some interesting things to our tests, which should make our lives a bit easier down the road.
Testing against the Go regex package As Go includes its own regex package, we can use this to validate our own implementation. Let&rsquo;s add a test which compares the results from our own FSM and the Go regex library.
func TestFSMAgainstGoRegexPkg(t *testing.T) { type test struct { name string regex string input string } tests := []test{ {"empty string", "abc", ""}, {"non matching string", "abc", "xxx"}, {"matching string", "abc", "abc"}, {"partial matching string", "abc", "ab"}, } for _, tt := range tests { t.&mldr;
</span>
</div>
<div class=post>
<div class=meta></div>
<a class=title href=/posts/regex-processor-5-wildcards/>Regex Processor 5 Wildcards</a> &mdash;
<span class=description>
Let&rsquo;s start adding some special regex characters, starting with the '.' wildcard regular expression.
Wildcards The . character in a regular expression will match any character. To make this clear, here are a few example cases for the regular expression ab.;
abc -> success ab -> normal So, let&rsquo;s add these as test cases in our code.
{"nested expressions", "a(b(d))c", "abdc"}, {"substring match with reset needed", "aA", "aaA"}, {"substring match without reset needed", "B", "ABA"}, {"multibyte characters", "Ȥ", "Ȥ"}, { "complex multibyte characters", string([]byte{0xef, 0xbf, 0xbd, 0x30}), string([]byte{0xcc, 0x87, 0x30}), }, + // wildcard + {"wildcard regex matching", "ab.&mldr;
</span>
</div>
<div class=post>
<div class=meta></div>
<a class=title href=/posts/the-journey-of-a-refactor/>The Journey of a Refactor</a> &mdash;
<span class=description>
Basically, I was trying to do something and went down the wrong path, and when I finally saw the light it all got a lot better.
Problem I’m trying to write a test that makes sure that no other fields in the db are effected when we write to the db - only the field that we care about. The issue is that when you decode a response from the db to a go struct, you can use known fields with a struct, or unknown fields with a map, but you can’t do a mix.&mldr;
</span>
</div>
</div>
</div>
</div>
<div class="footer wrapper">
<nav class=nav>
<div> <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
</body>
</html>