<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>08 Epsilons - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="08 Epsilons"><meta property="og:description" content="The empty string So, we have a regex engine that can handle branches, but our handy fuzzer has found something we can&rsquo;t process correctly; The regular expression '1|'.
This is the same as saying &ldquo;match the regex '1' OR match the regex ''&rdquo;, but what does it mean to match the regex ''? This is the empty string case, and it&rsquo;s something we&rsquo;re going to start dealing with.
Semantically, the regular expression '' should always match, because every string, including the empty string itself, contains within it the empty string."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/content/series/making-regex-from-scratch-in-go/08-epsilons/"><meta property="article:section" content="content"><meta property="og:see_also" content="https://leweym.github.io/content/series/making-regex-from-scratch-in-go/01-intro/"><meta property="og:see_also" content="https://leweym.github.io/content/series/making-regex-from-scratch-in-go/02-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/content/series/making-regex-from-scratch-in-go/03-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/content/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/content/series/making-regex-from-scratch-in-go/05-wildcards/"><meta property="og:see_also" content="https://leweym.github.io/content/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="08 Epsilons"><meta name=twitter:description content="The empty string So, we have a regex engine that can handle branches, but our handy fuzzer has found something we can&rsquo;t process correctly; The regular expression '1|'.
This is the same as saying &ldquo;match the regex '1' OR match the regex ''&rdquo;, but what does it mean to match the regex ''? This is the empty string case, and it&rsquo;s something we&rsquo;re going to start dealing with.
Semantically, the regular expression '' should always match, because every string, including the empty string itself, contains within it the empty string."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/bootstrap.css><script src=https://leweym.github.io/js/main.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6FPTHJ5QN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6FPTHJ5QN")</script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/content/series/making-regex-from-scratch-in-go/01-intro/>01 Intro</a> <span class=meta></span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/02-getting-into-some-code/>02 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/03-starting-the-compiler/>03 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/>04 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/05-wildcards/>05 Wildcards</a> <span class=meta></span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/>06 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/07-branches/>07 Branches</a> <span class=meta></span></div><div class=post><span>08 Epsilons</span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/09-groups/>09 Groups</a> <span class=meta></span></div><div class=post><a href=/content/series/making-regex-from-scratch-in-go/10-modifiers/>10 Modifiers</a> <span class=meta></span></div></div></div><br><div class=post-header><h1 class=title>08 Epsilons</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#the-empty-string>The empty string</a></li><li><a href=#ε>ε</a></li></ul></nav></aside><div class=markdown><h2 id=the-empty-string>The empty string</h2><p>So, we have a regex engine that can handle branches, but our handy fuzzer has found something we can&rsquo;t process correctly; The regular expression <code>'1|'</code>.</p><p>This is the same as saying &ldquo;match the regex <code>'1'</code> OR match the regex <code>''</code>&rdquo;, but what does it mean to match the regex <code>''</code>? This is the empty string case, and it&rsquo;s something we&rsquo;re going to start dealing with.</p><p>Semantically, the regular expression <code>''</code> should always match, because every string, including the empty string itself, contains within it the empty string. Also, any string of N characters contains N+1 empty strings within it, because each character has an empty string on either side of it. For example, the string <code>"ab"</code> has an empty string before <code>a</code>, between <code>a</code> and <code>b</code>, and after <code>b</code> (like <code>'_a_b_'</code> where <code>'_'</code> represents an empty string).</p><p>Up until now, the empty string hasn&rsquo;t posed us a problem because we&rsquo;ve only dealt with concatenations. The empty string can only appear as the regular expression <code>''</code>, which would lead to the following FSM:</p><div class=mermaid>graph LR
0((0))</div><p>Which would automatically be in a success state. Remember, <strong>a success state in our program is defined as any state with no outgoing transitions</strong>. As this single <code>State</code> has no other transitions, it would be considered a <code>success</code>, and so a match would always be found.</p><p>But now, we need a way of dealing with empty string expressions of different branches, such as in our current problem of <code>1|</code>. Currently, our compiler produces the FSM</p><div class=mermaid>graph LR
0((0)) --"1"--> 1((1))</div><p>Which is the result of the following merge operations:</p><div class=mermaid>graph LR
0((0))
1((0)) --"1"--> 3((1))
2((0))
2 -."merge".- 0
2 -."merge".- 1</div><p>This effectively removes the top expression, our empty string expression. It seems that in cases such as these, the merge operation will not work. What we want is a way of <em>starting at each branch at the same time</em>, rather than starting from the same place.</p><p>The difference is subtle but critical, and we can&rsquo;t do this with our current FSM. We&rsquo;ll need to introduce a new and powerful element to our FSM. The <strong>epsilon (ε) transition</strong>.</p><h2 id=ε>ε</h2><p>In the context of Finite State Machines, the ε, or epsilon, represents the empty string. If a state has a transition on the condition of the empty string, it means that it doesn&rsquo;t need to process a character in order to transition to the next state. This turns out to be a very powerful characteristic for composing FSMs representing complex regular expressions.</p><p>One thing that we can do with epsilon transitions is to say &ldquo;If you&rsquo;re in this state, you should also be in these other states&rdquo;. This makes it easier to compose FSMs because we can take subtrees of the FSM - decoupled groups of <code>States</code> which represent a subset - and join them together using epsilons without worrying about how they start.</p><p>For example, the above <code>'|1'</code> regular expression can be represented using epsilon transitions as the following FSM.</p><div class=mermaid>graph LR
0((1))
1((2)) --"1"--> 2((3))
3((0))
3 -."ε".-> 0
3 -."ε".-> 1</div><p>These epsilon transitions mean that starting at <code>State 0</code> is <strong>equivalent</strong> to starting at <code>State 1</code> and <code>State 2</code>.</p><h3 id=implementing-epsilon-transitions>Implementing epsilon transitions</h3><p>We need to treat epsilon transitions differently to regular transitions. It will require some changes to how we process characters, because we&rsquo;ll need to process the epsilon transitions before and after the character transitions.</p><p>We can break the implementation down into a few steps</p><ol><li>Add epsilon transitions to data structures</li><li>Compile using epsilon transitions</li><li>Draw epsilon transitions</li><li>Process epsilon transitions</li></ol><p>Before any of that, however, let&rsquo;s start with a test case for the problem we&rsquo;re trying to solve. In this case, it&rsquo;s the <code>'1|'</code> case, so let&rsquo;s start with something similar.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestFSMAgainstGoRegexPkg(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>                {&#34;branch matching 1st branch&#34;, &#34;ab|cd&#34;, &#34;ab&#34;},
</span></span><span style=display:flex><span>                {&#34;branch matching 2nd branch&#34;, &#34;ab|cd&#34;, &#34;cd&#34;},
</span></span><span style=display:flex><span>                {&#34;branch not matching&#34;, &#34;ab|cd&#34;, &#34;ac&#34;},
</span></span><span style=display:flex><span>                {&#34;branch with shared characters&#34;, &#34;dog|dot&#34;, &#34;dog&#34;}, 
</span></span><span style=display:flex><span>                {&#34;branch with shared characters&#34;, &#34;dog|dot&#34;, &#34;dot&#34;}, 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;branch with right side empty&#34;, &#34;a|&#34;, &#34;&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;branch with left side empty&#34;, &#34;|a&#34;, &#34;&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span></code></pre></div><p>Now, let&rsquo;s start including them in our main data structures.</p><h3 id=1-add-epsilons-to-data-structures>1. Add epsilons to data structures</h3><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // state.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> type State struct {
</span></span><span style=display:flex><span>        transitions []Transition
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       epsilons    []*State
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        incoming    []*State
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>Epsilon transitions don&rsquo;t need things like <code>Predicates</code> like regular transitions do, because they always result in a transition. Because of this, we can represent them simply as a slice of <code>State</code> pointers.</p><p>We&rsquo;ll also need to change the success criteria of a state to include epsilons.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // state.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> func (s *State) isSuccessState() bool {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       if len(s.transitions) == 0 {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       if len(s.transitions) == 0 &amp;&amp; len(s.epsilons) == 0 {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                return true
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>Epsilons should be deleted when removing a node also.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // state.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (s *State) delete() {  
</span></span><span style=display:flex><span>   // 1. remove s from incoming of connected nodes.  
</span></span><span style=display:flex><span>   for _, t := range s.transitions {  
</span></span><span style=display:flex><span>      t.to.removeIncoming(s)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   // 2. remove the outgoing transitions  
</span></span><span style=display:flex><span>   s.transitions = nil  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+  s.epsilons = nil  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>}
</span></span></code></pre></div><p>And let&rsquo;s include a method to add new epsilon transitions, similar to how we add regular transitions.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>addEpsilon</span>(destination <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   s.epsilons = <span style=color:#0086b3>append</span>(s.epsilons, destination)  
</span></span><span style=display:flex><span>   destination.incoming = <span style=color:#0086b3>append</span>(destination.incoming, s)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That should be enough for our data structures, let&rsquo;s move onto compiling our AST nodes into FSMs that use epsilon transitions.</p><h3 id=2-compiling-with-epsilon-transitions>2. Compiling with epsilon transitions.</h3><p>For branches, the changes required to use epsilon transitions are very small. We want to change this;</p><div class=mermaid>graph LR
0((0))
1((0)) --"1"--> 3((1))
2((0))
2 -."merge".- 0
2 -."merge".- 1</div><p>To this;</p><div class=mermaid>graph LR
0((1))
1((2)) --"1"--> 2((3))
3((0))
3 -."ε".-> 0
3 -."ε".-> 1</div><p>So we simply need to swap out the <code>merge</code> operations for <code>addEpsilon</code> operations.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (b *Branch) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startState := &amp;State{}
</span></span><span style=display:flex><span>        for _, expression := range b.ChildNodes {
</span></span><span style=display:flex><span>                nextStateHead, _ := expression.compile()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               startState.merge(nextStateHead)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+               startState.addEpsilon(nextStateHead)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span><span style=display:flex><span>        return startState, startState
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>That&rsquo;s really all there is to the compilation step.</p><p>It&rsquo;s a shame that we can&rsquo;t verify it yet, so let&rsquo;s now fix our <code>draw</code> functions so that we can visualize our new epsilon transitions.</p><h3 id=3-drawing-epsilon-transitions>3. Drawing epsilon transitions</h3><p>Let&rsquo;s start with adding a new test case to our <code>Test_drawFSM</code> test function which uses a branch regex. This will let us define what we want our <code>mermaid</code> graph to look like for FSMs with epsilon transitions.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // draw_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+func aεbBuilder() *State {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   state1, state2, state3, state4 := &amp;State{}, &amp;State{}, &amp;State{}, &amp;State{}  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   state1.addTransition(state2, Predicate{allowedChars: &#34;a&#34;}, &#34;a&#34;)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   state2.addEpsilon(state3)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   state3.addTransition(state4, Predicate{allowedChars: &#34;b&#34;}, &#34;b&#34;)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   return state1  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func Test_DrawFSM(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>    tests := []test{  
</span></span><span style=display:flex><span> 	   {  
</span></span><span style=display:flex><span> 	  	  name:       &#34;simple example&#34;,  
</span></span><span style=display:flex><span>		  fsmBuilder: abcBuilder,  
</span></span><span style=display:flex><span>		  expected: `graph LR  
</span></span><span style=display:flex><span>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span><span style=display:flex><span>1((1)) --&#34;b&#34;--&gt; 2((2))  
</span></span><span style=display:flex><span>2((2)) --&#34;c&#34;--&gt; 3((3))`,  
</span></span><span style=display:flex><span>	   },  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+      {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+         name:       &#34;graph with epsilon&#34;,  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+         fsmBuilder: aεbBuilder,  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+         expected: `graph LR  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+1((1)) -.&#34;ε&#34;.-&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+2((2)) --&#34;b&#34;--&gt; 3((3))`,  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+      },  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   }
</span></span></span></code></pre></div><p>This would render the following <code>mermaid</code> graph.</p><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
0((0)) -."ε".-> 3((3))
1((1)) --"a"--> 2((2))
3((3)) --"b"--> 4((4))</div><p>This looks great, the epsilon transitions are denoted with dotted lines and a <code>'ε'</code> symbol. It&rsquo;s also notable that the epsilon lines are drawn before the transition lines. This is not relevant now, but might have an effect later on when we have arrows going in different directions.</p><p>Ok, let&rsquo;s change our <code>draw</code> code to reflect these changes and get our tests to green again. First, we&rsquo;ll need to adapt our <code>visitNodes</code> function to add epsilon transitions to our <code>OrderedSet[Transition]</code> <em>before</em> we add regular transitions, and we&rsquo;ll also want to recur on epsilon transitions as well as regular transitions to make sure that every connected node is visited.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // draw.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func visitNodes(
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                return
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       // 2.i. Add transitions for the nodes epsilon transitions
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       for _, epsilon := range node.epsilons {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               transitions.add(Transition{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       debugSymbol: &#34;ε&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       from:        node,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       to:          epsilon,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       predicate:   Predicate{},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        // 2 Add the transitions from this node to a set of transitions.
</span></span><span style=display:flex><span>        for _, transition := range node.transitions {
</span></span><span style=display:flex><span>                transitions.add(transition)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func visitNodes(
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>        // 3. Mark the current node as visited.
</span></span><span style=display:flex><span>        visited.add(node)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       // 4.i. Recur on every epsilon.
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       for _, epsilon := range node.epsilons {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               visitNodes(epsilon, transitions, visited)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        // 4. Recur on the destination node of every outgoing transition.
</span></span><span style=display:flex><span>        for _, transition := range node.transitions {
</span></span><span style=display:flex><span>                destinationNode := transition.to
</span></span></code></pre></div><p>Nearly there, we just need to draw epsilons with dotted lines instead of regular lines.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // draw.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (s *State) Draw() (graph string, nodeSet OrderedSet[*State]) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>        for _, t := range transitionSet.list() {
</span></span><span style=display:flex><span>                fromId := nodeSet.getIndex(t.from)
</span></span><span style=display:flex><span>                toId := nodeSet.getIndex(t.to)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               output = append(output, fmt.Sprintf(&#34;%d((%d)) --\&#34;%s\&#34;--&gt; %d((%d))&#34;, fromId, fromId, t.debugSymbol, toId, toId))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+               if t.debugSymbol == &#34;ε&#34; {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       output = append(output, fmt.Sprintf(&#34;%d((%d)) -.\&#34;%s\&#34;.-&gt; %d((%d))&#34;, fromId, fromId, t.debugSymbol, toId, toId))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               } else {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       output = append(output, fmt.Sprintf(&#34;%d((%d)) --\&#34;%s\&#34;--&gt; %d((%d))&#34;, fromId, fromId, t.debugSymbol, toId, toId))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span></code></pre></div><p>Now, our <code>draw</code> tests should be passing, and we can print out the graph below for the regular expression <code>cat|dog</code>.</p><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
0((0)) -."ε".-> 5((5))
1((1)) --"c"--> 2((2))
2((2)) --"a"--> 3((3))
3((3)) --"t"--> 4((4))
5((5)) --"d"--> 6((6))
6((6)) --"o"--> 7((7))
7((7)) --"g"--> 8((8))</div><p>Great! Let&rsquo;s also look at the FSM we create for our problematic <code>'|1'</code> case:</p><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
0((0)) -."ε".-> 2((2))
2((2)) --"1"--> 3((3))</div><p>That&rsquo;s better. Now, before we&rsquo;ve processed any character, we should already be in <code>State 0</code>, <code>State 1</code> and <code>State 2</code>. <code>State 1</code> represents an FSM for an empty string, and, as we can see, it has no outgoing transitions, so it always has a <code>success</code> status.</p><p>The only thing left to get this working is to actually process the epsilon transitions in our <code>runner</code>.</p><h3 id=4-processing-epsilon-transitions>4. Processing epsilon transitions</h3><p>Before we think about how to process epsilon transitions, let&rsquo;s think about where and when we need to process them. We&rsquo;ll imagine for now that we have a <code>advanceEpsilons</code> function that we can call, and we&rsquo;ll figure out how it works later<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Epsilons need to be processed before any characters have been processed. Let&rsquo;s account for this in our <code>Next</code> function, as well as our <code>Start</code> and <code>Reset</code> functions.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // runner.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (r *runner) Next(input rune) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       r.advanceEpsilons()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        nextActiveStates := Set[*State]{}
</span></span><span style=display:flex><span>        for activeState := range r.activeStates {
</span></span><span style=display:flex><span>                for _, nextState := range activeState.matchingTransitions(input) {
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (r *runner) Next(input rune) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        r.activeStates = nextActiveStates
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> func (r *runner) Reset() {
</span></span><span style=display:flex><span>        r.activeStates = NewSet[*State](r.head)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       r.advanceEpsilons()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> func (r *runner) Start() {
</span></span><span style=display:flex><span>        r.activeStates.add(r.head)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       r.advanceEpsilons()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+}
</span></span></span></code></pre></div><p>This should cover most of our cases, but there&rsquo;s one more thing we&rsquo;ve not thought about yet. What happens if we process a character and land on a new <code>State</code> which has outgoing epsilon transitions? We would need to activate the <code>States</code> pointed to by those epsilon transitions also, so let&rsquo;s call <code>advanceEpsilons</code> after processing the character transitions also.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // runner.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (r *runner) Next(input rune) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       r.advanceEpsilons()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        nextActiveStates := Set[*State]{}
</span></span><span style=display:flex><span>        for activeState := range r.activeStates {
</span></span><span style=display:flex><span>                for _, nextState := range activeState.matchingTransitions(input) {
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (r *runner) Next(input rune) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        r.activeStates = nextActiveStates
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       r.advanceEpsilons()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span></code></pre></div><p>Ok, let&rsquo;s now look at <code>advanceEpsilons</code>. The algorithm for this function should be fairly simple, but could have significant performance implications. The reason for this is that it is recursive in nature. To understand this, imagine an FSM of which every node is connected by an epsilon transition.</p><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
1((1)) -."ε".-> 2((2))
2((2)) -."ε".-> 3((3))
3((3)) -."ε".-> 0((0))</div><p>This is a perfectly valid FSM, and we need to be able to process it. What would happen is that we would start from <code>State 0</code>, process its epsilon transition to activate <code>State 1</code>, and then we would need to <em>recursively activate</em> the epsilon transitions of <code>State 2</code>, and so on until all epsilon transitions have been processed for all active states. We also need to be careful when we get to <code>State 3</code>, because <code>State 0</code> has already been activated, so we want to stop the recursion there. If we don&rsquo;t stop, we could end up in an infinite loop.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// runner.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (r <span style=color:#000;font-weight:700>*</span>runner) <span style=color:#900;font-weight:700>advanceEpsilons</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> state <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> r.activeStates {  
</span></span><span style=display:flex><span>      r.<span style=color:#900;font-weight:700>activateConnectedEpsilons</span>(state)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (r <span style=color:#000;font-weight:700>*</span>runner) <span style=color:#900;font-weight:700>activateConnectedEpsilons</span>(state <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, epsilon <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> state.epsilons {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>if</span> !r.activeStates.<span style=color:#900;font-weight:700>has</span>(epsilon) {  
</span></span><span style=display:flex><span>         r.activeStates.<span style=color:#900;font-weight:700>add</span>(epsilon)  
</span></span><span style=display:flex><span>         r.<span style=color:#900;font-weight:700>activateConnectedEpsilons</span>(epsilon)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the algorithm above, we look at each active <code>State</code>, look at each of that <code>State's</code> epsilons, and see if it&rsquo;s already active. Only if it&rsquo;s not active do we add it to the <code>activeStates</code> set, and then recur on that <code>State</code>. Otherwise, it&rsquo;s just ignored.</p><p>That should be enough to get our tests working again. Let&rsquo;s check out a few examples in our visualizer to get a sense of what&rsquo;s happening.</p><p>Let&rsquo;s try our <code>cat|dog</code> example. First we&rsquo;ll try the input string <code>"cat"</code></p><p><img src=/img/cat-good-demo.gif alt=cat-good-demo.gif></p><p>Great, we now start in <code>State 1</code> and <code>State 5</code> because of our epsilon transitions. Now with the input string <code>"dog"</code>.</p><p><img src=/img/dog-good-demo.gif alt=dog-good-demo.gif></p><p>Great, everything&rsquo;s still working perfectly.</p><p>What about one of the failing example we had before? Previously, branches which shared substrings were having difficulty because the FSM didn&rsquo;t determine which branch it should go down. We fixed this before with multiple active states, let&rsquo;s make sure that it&rsquo;s still working.</p><p><img src=/img/mutli-branch-good-demo.gif alt=mutli-branch-good-demo.gif></p><p>Great, still as expected.</p><p>What about our tricky <code>'1|'</code> regular expression? Let&rsquo;s try that now.</p><p><img src=/img/empty-regex-branch-demo.gif alt=empty-regex-branch-demo.gif></p><p>As we can see, our FSM is always in a <code>success</code> state; <code>State 3</code>. Great, it looks like we&rsquo;ve covered all the cases for branches. Let&rsquo;s run our fuzzer and see if we&rsquo;re right.</p><p>Not quite, the fuzzer finds an error pretty quickly&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>--- FAIL: FuzzFSM <span style=color:#000;font-weight:700>(</span>0.00s<span style=color:#000;font-weight:700>)</span>
</span></span><span style=display:flex><span>	fsm_test.go:142: Mismatch - 
</span></span><span style=display:flex><span>		Regex: <span style=color:#d14>&#39;1(|)&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 31287c29<span style=color:#000;font-weight:700>)</span>, 
</span></span><span style=display:flex><span>		Input: <span style=color:#d14>&#39;0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 30<span style=color:#000;font-weight:700>)</span> 
</span></span><span style=display:flex><span>		-&gt; 
</span></span><span style=display:flex><span>		Go Regex Pkg: <span style=color:#d14>&#39;false&#39;</span>, 
</span></span><span style=display:flex><span>		Our regex result: <span style=color:#d14>&#39;true&#39;</span>
</span></span></code></pre></div><p>Let&rsquo;s break down the regex <code>1(|)</code>. It&rsquo;s looking for the character <code>'1'</code> followed by <code>''</code> OR <code>''</code>. In other words, it&rsquo;s looking for the character <code>'1'</code>. Given that information, it&rsquo;s obvious that we shouldn&rsquo;t give a correct match with <code>0</code>! Let&rsquo;s inspect our FSM graph to see what&rsquo;s going on.</p><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
0((0)) -."ε".-> 3((3))
1((1)) --"1"--> 2((2))</div><p>Ok, we can see the problem here. This FSM does not respect the <code>'('</code> and <code>')'</code> characters in the regular expression, and is instead compiling the regular expression <code>1|</code>. This is not surprising, as haven&rsquo;t taught our program how to handle parentheses yet!</p><div class="notices note"><p>It&rsquo;s worth noting that we haven&rsquo;t run into any issues with parentheses until now because, until now, we&rsquo;ve only been working with concatenations. Concatenation has the <strong>associative property</strong>, which means that we can group them together without it making a difference to the outcome. For example, <code>"a" + "b" + "c"</code> is the same as <code>"a" + ("b" + "c")</code>.
Integer addition is also associative, so <code>1 + 2 + 3 == 1 + (2 + 3)</code>.</p></div><p>Now&rsquo;s the time to add support for grouping by parentheses.</p><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v7>here</a></p></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This is a handy design practice that can be used in many situations. Come up with the name of a function first, use it as you would like to, and only then come up with the implementation. Like TTD, it forces you to think first about the purpose of the function, before thinking about how it works.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p>Previous: <a href=/content/series/making-regex-from-scratch-in-go/07-branches/>07 Branches</a><span class=meta></span></p><p>Next: <a href=/content/series/making-regex-from-scratch-in-go/09-groups/>09 Groups</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>