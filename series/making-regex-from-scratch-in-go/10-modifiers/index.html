<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>10 Modifiers - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="10 Modifiers"><meta property="og:description" content="Modifiers Regular Expression modifiers are special characters which change how sub-expressions of the regex are interpreted. The three modifiers we&rsquo;ll be implementing will be the '?', '+', and '*' modifiers.
Expected Behavior of Modifiers Zero or One The '?' symbol is the &lsquo;Zero or One&rsquo; modifier. It says that the regex should match an expression if it appears zero or once. For example, the regular expression ab?c has the following match profile;"><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/10-modifiers/"><meta property="article:section" content="series"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/01-intro/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/02-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/03-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/05-wildcards/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="10 Modifiers"><meta name=twitter:description content="Modifiers Regular Expression modifiers are special characters which change how sub-expressions of the regex are interpreted. The three modifiers we&rsquo;ll be implementing will be the '?', '+', and '*' modifiers.
Expected Behavior of Modifiers Zero or One The '?' symbol is the &lsquo;Zero or One&rsquo; modifier. It says that the regex should match an expression if it appears zero or once. For example, the regular expression ab?c has the following match profile;"><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/bootstrap.css><script src=https://leweym.github.io/js/main.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6FPTHJ5QN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6FPTHJ5QN")</script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/series/making-regex-from-scratch-in-go/01-intro/>01 Intro</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/02-getting-into-some-code/>02 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/03-starting-the-compiler/>03 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/>04 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/05-wildcards/>05 Wildcards</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/>06 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/07-branches/>07 Branches</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/08-epsilons/>08 Epsilons</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/09-groups/>09 Groups</a> <span class=meta></span></div><div class=post><span>10 Modifiers</span></div></div></div><br><div class=post-header><h1 class=title>10 Modifiers</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#modifiers>Modifiers</a></li><li><a href=#expected-behavior-of-modifiers>Expected Behavior of Modifiers</a></li><li><a href=#modelling-modifiers-with-epsilon-fsms>Modelling Modifiers with Epsilon FSMs</a></li><li><a href=#why-epsilons>Why Epsilons?</a></li><li><a href=#implementing-modifiers>Implementing Modifiers</a></li><li><a href=#a-few-examples>A few examples</a></li><li><a href=#whats-next>What&rsquo;s next?</a></li></ul></nav></aside><div class=markdown><h2 id=modifiers>Modifiers</h2><iframe src=/html/a0638db1c14190ad961f1935937a2bd2.html alt class=w-100 style=height:80vh></iframe><p>Regular Expression modifiers are special characters which change how sub-expressions of the regex are interpreted. The three modifiers we&rsquo;ll be implementing will be the <code>'?'</code>, <code>'+'</code>, and <code>'*'</code> modifiers.</p><h2 id=expected-behavior-of-modifiers>Expected Behavior of Modifiers</h2><h3 id=zero-or-one>Zero or One</h3><p>The <code>'?'</code> symbol is the &lsquo;Zero or One&rsquo; modifier. It says that the regex should match an expression if it appears zero or once. For example, the regular expression <code>ab?c</code> has the following match profile;</p><ul><li><code>'abc'</code> → match</li><li><code>'ac'</code> → match</li><li><code>'abbc'</code> → no match</li></ul><p>Similarly, the regular expression <code>(abc)?z</code> has the profile</p><ul><li><code>'abcz'</code> → match</li><li><code>'z'</code> → match</li><li><code>'abcabcz'</code> → no match</li></ul><h3 id=one-or-more>One or More</h3><p>The <code>'+'</code> symbol is the &lsquo;One or More&rsquo; modifier. It says that the regex should match an expression if it appears one or more times. For example, the regular expression <code>ab+c</code> has the following match profile;</p><ul><li><code>'abc'</code> → match</li><li><code>'abbc'</code> → match</li><li><code>'abbbc'</code> → match</li><li><code>'ac'</code> → no match</li></ul><p>Similarly, the regular expression <code>(abc)+</code> has the profile</p><ul><li><code>'abc'</code> → match</li><li><code>'abcabc'</code> → match</li><li><code>''</code> → no match</li></ul><h3 id=zero-or-more>Zero or More</h3><p>The <code>'*'</code> symbol is the &lsquo;Zero or More&rsquo; modifier. It says that the regex should match an expression if it appears zero or more times. For example, the regular expression <code>ab*c</code> has the following match profile;</p><ul><li><code>'abc'</code> → match</li><li><code>'abbc'</code> → match</li><li><code>'abbbc'</code> → match</li><li><code>'ac'</code> → match</li></ul><p>Similarly, the regular expression `(abc)*&rsquo; has the profile</p><ul><li><code>'abc'</code> → match</li><li><code>'abcabc'</code> → match</li><li><code>''</code> → match</li></ul><h2 id=modelling-modifiers-with-epsilon-fsms>Modelling Modifiers with Epsilon FSMs</h2><p>Modelling this behaviour with state machines is fairly straight forward when using epsilon transitions.</p><p>Let&rsquo;s start with the Zero or One modifier.</p><h3 id=zero-or-one-1>Zero or One</h3><p>Modelling the behaviour for this modifier involves implementing an optional <strong>skip</strong> step between the <code>State</code> (or <code>States</code>) that represent the sub expression, so that we can &lsquo;skip&rsquo; over it for the &lsquo;zero&rsquo; case or pass through it as normal for the &lsquo;one&rsquo; case.</p><p>This should look something like this;</p><p><img src=/img/Pasted-image-20221009123359.png alt=Pasted-image-20221009123359.png></p><p>Let&rsquo;s explain this a bit.</p><p>To apply the <code>'?'</code> modifier to an FSM, we need to start from a <code>State</code> which has an epsilon transition to the start of the FSM, and also an epsilon transition to the end of the FSM.</p><p>The epsilon transition to the start of the FSM represents the &lsquo;one&rsquo; case, in which we walk as normal through the FSM.</p><p>The epsilon transition to the end of the FSM represents the &lsquo;zero&rsquo; case, in which we skip the FSM entirely.</p><p>For example, the regex <code>dogs?</code> would look like so;</p><div class=mermaid>graph LR
0((0)) --"d"--> 1((1))
1((1)) --"o"--> 2((2))
2((2)) --"g"--> 3((3))
3((3)) -."ε".-> 4((4))
4((4)) --"s"--> 5((5))
3((3)) -."ε".-> 5((5))</div><p>And <code>(dog)?s</code> would be;</p><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
1((1)) --"d"--> 2((2))
2((2)) --"o"--> 3((3))
3((3)) --"g"--> 4((4))
0((0)) -."ε".-> 4((4))
4((4)) --"s"--> 5((5))</div><h3 id=one-or-more-1>One Or More</h3><p>The One or More modifier will involve an optional <strong>loop</strong>. The <strong>loop</strong> will be used to represent the &lsquo;or More&rsquo; case, and will involve looping back from the end of the sub expression back to the beginning. This can happen as many times as necessary, because the sub expression can be matches any number of times.</p><p><img src=/img/Pasted-image-20221009124845.png alt=Pasted-image-20221009124845.png></p><p>It should be clear that this looks very similar to the Zero Or One case.</p><p>The &lsquo;One&rsquo; case is still the same, so we still need our epsilon transition pointing to the start of the FSM sub expression so that we can walk through the FSM as usual.</p><p>The <strong>loop</strong> for the &lsquo;Or More&rsquo; case is implemented with an epsilon transition pointing from the end of the FSM back to the start<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. This means that we can walk through the FSM sub expression as many times as we want without it failing.</p><p>To use the same examples as before, the regex <code>dogs+</code> would look like so;</p><div class=mermaid>graph LR
0((0)) --"d"--> 1((1))
1((1)) --"o"--> 2((2))
2((2)) --"g"--> 3((3))
3((3)) -."ε".-> 4((4))
4((4)) --"s"--> 5((5))
5((5)) -."ε".-> 3((3))</div><p>And <code>(dog)+s</code> would be;</p><div class=mermaid>graph LR
0((0)) -."ε".-> 1((1))
1((1)) --"d"--> 2((2))
2((2)) --"o"--> 3((3))
3((3)) --"g"--> 4((4))
4((4)) -."ε".-> 0((0))
4((4)) --"s"--> 5((5))</div><p>It might be worth stepping through these examples in your head. Although the difference in the FSM graphs is visually subtle, the effect is significant.</p><h3 id=zero-or-more-1>Zero or More</h3><p>The &lsquo;Zero or More&rsquo; modifier can actually be composed of the &lsquo;One or More&rsquo; and &lsquo;Zero or One&rsquo; modifiers.</p><p>We need both the <strong>skip</strong> for the &lsquo;Zero&rsquo; case, and the <strong>loop</strong> from the &lsquo;or More&rsquo; case.</p><p><img src=/img/Pasted-image-20221009130010.png alt=Pasted-image-20221009130010.png></p><p>Again, the regex <code>dogs*</code> would look like so;</p><div class=mermaid>graph LR
0((0)) --"d"--> 1((1))
1((1)) --"o"--> 2((2))
2((2)) --"g"--> 3((3))
3((3)) -."ε".-> 5((5))
3((3)) -."ε".-> 4((4))
4((4)) --"s"--> 5((5))
5((5)) -."ε".-> 3((3))</div><p>And <code>(dog)*s</code> would be;</p><div class=mermaid>graph LR
0((0)) -."ε".-> 4((4))
0((0)) -."ε".-> 1((1))
1((1)) --"d"--> 2((2))
2((2)) --"o"--> 3((3))
3((3)) --"g"--> 4((4))
4((4)) -."ε".-> 0((0))
4((4)) --"s"--> 5((5))</div><p>Composing these FSMs with epsilons is a lot easier than without them.</p><h2 id=why-epsilons>Why Epsilons?</h2><p>As a quick aside, it&rsquo;s worth noting here that it might seem that the epsilon transitions make things more complicated rather than more simple. For example, the regex <code>(dog)*s</code> can be constructed without epsilons. Actually, all epsilon FSMs can be constructed as non-epsilon FSMs. Let&rsquo;s take a look at what such an FSM might look like.</p><div class=mermaid>graph LR
1((1)) --"s"--> 5((5))
1((1)) --"d"--> 2((2))
2((2)) --"o"--> 3((3))
3((3)) --"g"--> 4((4))
4((4)) --"d"--> 2((2))
4((4)) --"s"--> 5((5))</div><p>This is still fairly simple, but we need to know a few things about the FSM sub expression in order to construct it, such as the transitions to and from the start and end states. The nice thing about epsilon transitions is that you can ignore the inner details of the sub expressions.</p><h2 id=implementing-modifiers>Implementing Modifiers</h2><p>Now we know the theory, let&rsquo;s start adding modifiers to our system.</p><h3 id=parser>Parser</h3><p>Let&rsquo;s start with our modifier data structures.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> ZeroOrOneModifier <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   Child Node  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> OneOrMoreModifier <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   Child Node  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> ZeroOrMoreModifier <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   Child Node  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And we&rsquo;ll add a simple <code>string()</code> method to them for debugging purposes.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (zo ZeroOrOneModifier) <span style=color:#0086b3>string</span>(indentation <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>compositeToString</span>(<span style=color:#d14>&#34;ZeroOrOne&#34;</span>, []Node{zo.Child}, indentation<span style=color:#000;font-weight:700>+</span><span style=color:#099>1</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (om OneOrMoreModifier) <span style=color:#0086b3>string</span>(indentation <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>compositeToString</span>(<span style=color:#d14>&#34;OneOrMore&#34;</span>, []Node{om.Child}, indentation<span style=color:#000;font-weight:700>+</span><span style=color:#099>1</span>)  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (zm ZeroOrMoreModifier) <span style=color:#0086b3>string</span>(indentation <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>compositeToString</span>(<span style=color:#d14>&#34;ZeroOrMore&#34;</span>, []Node{zm.Child}, indentation<span style=color:#000;font-weight:700>+</span><span style=color:#099>1</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As well as some a stand in <code>compile()</code> method so that the compiler doesn&rsquo;t complain.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (zo ZeroOrOneModifier) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;implement me&#34;</span>)
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (om OneOrMoreModifier) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;implement me&#34;</span>) 
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (zm ZeroOrMoreModifier) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;implement me&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now that we have our data structures, let&rsquo;s set up some simple tests for the parser.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser_test
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestParser(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span><span style=color:#000;background-color:#dfd>+               {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       name:  &#34;zero or one modifier on a character&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       input: &#34;a?&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               ZeroOrOneModifier{Child: CharacterLiteral{Character: &#39;a&#39;}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       name:  &#34;zero or one modifier on a group&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       input: &#34;(ab)?&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               ZeroOrOneModifier{Child: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;a&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;b&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               }}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       name:  &#34;one or more modifier on a character&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       input: &#34;a+&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               OneOrMoreModifier{Child: CharacterLiteral{Character: &#39;a&#39;}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       name:  &#34;one or more modifier on a group&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       input: &#34;(ab)+&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               OneOrMoreModifier{Child: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;a&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;b&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               }}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }, {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       name:  &#34;zero or more modifier on a character&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       input: &#34;a*&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               ZeroOrMoreModifier{Child: CharacterLiteral{Character: &#39;a&#39;}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       name:  &#34;zero or more modifier on a group&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       input: &#34;(ab)*&#34;,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       expectedResult: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               ZeroOrMoreModifier{Child: &amp;Group{ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;a&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                                       CharacterLiteral{Character: &#39;b&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               }}},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               },
</span></span></span></code></pre></div><p>As we can see from our tests, the modifier structs act as wrappers around a single <code>Child</code> inner <code>Node</code>.</p><p>Implementing this in our parser is fairly straight forward. We simply need to use a wrapper function, which will wrap the node if there is a modifier character present.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func (p *Parser) Parse(tokens []token) Node {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>        for i, t := range p.tokens {
</span></span><span style=display:flex><span>                switch t.symbol {
</span></span><span style=display:flex><span>                case Character:
</span></span><span style=display:flex><span>                        node := p.pop()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       node.Append(CharacterLiteral{Character: t.letter})
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       node.Append(p.wrapWithModifier(i, CharacterLiteral{Character: t.letter}))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                        p.push(node)
</span></span><span style=display:flex><span>                case AnyCharacter:
</span></span><span style=display:flex><span>                        node := p.pop()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       node.Append(WildcardLiteral{})
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       node.Append(p.wrapWithModifier(i, WildcardLiteral{}))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                        p.push(node)
</span></span><span style=display:flex><span><span style=color:#aaa>@@				[...]
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                case RParen:
</span></span><span style=display:flex><span>                        inner := p.pop()
</span></span><span style=display:flex><span>                        outer := p.pop()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       outer.Append(inner)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       outer.Append(p.wrapWithModifier(i, inner))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                        p.push(outer)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>The wrapper function is <code>p.wrapWithModifier()</code>. let&rsquo;s take a look at it&rsquo;s implementation.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// parser.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Parser) <span style=color:#900;font-weight:700>peekAhead</span>(i <span style=color:#458;font-weight:700>int</span>) (<span style=color:#458;font-weight:700>bool</span>, token) {  
</span></span><span style=display:flex><span>   nextIndex <span style=color:#000;font-weight:700>:=</span> i <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> nextIndex <span style=color:#000;font-weight:700>&gt;=</span> <span style=color:#0086b3>len</span>(p.tokens) {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>, token{}  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>true</span>, p.tokens[nextIndex]  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p <span style=color:#000;font-weight:700>*</span>Parser) <span style=color:#900;font-weight:700>wrapWithModifier</span>(i <span style=color:#458;font-weight:700>int</span>, child Node) Node {  
</span></span><span style=display:flex><span>   ok, nextToken <span style=color:#000;font-weight:700>:=</span> p.<span style=color:#900;font-weight:700>peekAhead</span>(i)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> ok {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>switch</span> nextToken.symbol {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>case</span> ZeroOrOne:  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>return</span> ZeroOrOneModifier{Child: child}  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>case</span> OneOrMore:  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>return</span> OneOrMoreModifier{Child: child}  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>case</span> ZeroOrMore:  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>return</span> ZeroOrMoreModifier{Child: child}  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> child  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We use <code>peekAhead()</code> to check if there&rsquo;s a modifier token next, and if there is, we wrap the <code>Node</code> in the correct modifier. Otherwise, we return the <code>Node</code> as is.</p><p>Now the parser tests are passing, let&rsquo;s move onto the compiler.</p><h3 id=compiler>Compiler</h3><p>Let&rsquo;s start with some tests;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func TestFSMAgainstGoRegexPkg(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                {&#34;word followed by group&#34;, &#34;1(|)&#34;, &#34;0&#34;},
</span></span><span style=display:flex><span>                {&#34;empty group concatenation&#34;, &#34;(()0)0&#34;, &#34;0&#34;},
</span></span><span style=display:flex><span>                {&#34;group followed by word&#34;, &#34;(|)1&#34;, &#34;0&#34;},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               // zero or one
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple zero or one with 0 &#39;?&#39; match&#34;, &#34;ab?c&#34;, &#34;ac&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple zero or one with one &#39;?&#39; matches&#34;, &#34;ab?c&#34;, &#34;abc&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple zero or one too many &#39;?&#39; matches&#34;, &#34;ab?c&#34;, &#34;abbc&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               // one or more
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple one or more with 0 &#39;+&#39; matches&#34;, &#34;ab+c&#34;, &#34;ac&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple one or more with one &#39;+&#39; matches&#34;, &#34;ab+c&#34;, &#34;abc&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple one or more with many &#39;+&#39; matches&#34;, &#34;ab+c&#34;, &#34;abbbbc&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               // zero or more
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple zero or more with 0 &#39;*&#39; matches&#34;, &#34;ab*c&#34;, &#34;ac&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple zero or more with one &#39;*&#39; matches&#34;, &#34;ab*c&#34;, &#34;abc&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;simple zero or more with many &#39;*&#39; matches&#34;, &#34;ab*c&#34;, &#34;abbbbc&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span></code></pre></div><p>And now we simply need to implement the <code>compile()</code> methods. Let&rsquo;s start with <code>ZeroOrOneModifier</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (zo ZeroOrOneModifier) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   startState <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>   endState <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   head, tail = zo.Child.<span style=color:#900;font-weight:700>compile</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// &#39;one&#39; case, go through expression as normal  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   startState.<span style=color:#900;font-weight:700>addEpsilon</span>(head)  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// &#39;zero&#39; case, skip to end of expression  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   startState.<span style=color:#900;font-weight:700>addEpsilon</span>(tail)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tail.<span style=color:#900;font-weight:700>addEpsilon</span>(endState)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> startState, endState  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Following our designs above, the <code>ZeroOrOneModifier</code> will create a new <code>State</code> with the name <code>startState</code>, and add an epsilon transition from <code>startState</code> to the first &lsquo;head&rsquo; <code>State</code> of the compiled <code>Child</code> inner <code>Node</code>. This is for the &lsquo;one&rsquo; case.</p><p>We also need to add an epsilon transition from <code>StartState</code> to the last &rsquo;tail&rsquo; <code>State</code> of the compiled <code>Child</code> inner <code>Node</code>, to represent the <code>zero</code> case where we simply &lsquo;skip&rsquo; to the end.</p><p>You&rsquo;ll notice that we also add an extra <code>State</code> called <code>endState</code>, which we link to the &rsquo;tail&rsquo; state of the compiled <code>Child</code> inner <code>Node</code>. This is not strictly necessary here, but it will ensure that our trick of saying that any <code>State</code> without outgoing transitions is a success <code>State</code> will continue to work, even if we add epsilon transitions to the last &rsquo;tail&rsquo; <code>State</code>.</p><p>Let&rsquo;s do the same for <code>OneOrMoreModifier</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (om OneOrMoreModifier) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   startState <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>   endState <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   head, tail = om.Child.<span style=color:#900;font-weight:700>compile</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// &#39;one&#39; case, go through expression as normal  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   startState.<span style=color:#900;font-weight:700>addEpsilon</span>(head)  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// &#39;more&#39; case, loop back through the expression  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   tail.<span style=color:#900;font-weight:700>addEpsilon</span>(startState)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tail.<span style=color:#900;font-weight:700>addEpsilon</span>(endState)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> startState, endState  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we don&rsquo;t need the &lsquo;zero&rsquo; case, but we need a &lsquo;more&rsquo; case in which we loop back from the last &rsquo;tail&rsquo; <code>State</code> back to the <code>startState</code>.</p><p>And now for the <code>ZeroOrMoreModifier</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// ast.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (zm ZeroOrMoreModifier) <span style=color:#900;font-weight:700>compile</span>() (head <span style=color:#000;font-weight:700>*</span>State, tail <span style=color:#000;font-weight:700>*</span>State) {  
</span></span><span style=display:flex><span>   startState <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>   endState <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   head, tail = zm.Child.<span style=color:#900;font-weight:700>compile</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// &#39;one&#39; case, go through expression as normal  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   startState.<span style=color:#900;font-weight:700>addEpsilon</span>(head)  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// &#39;more&#39; case, loop back through the expression  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   tail.<span style=color:#900;font-weight:700>addEpsilon</span>(startState)  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// &#39;zero&#39; case, skip to end of expression  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   startState.<span style=color:#900;font-weight:700>addEpsilon</span>(tail)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tail.<span style=color:#900;font-weight:700>addEpsilon</span>(endState)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> startState, endState
</span></span></code></pre></div><p>Here we need the &lsquo;one&rsquo;, &lsquo;more&rsquo; and &lsquo;zero&rsquo; cases.</p><p>With those changes, our tests should be passing! Let&rsquo;s try out a few examples with our command line.</p><h2 id=a-few-examples>A few examples</h2><p>Let&rsquo;s first try with the regular expression <code>ca(rro)?t</code> using the Zero or One modifier.</p><p><img src=/img/carrot-carrot.gif alt=carrot-carrot.gif></p><p>We can see in this example that when matching the <code>(rro)</code> sub expression, the matcher travels along the bottom row of <code>States</code>.</p><p><img src=/img/carrot-cat.gif alt=carrot-cat.gif></p><p>When not matching the sub expression, the matcher uses the epsilons to go straight past the sub expression.</p><p>Let&rsquo;s try something similar with the &lsquo;One or More&rsquo; modifier.</p><p><img src=/img/i-love-cats.gif alt=i-love-cats.gif></p><p>In this example, the regex <code>I( love)+ cats</code> is a good demonstration of the &lsquo;More&rsquo; case looping over every match of the <code>( love)</code> sub expression.</p><p>And for one more example, let&rsquo;s combine the wildcard <code>'.'</code> symbol with the Zero or More <code>*</code> symbol to create a generic matcher for any substring.</p><p><img src=/img/its-a-_-cat.gif alt=its-a-_-cat.gif></p><p>Now that we can combine and compose modifiers and branches, we can create some really sophisticated regular expression matchers. Let&rsquo;s look at an example where we combine all of the components we&rsquo;ve created so far.</p><p><img src=/img/complex.gif alt=complex.gif></p><p>There are a lot of moving parts here, but our composable design is keeping things in check.</p><p>Let&rsquo;s make sure that everything is working as expected by running our fuzzer. First, remove <code>*+?</code> from our special character filter.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func FuzzFSM(f *testing.F) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>        f.Fuzz(func(t *testing.T, regex, input string) {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               if strings.ContainsAny(regex, &#34;[]{}$^*+?\\&#34;) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+               if strings.ContainsAny(regex, &#34;[]{}$^\\&#34;) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       t.Skip()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }
</span></span></span></code></pre></div><p>Then, we&rsquo;ll also need to check for regular expressions where <code>?</code> is used on its own, as this is used for group constructions which we&rsquo;re not implementing in this project.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func FuzzFSM(f *testing.F) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                if strings.ContainsAny(regex, &#34;[]{}$^\\&#34;) {
</span></span><span style=display:flex><span>                        t.Skip()
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               if strings.Contains(regex, &#34;(?&#34;) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       // &#39;?&#39; on its own is used for special group constructs, which we&#39;re not implementing.
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                        t.Skip()
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><p>The fuzzer should now be able to fun without finding any errors!</p><h2 id=whats-next>What&rsquo;s next?</h2><p>There are many more features of modern regex engines which we could implement. For example, we could allow regular expressions with <code>{3}</code> which would match exactly 3 sub expressions. Or we could allow character ranges such as <code>[a-zA-Z]</code>. We could match on expressions which start or end with an expression using <code>^</code> and <code>$</code>.</p><p>We could also extend our matcher by returning the substring indices of the match, or by accounting for match groups.</p><p>There&rsquo;s also a myriad of performance improvements we could make - our implementation is currently many, many orders of magnitude slower than the Golang implementation&mldr;</p><p>However, what I&rsquo;m more interested in is converting our epsilon-based NFA to a DFA, in which every <code>State</code> has only one valid <code>Transition</code> per input.</p><p>After that, I&rsquo;ll probably call it a day with this project (unless something else perks my curiosity - I&rsquo;m open to suggestions!).</p><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v9>here</a></p></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Note that we can transition to the new state, or to the starting state of the FSM sub expression here, as the epsilon transition between them mean that the effect is the same.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p>Previous: <a href=/series/making-regex-from-scratch-in-go/09-groups/>09 Groups</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>