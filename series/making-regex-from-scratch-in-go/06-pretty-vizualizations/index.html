<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>06 Pretty Vizualizations - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="06 Pretty Vizualizations"><meta property="og:description" content="Now that we have a few features working, this is a good time to take a step back and build some things to help us see what we&rsquo;re working with. The tools we&rsquo;re going to build now will help with debugging as our features become more complex, and will give us a clearer picture of the logic of the systems we&rsquo;re working with.
As a side note, I also think it&rsquo;s worth mentioning that an important part of building a (kinda) sophisticated system is maintaining the developer infrastructure around it."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/"><meta property="article:section" content="series"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/01-intro/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/02-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/03-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/05-wildcards/"><meta name=twitter:card content="summary"><meta name=twitter:title content="06 Pretty Vizualizations"><meta name=twitter:description content="Now that we have a few features working, this is a good time to take a step back and build some things to help us see what we&rsquo;re working with. The tools we&rsquo;re going to build now will help with debugging as our features become more complex, and will give us a clearer picture of the logic of the systems we&rsquo;re working with.
As a side note, I also think it&rsquo;s worth mentioning that an important part of building a (kinda) sophisticated system is maintaining the developer infrastructure around it."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/bootstrap.css><link src=https://leweym.github.io/js/bootstrap.bundle.js><script src=https://leweym.github.io/js/main.js></script>
<script type=application/javascript>function resizeIFrameToFitContent(e){e.width=e.contentWindow.document.body.scrollWidth,e.height=e.contentWindow.document.body.scrollHeight}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6FPTHJ5QN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6FPTHJ5QN")</script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/series/making-regex-from-scratch-in-go/01-intro/>01 Intro</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/02-getting-into-some-code/>02 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/03-starting-the-compiler/>03 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/>04 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/05-wildcards/>05 Wildcards</a> <span class=meta></span></div><div class=post><span>06 Pretty Vizualizations</span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/07-branches/>07 Branches</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/08-epsilons/>08 Epsilons</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/09-groups/>09 Groups</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/10-modifiers/>10 Modifiers</a> <span class=meta></span></div></div></div><br><div class=post-header><h1 class=title>06 Pretty Vizualizations</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#visualizing-graphs>Visualizing Graphs</a></li><li><a href=#mermaidjs-for-graphs>Mermaid.js for graphs</a></li><li><a href=#traversal>Traversal</a></li><li><a href=#orderedset>OrderedSet</a></li><li><a href=#writing-the-node-traversal-algorithm>Writing the node traversal algorithm</a></li><li><a href=#a-quick-command-line-tool>A quick command line tool</a></li><li><a href=#visualizing-the-runner>Visualizing the Runner</a></li></ul></nav></aside><div class=markdown><p>Now that we have a few features working, this is a good time to take a step back and build some things to help us see what we&rsquo;re working with. The tools we&rsquo;re going to build now will help with debugging as our features become more complex, and will give us a clearer picture of the logic of the systems we&rsquo;re working with.</p><p>As a side note, I also think it&rsquo;s worth mentioning that an important part of building a (kinda) sophisticated system is maintaining the developer infrastructure around it. That can be anything from tests, build tools, debugging tools - anything that helps you get your head around the system and manage that complexity.</p><p>So, let&rsquo;s build something to help us <em>see</em>.</p><h2 id=visualizing-graphs>Visualizing Graphs</h2><p>The issue we have is that it&rsquo;s not very easy to visualize a set of connected nodes (a graph) using variables and text. We <em>could</em> do it, and trace the pointer hashes from one object to the next, but it&rsquo;s not going to be very fun. As our system scales in complexity, this method will get more and more tedious.</p><p>As the old adage goes, a picture tells a thousand words&mldr;</p><p>We&rsquo;re going to produce something like this:</p><div class=mermaid>graph LR
0((0)) --a--> 1((1))
1((1)) --b--> 2((2))
2((2)) --c--> 3((3))
style 3 stroke:green,stroke-width:4px;</div><p>This visual representation of our FSM will give us a quick insight into whether we&rsquo;ve compiled the regular expression correctly, and let us run through the steps ourselves to check when things go wrong.</p><p>This was created using <code>mermaid.js</code>.</p><h2 id=mermaidjs-for-graphs>Mermaid.js for graphs</h2><p><code>mermaid.js</code> is a fantastic tool which allows us to write graphs in standard markdown which can be then rendered in the browser. The markdown for the above graph is the following;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>graph LR
</span></span><span style=display:flex><span>	0((0)) --a--&gt; 1((1))
</span></span><span style=display:flex><span>	1((1)) --b--&gt; 2((2))
</span></span><span style=display:flex><span>	2((2)) --c--&gt; 3((3))
</span></span><span style=display:flex><span>	style 3 stroke:green,stroke-width:4px;
</span></span></code></pre></div><div class="notices info"><p><code>mermaid</code> is much more powerful than this and has all sorts of wild and wonderful features. Check out <a href=https://mermaid-js.github.io/mermaid>the docs</a> and see.</p></div><p>This is simple enough, we just need to parse our <code>States</code> and <code>Transitions</code> into the numbers and arrows in the markdown above.</p><p>As always, let&rsquo;s start with some tests to help define our objective.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// draw_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>abcBuilder</span>() <span style=color:#000;font-weight:700>*</span>State {  
</span></span><span style=display:flex><span>   state1, state2, state3, state4 <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}, <span style=color:#000;font-weight:700>&amp;</span>State{}, <span style=color:#000;font-weight:700>&amp;</span>State{}, <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   state1.<span style=color:#900;font-weight:700>addTransition</span>(state2, Predicate{allowedChars: <span style=color:#d14>&#34;a&#34;</span>}, <span style=color:#d14>&#34;a&#34;</span>)  
</span></span><span style=display:flex><span>   state2.<span style=color:#900;font-weight:700>addTransition</span>(state3, Predicate{allowedChars: <span style=color:#d14>&#34;b&#34;</span>}, <span style=color:#d14>&#34;b&#34;</span>)  
</span></span><span style=display:flex><span>   state3.<span style=color:#900;font-weight:700>addTransition</span>(state4, Predicate{allowedChars: <span style=color:#d14>&#34;c&#34;</span>}, <span style=color:#d14>&#34;c&#34;</span>)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> state1  
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Test_DrawFSM</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>      name, expected <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>      fsmBuilder     <span style=color:#000;font-weight:700>func</span>() <span style=color:#000;font-weight:700>*</span>State  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tests <span style=color:#000;font-weight:700>:=</span> []test{  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         name:       <span style=color:#d14>&#34;simple example&#34;</span>,  
</span></span><span style=display:flex><span>         fsmBuilder: abcBuilder,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34;b&#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;c&#34;--&gt; 3((3))
</span></span></span><span style=display:flex><span><span style=color:#d14>style 3 stroke:green,stroke-width:4px;`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, tt <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tests {  
</span></span><span style=display:flex><span>      t.<span style=color:#900;font-weight:700>Run</span>(tt.name, <span style=color:#000;font-weight:700>func</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>         drawing <span style=color:#000;font-weight:700>:=</span> tt.<span style=color:#900;font-weight:700>fsmBuilder</span>().<span style=color:#900;font-weight:700>Draw</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>if</span> drawing <span style=color:#000;font-weight:700>!=</span> tt.expected {  
</span></span><span style=display:flex><span>            t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;Expected drawing to be \n\&#34;%s\&#34;, got\n\&#34;%s\&#34;&#34;</span>, tt.expected, drawing)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      })  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This test is pretty straight forward, let&rsquo;s just zoom in on a couple of things.</p><p>We&rsquo;re expecting to build a simple <code>mermaid</code> graph with numbered nodes and arrow transitions labeled with letters, such as <code>0((0)) --"a"--> 1((1))</code>. We also want our success node (in this case it&rsquo;s node 3) to look different, so we&rsquo;re giving it a thicker green outline with <code>style 3 stroke:green,stroke-width:4px</code>.</p><p>The first thing to note here is that we&rsquo;re building our FSMs by hand here in the helper function <code>abcBuilder()</code>. This is because we don&rsquo;t want changes in our compiler or parser to break these tests - they should only be concerned with how FSMs are drawn.</p><p>The next thing to note is the new <code>.Draw()</code> method on the <code>State</code> struct. This is what we need to implement to get these tests to pass. Once we have a <code>State</code> constructed, we simply call <code>.Draw()</code> and check that the <code>mermaid</code> graph is as we expect.</p><p>Now that we have some red tests, we can start implementing the <code>Draw()</code> method.</p><h2 id=traversal>Traversal</h2><p>We need a line for every <code>Transition</code> in our FSM. Generically speaking, this means we need to look at every &lsquo;vertex&rsquo; in our &lsquo;directed graph&rsquo; (digraph). So, what we have here is a <strong>graph traversal problem</strong>.</p><p>There are two generic ways to traverse a graph; Breadth-First Search (BFS) and Depth-First Search (DFS). How we visit every vertex will determine the order of the lines in our <code>mermaid</code> markdown. It doesn&rsquo;t make a huge difference, but DFS should lead to longer chains of connected nodes being drawn first. Another advantage of DFS is that our traversal algorithm can be defined recursively.</p><p>Our algorithm for collecting all the <code>Transitions</code> of the FSM should look something like this;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// from the root node
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#099>1.</span> If the current node has already been visited, stop.
</span></span><span style=display:flex><span><span style=color:#099>2.</span> Add the transitions from this node to a set of transitions.
</span></span><span style=display:flex><span><span style=color:#099>3.</span> Mark the current node as visited.
</span></span><span style=display:flex><span><span style=color:#099>4.</span> Recur on the destination node of every outgoing transition.
</span></span></code></pre></div><p>In this algorithm, we have a common need - we need to maintain a set of <code>Transitions</code> and <code>States</code>, as well as maintain their insertion order. The insertion order will be necessary for printing the <code>Transitions</code> in the correct order, as well as numbering the <code>State</code> nodes correctly.</p><p>I won&rsquo;t labor the point here, as it&rsquo;s tricky to visualize what&rsquo;s going on and distracts from what we&rsquo;re trying to do here. If this is mysterious to you, try walking step by step through the call stack and see where you end up.</p><p>Let&rsquo;s build a generic <code>OrderedSet</code> data structure to manage this for us.</p><h2 id=orderedset>OrderedSet</h2><p>We can use the new Generics features of Go 1.18 to write this generically and use the same structure for both &lsquo;visited&rsquo; <code>*States</code> and <code>Transitions</code>.</p><div class="notices info"><p>Notice that we want a set of <code>State</code> pointers, and a set of concrete <code>Transitions</code>. This is because <code>Transitions</code> contain all of their identifying information, such as their <code>to</code> and <code>from</code> states, and the predicate, as fields in the struct. <code>States</code>, on the other hand, require a reference to be identified.</p></div><p>Before we get into the generic implementation, we need to do some refactoring of <code>Transition</code> in order to make it <code>comparable</code> in Go (not a slice, map, or function type).</p><h3 id=modifying-the-transition-object>Modifying the Transition object</h3><p>In go, an object is <code>comparable</code> when all of its fields are also <code>comparable</code>, and currently the <code>predicate</code> field of a <code>Transition</code> is a function type. Let&rsquo;s change that now.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // transition.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>- type Predicate func(input rune) bool
</span></span></span></code></pre></div><p>Instead, let&rsquo;s use a struct which can have either a string of allowed or disallowed chars<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// transition.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Predicate <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   allowedChars    <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   disallowedChars <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (p Predicate) <span style=color:#900;font-weight:700>test</span>(input <span style=color:#458;font-weight:700>rune</span>) <span style=color:#458;font-weight:700>bool</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> p.allowedChars <span style=color:#000;font-weight:700>!=</span> <span style=color:#d14>&#34;&#34;</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> p.disallowedChars <span style=color:#000;font-weight:700>!=</span> <span style=color:#d14>&#34;&#34;</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;must be mutually exclusive&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(p.allowedChars) &gt; <span style=color:#099>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> strings.<span style=color:#900;font-weight:700>ContainsRune</span>(p.allowedChars, input)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(p.disallowedChars) &gt; <span style=color:#099>0</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> !strings.<span style=color:#900;font-weight:700>ContainsRune</span>(p.disallowedChars, input)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#000;font-weight:700>false</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Also, let&rsquo;s add a handy symbol for drawing our transitions.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // transition.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>type Transition struct {  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   debugSymbol string  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   // to: a pointer to the next state   
</span></span><span style=display:flex><span>   to        *State  
</span></span><span style=display:flex><span>   from      *State  
</span></span><span style=display:flex><span>   predicate Predicate  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // state.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-func (s *State) addTransition(destination *State, predicate Predicate) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+func (s *State) addTransition(destination *State, predicate Predicate, debugSymbol string) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        t := Transition{
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               to:        destination,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               predicate: predicate,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+               debugSymbol: debugSymbol,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               to:          destination,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               from:        s,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               predicate:   predicate,
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span><span style=display:flex><span>        s.transitions = append(s.transitions, t)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func (s *State) merge(s2 *State) {
</span></span><span style=display:flex><span>        for _, t := range s2.transitions {
</span></span><span style=display:flex><span>                // 1. copy s2 transitions to s
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               s.addTransition(t.to, t.predicate)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+               s.addTransition(t.to, t.predicate, t.debugSymbol)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        // 2. remove s2
</span></span><span style=display:flex><span>		s2.delete()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (l CharacterLiteral) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startingState := State{}
</span></span><span style=display:flex><span>        endState := State{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       startingState.addTransition(&amp;endState, func(input rune) bool { return input == l.Character })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       startingState.addTransition(&amp;endState, Predicate{allowedChars: string(l.Character)}, string(l.Character))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return &amp;startingState, &amp;endState
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>func (w WildcardLiteral) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startingState := State{}
</span></span><span style=display:flex><span>        endState := State{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       startingState.addTransition(&amp;endState, func(input rune) bool { return input != &#39;\n&#39; })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       startingState.addTransition(&amp;endState, Predicate{disallowedChars: &#34;\n&#34;}, &#34;.&#34;)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return &amp;startingState, &amp;endState
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>And let&rsquo;s make a few changes so that our problem compiles.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // state.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> func (s *State) firstMatchingTransition(input rune) *State {
</span></span><span style=display:flex><span>        for _, t := range s.transitions {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               if t.predicate.test(input) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span><span style=color:#000;background-color:#fdd>-               if t.predicate(input) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span>                        return t.to
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	return nil
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func (l CharacterLiteral) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startingState := State{}
</span></span><span style=display:flex><span>        endState := State{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       startingState.addTransition(&amp;endState, func(input rune) bool { return input == l.Character }, string(l.Character))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       startingState.addTransition(&amp;endState, Predicate{allowedChars: string(l.Character)}, string(l.Character))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return &amp;startingState, &amp;endState
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func (w WildcardLiteral) compile() (head *State, tail *State) {  
</span></span><span style=display:flex><span>   startingState := State{}  
</span></span><span style=display:flex><span>   endState := State{}  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-  startingState.addTransition(&amp;endState, func(input rune) bool { return input != &#34;\n&#34; }, string(l.Character))  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+  startingState.addTransition(&amp;endState, Predicate{disallowedChars: &#34;\n&#34;}, &#34;.&#34;)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   return &amp;startingState, &amp;endState  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now, let&rsquo;s build our generic <code>OrderedSet</code> struct. Our struct will need the following interface, where <code>T</code> is the generic type:</p><ul><li><code>add(ts ...T)</code></li><li><code>has(t T) bool</code></li><li><code>list() []T</code></li><li><code>getIndex(t T) int</code></li></ul><p>Let&rsquo;s write that out.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// orderedset.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// OrderedSet maintains an ordered set of unique items of type &lt;T&gt;type 
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>OrderedSet[T comparable] <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   set       <span style=color:#000;font-weight:700>map</span>[T]<span style=color:#458;font-weight:700>int</span>  
</span></span><span style=display:flex><span>   nextIndex <span style=color:#458;font-weight:700>int</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>add</span>(ts <span style=color:#000;font-weight:700>...</span>T) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> o.set <span style=color:#000;font-weight:700>==</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      o.set = <span style=color:#0086b3>make</span>(<span style=color:#000;font-weight:700>map</span>[T]<span style=color:#458;font-weight:700>int</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> ts {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>if</span> !o.<span style=color:#900;font-weight:700>has</span>(t) {  
</span></span><span style=display:flex><span>         o.set[t] = o.nextIndex  
</span></span><span style=display:flex><span>         o.nextIndex<span style=color:#000;font-weight:700>++</span>  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>has</span>(t T) <span style=color:#458;font-weight:700>bool</span> {  
</span></span><span style=display:flex><span>   _, hasItem <span style=color:#000;font-weight:700>:=</span> o.set[t]  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> hasItem  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>list</span>() []T {  
</span></span><span style=display:flex><span>   size <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>len</span>(o.set)  
</span></span><span style=display:flex><span>   list <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>make</span>([]T, size)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   i <span style=color:#000;font-weight:700>:=</span> <span style=color:#099>0</span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> o.set {  
</span></span><span style=display:flex><span>      list[i] = t  
</span></span><span style=display:flex><span>      i<span style=color:#000;font-weight:700>++</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   sort.<span style=color:#900;font-weight:700>Slice</span>(list, <span style=color:#000;font-weight:700>func</span>(i, j <span style=color:#458;font-weight:700>int</span>) <span style=color:#458;font-weight:700>bool</span> {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span> o.<span style=color:#900;font-weight:700>getIndex</span>(list[i]) &lt; o.<span style=color:#900;font-weight:700>getIndex</span>(list[j])  
</span></span><span style=display:flex><span>   })  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> list  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (o <span style=color:#000;font-weight:700>*</span>OrderedSet[T]) <span style=color:#900;font-weight:700>getIndex</span>(t T) <span style=color:#458;font-weight:700>int</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> o.set[t]  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We&rsquo;ve changed the implementation here slightly by storing the index in the <code>set</code> field. This makes our <code>list</code> method a little more awkward, but it makes it easier to get the index of any item in the set, which will be useful for finding the numbers of our nodes.</p><p>Now we have all the pieces we need for our traversal algorithm.</p><h2 id=writing-the-node-traversal-algorithm>Writing the node traversal algorithm</h2><p>Because of the useful data structures we&rsquo;ve just dreamed up, writing the traversal algorithm maps pretty simply to the pseudocode we described earlier.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// draw.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>visitNodes</span>(  
</span></span><span style=display:flex><span>   node <span style=color:#000;font-weight:700>*</span>State,  
</span></span><span style=display:flex><span>   transitions <span style=color:#000;font-weight:700>*</span>OrderedSet[Transition],  
</span></span><span style=display:flex><span>   visited <span style=color:#000;font-weight:700>*</span>OrderedSet[<span style=color:#000;font-weight:700>*</span>State],  
</span></span><span style=display:flex><span>) {  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 1. If the current node has already been visited, stop.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>if</span> visited.<span style=color:#900;font-weight:700>has</span>(node) {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 2. Add the transitions from this node to a set of transitions.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>for</span> _, transition <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> node.transitions {  
</span></span><span style=display:flex><span>      transitions.<span style=color:#900;font-weight:700>add</span>(transition)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 3. Mark the current node as visited.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   visited.<span style=color:#900;font-weight:700>add</span>(node)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// 4. Recur on the destination node of every outgoing transition.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>for</span> _, transition <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> node.transitions {  
</span></span><span style=display:flex><span>      destinationNode <span style=color:#000;font-weight:700>:=</span> transition.to  
</span></span><span style=display:flex><span>      <span style=color:#900;font-weight:700>visitNodes</span>(destinationNode, transitions, visited)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s important that the <code>transitions</code> and the <code>visited</code> <code>OrderedSets</code> are passed by reference using pointers. They should be the same instance in every recursive call, as we want to collect <code>Transitions</code> and mark <code>Nodes</code> as visited across the whole graph.</p><p>Once we have collected the <code>Transitions</code>, we now just have to draw them as lines in our <code>mermaid</code> markdown.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// draw.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>Draw</span>() <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// initialize sets  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   transitionSet <span style=color:#000;font-weight:700>:=</span> OrderedSet[Transition]{}  
</span></span><span style=display:flex><span>   nodeSet <span style=color:#000;font-weight:700>:=</span> OrderedSet[<span style=color:#000;font-weight:700>*</span>State]{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// collect transitions  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#900;font-weight:700>visitNodes</span>(s, <span style=color:#000;font-weight:700>&amp;</span>transitionSet, <span style=color:#000;font-weight:700>&amp;</span>nodeSet)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   output <span style=color:#000;font-weight:700>:=</span> []<span style=color:#458;font-weight:700>string</span>{  
</span></span><span style=display:flex><span>      <span style=color:#d14>&#34;graph LR&#34;</span>,  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#998;font-style:italic>// draw transitions  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>for</span> _, t <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> transitionSet.<span style=color:#900;font-weight:700>list</span>() {  
</span></span><span style=display:flex><span>      fromId <span style=color:#000;font-weight:700>:=</span> nodeSet.<span style=color:#900;font-weight:700>getIndex</span>(t.from)  
</span></span><span style=display:flex><span>      toId <span style=color:#000;font-weight:700>:=</span> nodeSet.<span style=color:#900;font-weight:700>getIndex</span>(t.to)  
</span></span><span style=display:flex><span>      output = <span style=color:#0086b3>append</span>(output, fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;%d((%d)) --\&#34;%s\&#34;--&gt; %d((%d))&#34;</span>, fromId, fromId, t.debugSymbol, toId, toId))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// draw outline around success nodes  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>	<span style=color:#000;font-weight:700>for</span> _, state <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> nodeSet.<span style=color:#900;font-weight:700>list</span>() {  
</span></span><span style=display:flex><span>	   <span style=color:#000;font-weight:700>if</span> state.<span style=color:#900;font-weight:700>isSuccessState</span>() {  
</span></span><span style=display:flex><span>	      output = <span style=color:#0086b3>append</span>(output, fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;style %d stroke:green,stroke-width:4px;&#34;</span>, nodeSet.<span style=color:#900;font-weight:700>getIndex</span>(state)))  
</span></span><span style=display:flex><span>	   }  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> strings.<span style=color:#900;font-weight:700>Join</span>(output, <span style=color:#d14>&#34;\n&#34;</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Once all the hard work of collecting the <code>Nodes</code> and <code>Transitions</code> is done, it&rsquo;s quite simple to concatenate the strings required to build the <code>mermaid.js</code> code. I won&rsquo;t go into much more detail here, as the code seems to speak for itself.</p><p>With all this in place, let&rsquo;s run our tests. Looks like we&rsquo;re green!</p><p>One more thing, let&rsquo;s add a quick method on the <code>myRegex</code> struct to call the root <code>State.Draw()</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// regex.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>myRegex) <span style=color:#900;font-weight:700>DebugFSM</span>() <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   graph <span style=color:#000;font-weight:700>:=</span> m.fsm.<span style=color:#900;font-weight:700>Draw</span>()  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> graph  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=a-quick-command-line-tool>A quick command line tool</h2><p>Let&rsquo;s add one more thing before we finish with our visualizer. We want to be able to use it, quickly and easily, so let&rsquo;s make a command that we can run which takes a regular expression and shows us what the compiled FSM looks like.</p><p>Let&rsquo;s set up a <code>main</code> function<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// main.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> main
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>main</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>switch</span> os.Args[<span style=color:#099>1</span>] {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#34;v5&#34;</span>:  
</span></span><span style=display:flex><span>      v5.<span style=color:#900;font-weight:700>Main</span>(os.Args[<span style=color:#099>2</span>:])  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>return</span>  
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// v5/main.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>package</span> v5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// Main just used for linking up the main functions
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Main</span>(args []<span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>switch</span> args[<span style=color:#099>0</span>] {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#34;draw&#34;</span>:  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>if</span> <span style=color:#0086b3>len</span>(args) <span style=color:#000;font-weight:700>==</span> <span style=color:#099>2</span> {  
</span></span><span style=display:flex><span>         <span style=color:#900;font-weight:700>RenderFSM</span>(args[<span style=color:#099>1</span>])  
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>default</span>:  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;command not recognized&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that, we can call <code>Draw</code> from our command. Let&rsquo;s test that things are set up correctly.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// draw.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Draw</span>(input <span style=color:#458;font-weight:700>string</span>) {
</span></span><span style=display:flex><span>	fmt.<span style=color:#900;font-weight:700>Println</span>(<span style=color:#d14>&#34;Draw called with &#34;</span> <span style=color:#000;font-weight:700>+</span> input)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can run the program with <code>go run ./.. v5 draw {input}</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>➜  search git:<span style=color:#000;font-weight:700>(</span>master<span style=color:#000;font-weight:700>)</span> ✗ go run ./... v5 draw <span style=color:#d14>&#34;abc&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Draw called with abc
</span></span></code></pre></div><p>Great, let&rsquo;s make <code>Draw()</code> open a browser and display our <code>mermaid</code> code.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// main.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// RenderFSM will render just the finite state machine, and output the result to the browser
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>RenderFSM</span>(input <span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   graph <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewMyRegex</span>(input).<span style=color:#900;font-weight:700>DebugFSM</span>()  
</span></span><span style=display:flex><span>   html <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>buildFsmHtml</span>(graph)  
</span></span><span style=display:flex><span>   <span style=color:#900;font-weight:700>outputToBrowser</span>(html)  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>buildFsmHtml</span>(graph <span style=color:#458;font-weight:700>string</span>) <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>renderWithTemplate</span>(fsmTemplate, graph)  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>renderWithTemplate</span>(tmplt <span style=color:#458;font-weight:700>string</span>, data any) <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   t, err <span style=color:#000;font-weight:700>:=</span> template.<span style=color:#900;font-weight:700>New</span>(<span style=color:#d14>&#34;graph&#34;</span>).<span style=color:#900;font-weight:700>Parse</span>(tmplt)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(err)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   w <span style=color:#000;font-weight:700>:=</span> bytes.Buffer{}  
</span></span><span style=display:flex><span>   err = t.<span style=color:#900;font-weight:700>Execute</span>(<span style=color:#000;font-weight:700>&amp;</span>w, data)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(err)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> w.<span style=color:#900;font-weight:700>String</span>()  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>outputToBrowser</span>(html <span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   reader <span style=color:#000;font-weight:700>:=</span> strings.<span style=color:#900;font-weight:700>NewReader</span>(html)  
</span></span><span style=display:flex><span>   err <span style=color:#000;font-weight:700>:=</span> browser.<span style=color:#900;font-weight:700>OpenReader</span>(reader)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(err)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The template we&rsquo;re using here in the constant <code>fsmTemplate</code> is defined in the following <a href=https://github.com/LeweyM/search/blob/c31ebe6066a6cabd74ef2afadaee20a81a875d2a/src/v5/templates.go#L14-L24>github link</a>. This is some dirty and ugly HTML. It gets the job done, but it&rsquo;s not something I want to focus on here - if you&rsquo;re following along with this guide, I suggest you copy it directly from github.</p><p>Let&rsquo;s try that again. It should now open a browser with a visualisation of your compiled FSM!</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
1((1)) --"b"--> 2((2))
2((2)) --"c"--> 3((3))</div><p>That&rsquo;s better. This tool is going to come in very handy as our program grows in complexity.</p><p>So, we can visualize what a compiled FSM looks like, but what would be great is if we could also see our <em>runner processing each of the characters</em>. This would give us a wonderful insight into the characteristics of our algorithm.</p><p>Let&rsquo;s do that now.</p><h2 id=visualizing-the-runner>Visualizing the Runner</h2><p>What I want is to be able to open up a browser with an animation that shows me;</p><ol><li>The compiled FSM (as we just showed)</li><li>Which character of the input I&rsquo;m currently processing.</li><li>Which is the current active state in the FSM.</li></ol><p>We already implemented (1), so now we need a way of showing (2) where we are in the input string and (3) which state is currently active for each step of the algorithm. To be clear, when I write &lsquo;step&rsquo;, I refer to the processing of a character via the <code>Next(input rune)</code> method in our <code>runner</code>.</p><p>In terms of displaying this information, we can do this by simply rendering every step of the algorithm in the browser, and then use JavaScript to reveal one of the steps and hide the others when the arrow keys are pressed. This will give the impression of stepping backwards and forwards through the algorithm<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>We need a way of drawing the graph each step in the algorithm. In this case, the algorithm in question is the <code>match</code> algorithm, so let&rsquo;s create a <code>DebugMatch()</code> function on our <code>myRegex</code> struct to handle this.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// regex.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>myRegex) <span style=color:#900;font-weight:700>DebugMatch</span>(input <span style=color:#458;font-weight:700>string</span>) []debugStep {
</span></span><span style=display:flex><span>	<span style=color:#998;font-style:italic>// todo: implement me
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>}
</span></span></code></pre></div><p>This returns a slice of <code>debugSteps</code>, which contains everything we need in order to render a single step in the algorithm. Namely, a drawing of the runner in the current moment, and the index of the character we&rsquo;re processing in the current moment.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// regex.go 
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> debugStep <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   runnerDrawing         <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   currentCharacterIndex <span style=color:#458;font-weight:700>int</span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s start with a test;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// draw_test.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>aaaBuilder</span>() <span style=color:#000;font-weight:700>*</span>State {  
</span></span><span style=display:flex><span>   state1, state2, state3, state4 <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>&amp;</span>State{}, <span style=color:#000;font-weight:700>&amp;</span>State{}, <span style=color:#000;font-weight:700>&amp;</span>State{}, <span style=color:#000;font-weight:700>&amp;</span>State{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   state1.<span style=color:#900;font-weight:700>addTransition</span>(state2, Predicate{allowedChars: <span style=color:#d14>&#34;a&#34;</span>}, <span style=color:#d14>&#34;a&#34;</span>)  
</span></span><span style=display:flex><span>   state2.<span style=color:#900;font-weight:700>addTransition</span>(state3, Predicate{allowedChars: <span style=color:#d14>&#34;a&#34;</span>}, <span style=color:#d14>&#34;a&#34;</span>)  
</span></span><span style=display:flex><span>   state3.<span style=color:#900;font-weight:700>addTransition</span>(state4, Predicate{allowedChars: <span style=color:#d14>&#34;a&#34;</span>}, <span style=color:#d14>&#34;a&#34;</span>)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> state1  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>Test_DrawSnapshot</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>type</span> test <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>      name, input, expected <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>      fsmBuilder            <span style=color:#000;font-weight:700>func</span>() <span style=color:#000;font-weight:700>*</span>State  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   tests <span style=color:#000;font-weight:700>:=</span> []test{  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         name:       <span style=color:#d14>&#34;initial snapshot&#34;</span>,  
</span></span><span style=display:flex><span>         fsmBuilder: abcBuilder,  
</span></span><span style=display:flex><span>         input:      <span style=color:#d14>&#34;&#34;</span>,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34;b&#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;c&#34;--&gt; 3((3))  
</span></span></span><span style=display:flex><span><span style=color:#d14>style 3 stroke:green,stroke-width:4px;
</span></span></span><span style=display:flex><span><span style=color:#d14>style 0 fill:#ff5555;`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         name:       <span style=color:#d14>&#34;after a single letter&#34;</span>,  
</span></span><span style=display:flex><span>         fsmBuilder: abcBuilder,  
</span></span><span style=display:flex><span>         input:      <span style=color:#d14>&#34;a&#34;</span>,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34;b&#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;c&#34;--&gt; 3((3)) 
</span></span></span><span style=display:flex><span><span style=color:#d14>style 3 stroke:green,stroke-width:4px;
</span></span></span><span style=display:flex><span><span style=color:#d14>style 1 fill:#ff5555;`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>      {  
</span></span><span style=display:flex><span>         name:       <span style=color:#d14>&#34;last state highlighted&#34;</span>,  
</span></span><span style=display:flex><span>         fsmBuilder: aaaBuilder,  
</span></span><span style=display:flex><span>         input:      <span style=color:#d14>&#34;aaa&#34;</span>,  
</span></span><span style=display:flex><span>         expected: <span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34;a&#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;a&#34;--&gt; 3((3))  
</span></span></span><span style=display:flex><span><span style=color:#d14>style 3 stroke:green,stroke-width:4px;
</span></span></span><span style=display:flex><span><span style=color:#d14>style 3 fill:#00ab41;`</span>,  
</span></span><span style=display:flex><span>      },  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, tt <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tests {  
</span></span><span style=display:flex><span>      t.<span style=color:#900;font-weight:700>Run</span>(tt.name, <span style=color:#000;font-weight:700>func</span>(t <span style=color:#000;font-weight:700>*</span>testing.T) {  
</span></span><span style=display:flex><span>         runner <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewRunner</span>(tt.<span style=color:#900;font-weight:700>fsmBuilder</span>())  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>for</span> _, char <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> tt.input {  
</span></span><span style=display:flex><span>            runner.<span style=color:#900;font-weight:700>Next</span>(char)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         snapshot <span style=color:#000;font-weight:700>:=</span> runner.<span style=color:#900;font-weight:700>drawSnapshot</span>()  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>if</span> !reflect.<span style=color:#900;font-weight:700>DeepEqual</span>(tt.expected, snapshot) {  
</span></span><span style=display:flex><span>            t.<span style=color:#900;font-weight:700>Fatalf</span>(<span style=color:#d14>&#34;Expected drawing to be \n\&#34;%v\&#34;\ngot\n\&#34;%v\&#34;&#34;</span>, tt.expected, snapshot)  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>      })  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This should look familiar to our previous <code>Test_DebugFSM</code> test, with the biggest difference being that we are now returning a &lsquo;snapshot&rsquo; of the runner after having processed some input. This includes the highlighting of the currently active states.</p><p>Zoom in on the first test, which is after having processed the string <code>"a"</code> for the regular expression <code>"abc"</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#d14>`graph LR  
</span></span></span><span style=display:flex><span><span style=color:#d14>0((0)) --&#34;a&#34;--&gt; 1((1))  
</span></span></span><span style=display:flex><span><span style=color:#d14>1((1)) --&#34;b&#34;--&gt; 2((2))  
</span></span></span><span style=display:flex><span><span style=color:#d14>2((2)) --&#34;c&#34;--&gt; 3((3))  
</span></span></span><span style=display:flex><span><span style=color:#d14>style 3 stroke:green,stroke-width:4px;
</span></span></span><span style=display:flex><span><span style=color:#d14>style 0 fill:#ff5555;`</span>
</span></span></code></pre></div><p>One thing that wasn&rsquo;t in the previous test is the last line.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>style 0 fill:#ff5555;
</span></span></code></pre></div><p>This gives a color <code>#ff5555</code> to the node with the label &lsquo;<code>0</code>&rsquo;. Let&rsquo;s see what this looks like with <code>mermaid</code>.</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
1((1)) --"b"--> 2((2))
2((2)) --"c"--> 3((3))
style 3 stroke:green,stroke-width:4px;
style 0 fill:#ff5555;</div><p>The red node means that the current state is <code>State</code> &lsquo;<code>0</code>&rsquo;. Let&rsquo;s change the last line to <code>style 1 fill:#ff5555</code></p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
1((1)) --"b"--> 2((2))
2((2)) --"c"--> 3((3))
style 3 stroke:green,stroke-width:4px;
style 1 fill:#ff5555</div><p>So, by changing which node we style, we can demonstrate the currently active state &lsquo;moving&rsquo; across our FSM.</p><p>Finally, some might notice that the last graph in our test has a different color.</p><div class=mermaid>graph LR
0((0)) --"a"--> 1((1))
1((1)) --"b"--> 2((2))
2((2)) --"c"--> 3((3))
style 3 stroke:green,stroke-width:4px;
style 3 fill:#00ab41;</div><p>The green node means that the runner has landed in an end state, and so the match was successful.</p><p>Now we know what we&rsquo;re trying to build, let&rsquo;s start implementing the <code>runner.drawSnapshot</code> function.</p><h3 id=draw-snapshot>Draw Snapshot</h3><p>Drawing a snapshot of the runner is actually quite simple.</p><p>First, we&rsquo;re going to need to modify the <code>Draw</code> function to return the <code>nodeSet</code> object. This is because we&rsquo;ll need to know the labels of the nodes in order to highlight them.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // draw.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>- func (s *State) Draw() string {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+ func (s *State) Draw() (graph string, nodeSet OrderedSet[*State]) {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   // initialize sets  
</span></span><span style=display:flex><span>   transitionSet := OrderedSet[Transition]{}  
</span></span><span style=display:flex><span>   nodeSet = OrderedSet[*State]{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   // collect transitions  
</span></span><span style=display:flex><span>   visitNodes(s, &amp;transitionSet, &amp;nodeSet)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   output := []string{  
</span></span><span style=display:flex><span>      &#34;graph LR&#34;,  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   // draw transitions  
</span></span><span style=display:flex><span>   for _, t := range transitionSet.list() {  
</span></span><span style=display:flex><span>      fromId := nodeSet.getIndex(t.from)  
</span></span><span style=display:flex><span>      toId := nodeSet.getIndex(t.to)  
</span></span><span style=display:flex><span>      output = append(output, fmt.Sprintf(&#34;%d((%d)) --\&#34;%s\&#34;--&gt; %d((%d))&#34;, fromId, fromId, t.debugSymbol, toId, toId))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// draw outline around success nodes  
</span></span><span style=display:flex><span>	for _, state := range nodeSet.list() {  
</span></span><span style=display:flex><span>	   if state.isSuccessState() {  
</span></span><span style=display:flex><span>	      output = append(output, fmt.Sprintf(&#34;style %d stroke:green,stroke-width:4px;&#34;, nodeSet.getIndex(state)))  
</span></span><span style=display:flex><span>	   }  
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-   return strings.Join(output, &#34;\n&#34;)  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+   return strings.Join(output, &#34;\n&#34;), nodeSet
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>}
</span></span></code></pre></div><p>The compiler should be complaining, so let&rsquo;s quickly fix those issues.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // regex.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (m *myRegex) DebugFSM() string {  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-   graph := m.fsm.Draw()  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+   graph, _ := m.fsm.Draw()  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   return graph  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // draw_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#aaa>@@ func Test_DrawFSM(t *testing.T) {
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>	for _, tt := range tests {  
</span></span><span style=display:flex><span>	   t.Run(tt.name, func(t *testing.T) 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-         drawing := tt.fsmBuilder().Draw()  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+         drawing, _ := tt.fsmBuilder().Draw()  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>	  
</span></span><span style=display:flex><span>	      if drawing != tt.expected {  
</span></span><span style=display:flex><span>	         t.Fatalf(&#34;Expected drawing to be \n\&#34;%s\&#34;, got\n\&#34;%s\&#34;&#34;, tt.expected, drawing)  
</span></span><span style=display:flex><span>	      }  
</span></span><span style=display:flex><span>	   })
</span></span></code></pre></div><p>Now, we need to implement the <code>drawSnapshot</code> function. All this should do is print the <code>mermaid</code> graph of the FSM, then append the code to highlight all active states, using the <code>nodeSet</code> to get the appropriate label.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// draw.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// drawSnapshot will draw a mermaid graph from the FSM, as well as color the current node.
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> (r runner) <span style=color:#900;font-weight:700>drawSnapshot</span>() <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   graph, nodeSet <span style=color:#000;font-weight:700>:=</span> r.head.<span style=color:#900;font-weight:700>Draw</span>()  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>switch</span> r.<span style=color:#900;font-weight:700>GetStatus</span>() {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> Normal:  
</span></span><span style=display:flex><span>      graph <span style=color:#000;font-weight:700>+=</span> fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;\nstyle %d fill:#ff5555;&#34;</span>, nodeSet.<span style=color:#900;font-weight:700>getIndex</span>(r.current))  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>case</span> Success:  
</span></span><span style=display:flex><span>      graph <span style=color:#000;font-weight:700>+=</span> fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;\nstyle %d fill:#00ab41;&#34;</span>, nodeSet.<span style=color:#900;font-weight:700>getIndex</span>(r.current))  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> graph  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With that in place, our tests are passing, but it&rsquo;s not much use unless we can modify our algorithm to print a snapshot during the different steps of the algorithm. In order to do that, we&rsquo;ll need to modify our <code>match</code> function.</p><h3 id=changing-our-match-function>Changing our Match Function</h3><p>In order to do this, we&rsquo;re going to make use of golang&rsquo;s <code>channels</code> to send data as the algorithm is running.</p><p>Go <code>channels</code> are used for concurrent programs, which is not really how we&rsquo;re using them here. However, by using channels we can &rsquo;enqueue&rsquo; data during the processing of a function without the function returning. As long as something is &rsquo;listening&rsquo; on the other side of the channel, the <code>send</code> operation to the channel will not block. If you&rsquo;re not familiar with Go <code>channels</code>, this will likely be a bit mysterious for now, hopefully it will be clearer once we have some working code.</p><p>The upside of all this is that we don&rsquo;t need to modify the original algorithm too much.</p><p>Let&rsquo;s start by modifying the <code>match</code> function. At each step of the search, we&rsquo;ll check if a <code>channel</code> is present. If it is, we&rsquo;ll take a snapshot of the runner and send it to the <code>channel</code>, as well as some additional data.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // regex.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-func match(runner *runner, input []rune) bool {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+func match(runner *runner, input []rune, debugChan chan debugStep, offset int) bool {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        runner.Reset()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       if debugChan != nil {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               debugChan &lt;- debugStep{runnerDrawing: runner.drawSnapshot(), currentCharacterIndex: offset}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       for _, character := range input {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       for i, character := range input {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                runner.Next(character)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               if debugChan != nil {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       debugChan &lt;- debugStep{runnerDrawing: runner.drawSnapshot(), currentCharacterIndex: offset + i + 1}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                status := runner.GetStatus()
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>                if status == Fail {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       return match(runner, input[1:])
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       return match(runner, input[1:], debugChan, offset+1)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>				if status == Success {  
</span></span><span style=display:flex><span>				      return true  
</span></span><span style=display:flex><span>			    }  
</span></span><span style=display:flex><span>		}   
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>		return runner.GetStatus() == Success
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s break this down a bit;</p><p>First, the signature has changed.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#000;background-color:#fdd>-func match(runner *runner, input []rune) bool {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+func match(runner *runner, input []rune, debugChan chan debugStep, offset int) bool {
</span></span></span></code></pre></div><p>We now pass a <code>chan debugStep</code> channel to <code>match</code>. This is the channel to which we will output our graph drawing at each step of the algorithm.</p><p>We also pass an <code>offset</code> integer to the function. This is because of the recursive nature of the algorithm, which means that at each step we are operating on an ever shortening substring of <code>input</code>. For example, it will operate first on the string <code>"abcd"</code>, then <code>"bcd"</code>, then <code>"cd"</code>, then <code>"d"</code>, and then finally on the empty string <code>""</code>. As we need to know which index of the <em>complete</em> <code>input</code> string we&rsquo;re currently at, we need to know how many characters we&rsquo;ve already discarded. Therefore, the <code>offset</code> is incremented in every recursion to account for this.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>                if status == Fail {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       return match(runner, input[1:])
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       return match(runner, input[1:], debugChan, offset+1)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                }
</span></span></code></pre></div><p>The other modifications are simple, we just pass the current state of the <code>runner</code> and the <code>currentCharacterIndex</code> to the channel at each step.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>        runner.Reset()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       if debugChan != nil {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               debugChan &lt;- debugStep{runnerDrawing: runner.drawSnapshot(), currentCharacterIndex: offset}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       for _, character := range input {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       for i, character := range input {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                runner.Next(character)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               if debugChan != nil {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       debugChan &lt;- debugStep{runnerDrawing: runner.drawSnapshot(), currentCharacterIndex: offset + i + 1}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }
</span></span></span></code></pre></div><p>We do it before the loop in order to capture the state of the runner at the very beginning, before it has processed any characters, as well as whenever the algorithm recurs. This leads to some jumps in our animation, but it shows nicely the &lsquo;backtracking&rsquo; characteristics of our algorithm.</p><p>We also capture the runner state after the <code>runner.Next(character)</code> call during the loop in order to take a snapshot of every step after a character has been processed.</p><p>And finally, we always check that <code>debugChan != nil</code> before we pass data to the <code>debugStep</code> channel so that we can ignore all of this when we&rsquo;re not debugging.</p><p>The compiler should be moaning at us to fix what we&rsquo;ve broken, so let&rsquo;s fix that.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // regex.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> func (m *myRegex) MatchString(input string) bool {
</span></span><span style=display:flex><span>        testRunner := NewRunner(m.fsm)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       return match(testRunner, []rune(input))
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       return match(testRunner, []rune(input), nil, 0)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span></code></pre></div><p>That should be enough. We now have some failing tests to fix, so let&rsquo;s implement the <code>DebugMatch()</code> method.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// regex.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (m <span style=color:#000;font-weight:700>*</span>myRegex) <span style=color:#900;font-weight:700>DebugMatch</span>(input <span style=color:#458;font-weight:700>string</span>) []debugStep {  
</span></span><span style=display:flex><span>   testRunner <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewRunner</span>(m.fsm)  
</span></span><span style=display:flex><span>   debugStepChan <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>make</span>(<span style=color:#000;font-weight:700>chan</span> debugStep)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#900;font-weight:700>match</span>(testRunner, []<span style=color:#0086b3>rune</span>(input), debugStepChan, <span style=color:#099>0</span>)  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>close</span>(debugStepChan)  
</span></span><span style=display:flex><span>   }()  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>var</span> debugSteps []debugStep  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> step <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> debugStepChan {  
</span></span><span style=display:flex><span>      debugSteps = <span style=color:#0086b3>append</span>(debugSteps, step)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> debugSteps  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Again, if you&rsquo;re not familiar with Go <code>channels</code> this might look odd, so let&rsquo;s step through it.</p><p>First, we create a runner and a new <code>chan debugStep</code></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>   testRunner <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewRunner</span>(m.fsm)  
</span></span><span style=display:flex><span>   debugStepChan <span style=color:#000;font-weight:700>:=</span> <span style=color:#0086b3>make</span>(<span style=color:#000;font-weight:700>chan</span> debugStep)
</span></span></code></pre></div><p>Then, we start a new <code>Go routine</code> which will call <code>match</code> and use our previously created channel. Once <code>match</code> has finished, the <code>channel</code> will be closed.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>   <span style=color:#000;font-weight:700>go</span> <span style=color:#000;font-weight:700>func</span>() {  
</span></span><span style=display:flex><span>      <span style=color:#900;font-weight:700>match</span>(testRunner, []<span style=color:#0086b3>rune</span>(input), debugStepChan, <span style=color:#099>0</span>)  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>close</span>(debugStepChan)  
</span></span><span style=display:flex><span>   }()  
</span></span></code></pre></div><p>Finally, we immediately start collecting the data sent to the channel and adding it to a slice. Once <code>match</code> has returned in the other <code>Go routine</code>, the <code>range</code> loop will terminate and we can return the slice.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>   <span style=color:#000;font-weight:700>var</span> debugSteps []debugStep  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> step <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> debugStepChan {  
</span></span><span style=display:flex><span>      debugSteps = <span style=color:#0086b3>append</span>(debugSteps, step)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> debugSteps 
</span></span></code></pre></div><p>That should be enough to get our tests passing!</p><h3 id=a-new-command>A new command</h3><p>We now want to be able to use this by calling something from the command line, as we did before. Let&rsquo;s modify our <code>main.go</code> file.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // main.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>// Main just used for linking up the main functionsfunc Main(args []string) {  
</span></span><span style=display:flex><span>   switch args[0] {  
</span></span><span style=display:flex><span>   case &#34;draw&#34;:  
</span></span><span style=display:flex><span>      if len(args) == 2 {  
</span></span><span style=display:flex><span>         RenderFSM(args[1])  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+     } else if len(args) == 3 {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+        RenderRunner(args[1], args[2])  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+     }  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   default:  
</span></span><span style=display:flex><span>      panic(&#34;command not recognized&#34;)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This means that if we call our method with a single string, such as <code>go run ./... v5 cat</code>, we display the compiled FSM for the regular expression <code>"cat"</code>, but if we call with two strings, such as <code>go run ./... v5 cat "I love cats"</code>, we get a representation of our algorithm for the regular expression <code>"cat"</code> being applied to the input string <code>"I love cats"</code>.</p><p>Let&rsquo;s implement <code>RenderRunner</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// main.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// RenderRunner will render every step of the runner until it fails or succeeds. The template will then take care// of hiding all but one of the steps to give the illusion of stepping through the input characters. It will  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// then output the result to the browser.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>RenderRunner</span>(regex, input <span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   data <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>buildRunnerTemplateData</span>(regex, input)  
</span></span><span style=display:flex><span>   htmlRunner <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>buildRunnerHTML</span>(data)  
</span></span><span style=display:flex><span>   <span style=color:#900;font-weight:700>outputToBrowser</span>(htmlRunner)  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>buildRunnerTemplateData</span>(regex <span style=color:#458;font-weight:700>string</span>, input <span style=color:#458;font-weight:700>string</span>) TemplateData {  
</span></span><span style=display:flex><span>   newMyRegex <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>NewMyRegex</span>(regex)  
</span></span><span style=display:flex><span>   debugSteps <span style=color:#000;font-weight:700>:=</span> newMyRegex.<span style=color:#900;font-weight:700>DebugMatch</span>(input)  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>var</span> steps []Step  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, step <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> debugSteps {  
</span></span><span style=display:flex><span>      steps = <span style=color:#0086b3>append</span>(steps, Step{  
</span></span><span style=display:flex><span>         Graph:      step.runnerDrawing,  
</span></span><span style=display:flex><span>         InputSplit: <span style=color:#900;font-weight:700>threeSplitString</span>(input, step.currentCharacterIndex),  
</span></span><span style=display:flex><span>      })  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   data <span style=color:#000;font-weight:700>:=</span> TemplateData{  
</span></span><span style=display:flex><span>      Steps: steps,  
</span></span><span style=display:flex><span>      Regex: regex,  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> data  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>buildRunnerHTML</span>(data TemplateData) <span style=color:#458;font-weight:700>string</span> {  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> <span style=color:#900;font-weight:700>renderWithTemplate</span>(runnerTemplate, data)  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// threeSplitString divides a string into three pieces on a given indexfunc threeSplitString(s string, i int) []string {  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>   <span style=color:#000;font-weight:700>var</span> left, middle, right <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   left = s[:i]  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> i &lt; <span style=color:#0086b3>len</span>(s) {  
</span></span><span style=display:flex><span>      middle = <span style=color:#0086b3>string</span>(s[i])  
</span></span><span style=display:flex><span>      right = s[i<span style=color:#000;font-weight:700>+</span><span style=color:#099>1</span>:]  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> []<span style=color:#458;font-weight:700>string</span>{left, middle, right}  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All we&rsquo;re doing here is parsing the <code>debugSteps</code> from <code>DebugMatch</code> into data structures which our templates know what to do with. This includes breaking the input string into three pieces so that we can render the characters before the current character, the current character, and remaining characters in different ways.</p><p>To make this work, we just need a few template data structures, as well as the template itself, which also be found on <a href=https://github.com/LeweyM/search/blob/c31ebe6066a6cabd74ef2afadaee20a81a875d2a/src/v5/templates.go#L26-L99>github</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// templates.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> TemplateData <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   Steps []Step  
</span></span><span style=display:flex><span>   Regex <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   Input <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Step <span style=color:#000;font-weight:700>struct</span> {  
</span></span><span style=display:flex><span>   Graph      <span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>   InputSplit []<span style=color:#458;font-weight:700>string</span>  
</span></span><span style=display:flex><span>}  
</span></span></code></pre></div><p>Again, I won&rsquo;t explain this because it&rsquo;s nasty Javascript and it&rsquo;s not too interesting. Let&rsquo;s just try it out and see what happens!</p><script>function loadIFrame(e,t){let n=document.getElementById(t);if(n.src==="about:blank"){e.firstElementChild.style="visibility:hidden",e.innerHTML+=`
<span class="sr-only">Loading...</span>
<span class="spinner-border spinner-border-sm position-absolute" style="left:50%;top:50%;translate:-50% -50%" role="status" aria-hidden="true"></span>
`,n.style.visibility="hidden",n.style.display="block",n.src=t;const s=n.onload.bind(n);n.onload=()=>{s(),e.remove(),n.style.visibility="unset"}}}</script><figure><button class="btn btn-primary position-relative" type=button onclick='loadIFrame(this,"/html/e7f3dc672824a71d4b9995391b558f01.html")'>
<span>load</span></button>
<iframe src=about:blank id=/html/e7f3dc672824a71d4b9995391b558f01.html class=w-100 style=display:none onload=resizeIFrameToFitContent(this)></iframe><figcaption class="font-italic p-2"><span><code>v5 draw "abc" "abc"</code></span></figcaption></figure><p><img src=/img/abc-regex-demo.gif alt=abc-regex-demo.gif></p><p>Nice! The underlined character shows which character we&rsquo;re going to process next, and the letters in red are those already processed. The state in red shows the active state at any given moment.</p><p>So, we can look at the red state, ask ourselves &ldquo;is there a transition which matches the character that&rsquo;s about to be processed?&rdquo;, and then we can predict which state will be active next!</p><p>Let&rsquo;s try another example.</p><script>function loadIFrame(e,t){let n=document.getElementById(t);if(n.src==="about:blank"){e.firstElementChild.style="visibility:hidden",e.innerHTML+=`
<span class="sr-only">Loading...</span>
<span class="spinner-border spinner-border-sm position-absolute" style="left:50%;top:50%;translate:-50% -50%" role="status" aria-hidden="true"></span>
`,n.style.visibility="hidden",n.style.display="block",n.src=t;const s=n.onload.bind(n);n.onload=()=>{s(),e.remove(),n.style.visibility="unset"}}}</script><figure><button class="btn btn-primary position-relative" type=button onclick='loadIFrame(this,"/html/d9eae559dbbe94884d6f6314cb66ce74.html")'>
<span>load</span></button>
<iframe src=about:blank id=/html/d9eae559dbbe94884d6f6314cb66ce74.html class=w-100 style=display:none onload=resizeIFrameToFitContent(this)></iframe><figcaption class="font-italic p-2"><span><code>v5 draw "cat" "I love cats"</code></span></figcaption></figure><p><img src=/img/i-love-cats-regex-demo-fast.gif alt=i-love-cats-regex-demo-fast.gif></p><p>We can see that most of the characters make our FSM fail immediately. We know that the <code>runner</code> has failed because there is no active state for one step. It&rsquo;s at this point that our algorithm resets the runner and starts the search again from the next substring.</p><p>It&rsquo;s only until we reach the <code>cats</code> substring that we begin to start matching <code>States</code> and can finally progress to the final end state and declare the match a success.</p><p>Let&rsquo;s take a look at one more example, this time with the regular expression <code>aab</code> with the input search string <code>"aaaab"</code></p><script>function loadIFrame(e,t){let n=document.getElementById(t);if(n.src==="about:blank"){e.firstElementChild.style="visibility:hidden",e.innerHTML+=`
<span class="sr-only">Loading...</span>
<span class="spinner-border spinner-border-sm position-absolute" style="left:50%;top:50%;translate:-50% -50%" role="status" aria-hidden="true"></span>
`,n.style.visibility="hidden",n.style.display="block",n.src=t;const s=n.onload.bind(n);n.onload=()=>{s(),e.remove(),n.style.visibility="unset"}}}</script><figure><button class="btn btn-primary position-relative" type=button onclick='loadIFrame(this,"/html/9f22c0249c3a870b51b2c781a1fbb1b7.html")'>
<span>load</span></button>
<iframe src=about:blank id=/html/9f22c0249c3a870b51b2c781a1fbb1b7.html class=w-100 style=display:none onload=resizeIFrameToFitContent(this)></iframe><figcaption class="font-italic p-2"><span><code>v5 draw "aab" "aaaab"</code></span></figcaption></figure><p><img src=/img/backtracking-regex-demo.gif alt=backtracking-regex-demo.gif></p><p>Notice what happens when we get from <code>State 0</code> to <code>State 2</code> and then fail? We have to go back a few steps in our input search string in order to search for other potential matches. This is called &lsquo;backtracking&rsquo;. It&rsquo;s the result of the recursion in our <code>match()</code> function, and it has serious performance implications for regex/search string combinations such as these. In these cases we have to backtrack the length of the regex on every failure. Not ideal.</p><p>I invite you to play around with different combinations and see what you can find. I found that this was of vizualising the algorithms we&rsquo;re using was very helpful in internalizing the characteristics. This becomes especially useful when our FSMs become more complex.</p><p>Before we finish here, I want to add one more command to save the generated HTML to a file. We&rsquo;ll call this command <code>out</code>.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // main.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>// Main just used for linking up the main functions
</span></span><span style=display:flex><span>func Main(args []string) {  
</span></span><span style=display:flex><span>   switch args[0] {  
</span></span><span style=display:flex><span>   case &#34;draw&#34;:  
</span></span><span style=display:flex><span>      if len(args) == 2 {  
</span></span><span style=display:flex><span>         RenderFSM(args[1])  
</span></span><span style=display:flex><span>      } else if len(args) == 3 {  
</span></span><span style=display:flex><span>         RenderRunner(args[1], args[2])  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+   case &#34;out&#34;:  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+      if len(args) == 4 {  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+         OutputRunnerToFile(args[1], args[2], args[3])  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+      }  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   default:  
</span></span><span style=display:flex><span>      panic(&#34;command not recognized&#34;)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And a couple of functions to implement the file writing functionality.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// OutputRunnerToFile will render every step of the runner, the same as RenderRunner, and then write the html to  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic>// a file.  
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>OutputRunnerToFile</span>(regex, input, filePath <span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   data <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>buildRunnerTemplateData</span>(regex, input)  
</span></span><span style=display:flex><span>   htmlRunner <span style=color:#000;font-weight:700>:=</span> <span style=color:#900;font-weight:700>buildRunnerHTML</span>(data)  
</span></span><span style=display:flex><span>   <span style=color:#900;font-weight:700>outputToFile</span>(htmlRunner, filePath)  
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>outputToFile</span>(html, path <span style=color:#458;font-weight:700>string</span>) {  
</span></span><span style=display:flex><span>   containingDir <span style=color:#000;font-weight:700>:=</span> filepath.<span style=color:#900;font-weight:700>Dir</span>(path)  
</span></span><span style=display:flex><span>   err <span style=color:#000;font-weight:700>:=</span> os.<span style=color:#900;font-weight:700>MkdirAll</span>(containingDir, <span style=color:#099>0750</span>)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(err)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> filepath.<span style=color:#900;font-weight:700>Ext</span>(path) <span style=color:#000;font-weight:700>==</span> <span style=color:#d14>&#34;&#34;</span> {  
</span></span><span style=display:flex><span>      path <span style=color:#000;font-weight:700>+=</span> <span style=color:#d14>&#34;.html&#34;</span>  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> filepath.<span style=color:#900;font-weight:700>Ext</span>(path) <span style=color:#000;font-weight:700>!=</span> <span style=color:#d14>&#34;.html&#34;</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(<span style=color:#d14>&#34;only .html extension permitted&#34;</span>)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   err = os.<span style=color:#900;font-weight:700>WriteFile</span>(path, []<span style=color:#0086b3>byte</span>(html), <span style=color:#099>0750</span>)  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>if</span> err <span style=color:#000;font-weight:700>!=</span> <span style=color:#000;font-weight:700>nil</span> {  
</span></span><span style=display:flex><span>      <span style=color:#0086b3>panic</span>(err)  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s enough of visualisations for now, let&rsquo;s move onto adding new features to our regex engine.</p><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v5>here</a></p></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This feels pretty clunky. I would have preferred a dynamic type which implements an interface, but interface fields on structs also have problems implementing the <code>comparable</code> interface. So far, generics are still tricky to make work in Go, but it&rsquo;s still early days.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>I prefer some misdirection between the main function in order to strip away unnecessary command arguments. You might prefer to simply call <code>Draw</code> from the <code>main</code> package.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>If for some reason you&rsquo;re interested in the hacky javascript involved in this, take a look at the <code>templates.go</code> file in <a href=https://github.com/LeweyM/search/blob/master/src/v5/templates.go>github</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>This is actually the command I use to generate the HTML used in the demos in this very blog!&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p>Previous: <a href=/series/making-regex-from-scratch-in-go/05-wildcards/>05 Wildcards</a><span class=meta></span></p><p>Next: <a href=/series/making-regex-from-scratch-in-go/07-branches/>07 Branches</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>mermaid.initialize({startOnLoad:!0})</script></body></html>