<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>05 Wildcards - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="05 Wildcards"><meta property="og:description" content="Let&rsquo;s start adding some special regex characters, starting with the '.' wildcard regular expression.
Wildcards The . character in a regular expression will match any character. To make this clear, here are a few example cases for the regular expression ab.;
abc -> success ab -> normal So, let&rsquo;s add these as test cases in our code.
@@ // fsm_test.go {&#34;nested expressions&#34;, &#34;a(b(d))c&#34;, &#34;abdc&#34;}, {&#34;substring match with reset needed&#34;, &#34;aA&#34;, &#34;aaA&#34;}, {&#34;substring match without reset needed&#34;, &#34;B&#34;, &#34;ABA&#34;}, {&#34;multibyte characters&#34;, &#34;Ȥ&#34;, &#34;Ȥ&#34;}, { &#34;complex multibyte characters&#34;, string([]byte{0xef, 0xbf, 0xbd, 0x30}), string([]byte{0xcc, 0x87, 0x30}), }, + // wildcard + {&#34;wildcard regex matching&#34;, &#34;ab."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/05-wildcards/"><meta property="article:section" content="series"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/01-intro/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/02-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/03-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="05 Wildcards"><meta name=twitter:description content="Let&rsquo;s start adding some special regex characters, starting with the '.' wildcard regular expression.
Wildcards The . character in a regular expression will match any character. To make this clear, here are a few example cases for the regular expression ab.;
abc -> success ab -> normal So, let&rsquo;s add these as test cases in our code.
@@ // fsm_test.go {&#34;nested expressions&#34;, &#34;a(b(d))c&#34;, &#34;abdc&#34;}, {&#34;substring match with reset needed&#34;, &#34;aA&#34;, &#34;aaA&#34;}, {&#34;substring match without reset needed&#34;, &#34;B&#34;, &#34;ABA&#34;}, {&#34;multibyte characters&#34;, &#34;Ȥ&#34;, &#34;Ȥ&#34;}, { &#34;complex multibyte characters&#34;, string([]byte{0xef, 0xbf, 0xbd, 0x30}), string([]byte{0xcc, 0x87, 0x30}), }, + // wildcard + {&#34;wildcard regex matching&#34;, &#34;ab."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/bootstrap.css><link src=https://leweym.github.io/js/bootstrap.bundle.js><script src=https://leweym.github.io/js/main.js></script>
<script type=application/javascript>function resizeIFrameToFitContent(e){e.width=e.contentWindow.document.body.scrollWidth,e.height=e.contentWindow.document.body.scrollHeight}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6FPTHJ5QN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6FPTHJ5QN")</script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/series/making-regex-from-scratch-in-go/01-intro/>01 Intro</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/02-getting-into-some-code/>02 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/03-starting-the-compiler/>03 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/>04 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><span>05 Wildcards</span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/>06 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/07-branches/>07 Branches</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/08-epsilons/>08 Epsilons</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/09-groups/>09 Groups</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/10-modifiers/>10 Modifiers</a> <span class=meta></span></div></div></div><br><div class=post-header><h1 class=title>05 Wildcards</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#wildcards>Wildcards</a></li></ul></nav></aside><div class=markdown><p>Let&rsquo;s start adding some special regex characters, starting with the <code>'.'</code> wildcard regular expression.</p><h2 id=wildcards>Wildcards</h2><p>The <code>.</code> character in a regular expression will match any character. To make this clear, here are a few example cases for the regular expression <code>ab.</code>;</p><ul><li><code>abc</code> -> <code>success</code></li><li><code>ab</code> -> <code>normal</code></li></ul><p>So, let&rsquo;s add these as test cases in our code.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>                {&#34;nested expressions&#34;, &#34;a(b(d))c&#34;, &#34;abdc&#34;},
</span></span><span style=display:flex><span>                {&#34;substring match with reset needed&#34;, &#34;aA&#34;, &#34;aaA&#34;},
</span></span><span style=display:flex><span>                {&#34;substring match without reset needed&#34;, &#34;B&#34;, &#34;ABA&#34;},
</span></span><span style=display:flex><span>                {&#34;multibyte characters&#34;, &#34;Ȥ&#34;, &#34;Ȥ&#34;},
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                        &#34;complex multibyte characters&#34;,
</span></span><span style=display:flex><span>                        string([]byte{0xef, 0xbf, 0xbd, 0x30}),
</span></span><span style=display:flex><span>                        string([]byte{0xcc, 0x87, 0x30}),
</span></span><span style=display:flex><span>                },
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               // wildcard
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;wildcard regex matching&#34;, &#34;ab.&#34;, &#34;abc&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;wildcard regex not matching&#34;, &#34;ab.&#34;, &#34;ab&#34;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span></code></pre></div><p>We should get one failing test.</p><div class="notices info"><p>Why only one? Well, this is just us getting lucky. Our current implementation doesn&rsquo;t recognize the <code>.</code> character, so it treats the regex as though it were <code>ab</code>. This means that the input string <code>abc</code> correctly matches the regex <code>ab</code>, but we incorrectly match the input string <code>ab</code> - which should require another character to fulfil the regex <code>ab.</code>.</p></div><p>As we already tokenize the <code>.</code> character in our lexer, we can move directly to the parser. Let&rsquo;s create a new <code>AST</code> node type to represent our wildcard.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> type CharacterLiteral struct {
</span></span><span style=display:flex><span>        Character rune
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> func (g *Group) Append(node Node) {
</span></span><span style=display:flex><span>        g.ChildNodes = append(g.ChildNodes, node)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+type WildcardLiteral struct{}
</span></span></span></code></pre></div><p>Before we implement the parser logic, let&rsquo;s add a case for it to our parser tests.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>        tests := []test{
</span></span><span style=display:flex><span>                {name: &#34;simple string&#34;, input: &#34;aBc&#34;, expectedResult: &amp;Group{
</span></span><span style=display:flex><span>                        ChildNodes: []Node{
</span></span><span style=display:flex><span>                                CharacterLiteral{Character: &#39;a&#39;},
</span></span><span style=display:flex><span>                                CharacterLiteral{Character: &#39;B&#39;},
</span></span><span style=display:flex><span>                                CharacterLiteral{Character: &#39;c&#39;},
</span></span><span style=display:flex><span>                        },
</span></span><span style=display:flex><span>                }},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {name: &#34;wildcard character&#34;, input: &#34;ab.&#34;, expectedResult: &amp;Group{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       ChildNodes: []Node{
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               CharacterLiteral{Character: &#39;a&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               CharacterLiteral{Character: &#39;b&#39;},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                               WildcardLiteral{},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+                       },
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               }},
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        }
</span></span></code></pre></div><p>The implementation should be quite similar to the <code>CharacterLiteral</code> parser implementation.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // parser.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (p *Parser) Parse() Node {  
</span></span><span style=display:flex><span>   root := Group{}  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   for _, t := range p.tokens {  
</span></span><span style=display:flex><span>       switch t.symbol {  
</span></span><span style=display:flex><span>       case Character:  
</span></span><span style=display:flex><span>          root.Append(CharacterLiteral{Character: t.letter})  
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+      case AnyCharacter:  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+         root.Append(WildcardLiteral{})  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+      }  
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>   }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>   return &amp;root  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With our parser tests green again, we can implement the <code>compile</code> method. This will also be quite similar to the <code>CharacterLiteral</code>. The only difference is that the <code>WildcardLiteral</code> predicate will return <code>true</code> for every rune.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span> 
</span></span><span style=display:flex><span> func (l CharacterLiteral) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startingState := State{}
</span></span><span style=display:flex><span>        endState := State{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        startingState.addTransition(&amp;endState, func(input rune) bool { return input == l.Character })
</span></span><span style=display:flex><span>        return &amp;startingState, &amp;endState
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+func (w WildcardLiteral) compile() (head *State, tail *State) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       startingState := State{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       endState := State{}
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       startingState.addTransition(&amp;endState, func(input rune) bool { return true })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       return &amp;startingState, &amp;endState
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+}
</span></span></span></code></pre></div><p>And that&rsquo;s all there is to it! All of our tests should now be green, and we can now parse and match using wildcard characters!</p><p>The only thing left to do is to remove our filter of <code>.</code> characters in our fuzz tests and to check that the fuzzer can&rsquo;t find any breaking inputs.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> func FuzzFSM(f *testing.F) {
</span></span><span style=display:flex><span>        f.Add(&#34;abc&#34;, &#34;abc&#34;)
</span></span><span style=display:flex><span>        f.Add(&#34;abc&#34;, &#34;&#34;)
</span></span><span style=display:flex><span>        f.Add(&#34;abc&#34;, &#34;xxx&#34;)
</span></span><span style=display:flex><span>        f.Add(&#34;ca(t)(s)&#34;, &#34;dog&#34;)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>        f.Fuzz(func(t *testing.T, regex, input string) {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               if strings.ContainsAny(regex, &#34;[]{}$^|*+?.\\&#34;) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+               if strings.ContainsAny(regex, &#34;[]{}$^|*+?\\&#34;) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                        t.Skip()
</span></span><span style=display:flex><span>                }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>➜ go <span style=color:#0086b3>test</span> ./src/v4/... -fuzz ^FuzzFSM$  
</span></span></code></pre></div><p>We found one&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zsh data-lang=zsh><span style=display:flex><span>v4_test.go:126: Mismatch - 
</span></span><span style=display:flex><span>	Regex: <span style=color:#d14>&#39;..0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 2e2e30<span style=color:#000;font-weight:700>)</span>, 
</span></span><span style=display:flex><span>	Input: <span style=color:#d14>&#39;0
</span></span></span><span style=display:flex><span><span style=color:#d14>	0&#39;</span> <span style=color:#000;font-weight:700>(</span>as bytes: 300a30<span style=color:#000;font-weight:700>)</span> 
</span></span><span style=display:flex><span>	-&gt; 
</span></span><span style=display:flex><span>	Go Regex Pkg: <span style=color:#d14>&#39;false&#39;</span>, 
</span></span><span style=display:flex><span>	Our regex result: <span style=color:#d14>&#39;true&#39;</span>
</span></span></code></pre></div><p>Again, our fuzzer has uncovered some very interesting behavior of regular expression implementations.</p><p>To make clearer what&rsquo;s going on here, let&rsquo;s add a test.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // fsm_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>                // wildcard
</span></span><span style=display:flex><span>                {&#34;wildcard regex matching&#34;, &#34;ab.&#34;, &#34;abc&#34;},
</span></span><span style=display:flex><span>                {&#34;wildcard regex not matching&#34;, &#34;ab.&#34;, &#34;ab&#34;},
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               {&#34;wildcards matching newlines&#34;, &#34;..0&#34;, &#34;0\n0&#34;},
</span></span></span></code></pre></div><p>We can see here that the <code>.</code> wildcard character is matching against the newline character <code>\n</code>. In the go regex package, <a href="https://www.regular-expressions.info/dot.html#:~:text=The%20dot%20matches%20a%20single%20character%2C%20without%20caring%20what%20that%20character%20is.%20The%20only%20exception%20are%20line%20break%20characters.%20In%20all%20regex%20flavors%20discussed%20in%20this%20tutorial%2C%20the%20dot%20does%20not%20match%20line%20breaks%20by%20default.">and in most regex flavors</a>, the <code>.</code> wildcard does not match the <code>\n</code>. This is mainly to avoid common misuse of queries such as <code>.*</code> which would otherwise search indefinitely throughout the search input, instead of just limiting the search space to a single line.</p><p>This can actually be disabled in most regex flavors with the <code>singleline</code> option, although this is disabled by default.</p><p>The fix is simple.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // ast.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func (w WildcardLiteral) compile() (head *State, tail *State) {
</span></span><span style=display:flex><span>        startingState := State{}
</span></span><span style=display:flex><span>        endState := State{}
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       startingState.addTransition(&amp;endState, func(input rune) bool { return true })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       startingState.addTransition(&amp;endState, func(input rune) bool { return input != &#39;\n&#39; })
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return &amp;startingState, &amp;endState
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>Tests are green again, our fuzzer whizzes along for a few minutes without any complaints, and we&rsquo;ve learned a bit more about regular expressions. Not bad!</p><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v4>here</a></p></div></div><p>Previous: <a href=/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/>04 Testing, Fuzzing, and fixing things</a><span class=meta></span></p><p>Next: <a href=/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/>06 Pretty Vizualizations</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div></body></html>