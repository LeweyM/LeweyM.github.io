<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>11 Reducing Epsilon NFA to NFA - Lewis Metcalf</title><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="11 Reducing Epsilon NFA to NFA"><meta property="og:description" content="Reducing Epsilon NFA to NFA Having spent so long building up state machines using epsilon transitions, it now seems slightly perverse that we&rsquo;re going to spend this chapter ripping them out! However, we&rsquo;re still going to use them to compose our regular expression FSMs. The idea is to compose using epsilons, because it&rsquo;s easier, and then reduce the epsilon-NFA to a normal NFA.
The benefits of doing so are mainly for performance, although we haven&rsquo;t been particularly performance conscious up until now, and there are plenty of optimisations we could make before this one."><meta property="og:type" content="article"><meta property="og:url" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/11-reducing-epsilon-nfa-to-nfa/"><meta property="article:section" content="series"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/01-intro/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/02-getting-into-some-code/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/03-starting-the-compiler/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/05-wildcards/"><meta property="og:see_also" content="https://leweym.github.io/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/"><meta name=twitter:card content="summary"><meta name=twitter:title content="11 Reducing Epsilon NFA to NFA"><meta name=twitter:description content="Reducing Epsilon NFA to NFA Having spent so long building up state machines using epsilon transitions, it now seems slightly perverse that we&rsquo;re going to spend this chapter ripping them out! However, we&rsquo;re still going to use them to compose our regular expression FSMs. The idea is to compose using epsilons, because it&rsquo;s easier, and then reduce the epsilon-NFA to a normal NFA.
The benefits of doing so are mainly for performance, although we haven&rsquo;t been particularly performance conscious up until now, and there are plenty of optimisations we could make before this one."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link href=/css/fontawesome-all.min.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/notice.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/main.css><link rel=stylesheet type=text/css media=screen href=https://leweym.github.io/css/bootstrap.css><link src=https://leweym.github.io/js/bootstrap.bundle.js><script src=https://leweym.github.io/js/main.js></script>
<script type=application/javascript>function resizeIFrameToFitContent(e){e.width=e.contentWindow.document.body.scrollWidth,e.height=e.contentWindow.document.body.scrollHeight}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q6FPTHJ5QN"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Q6FPTHJ5QN")</script></head><body><div class="container wrapper post"><div class=header><h1 class=site-title><a href=https://leweym.github.io/>Lewis Metcalf</a></h1><div class=site-description><nav class="nav social"><ul class=flat></ul></nav></div><nav class=nav><ul class=flat></ul></nav></div><div class=post-header><h1 class=title>Making regex from scratch in go</h1></div><div class=section><div class=posts><div class=post><a href=/series/making-regex-from-scratch-in-go/01-intro/>01 Intro</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/02-getting-into-some-code/>02 Getting into some code</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/03-starting-the-compiler/>03 Starting the compiler</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/04-testing-fuzzing-and-fixing-things/>04 Testing, Fuzzing, and fixing things</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/05-wildcards/>05 Wildcards</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/06-pretty-vizualizations/>06 Pretty Vizualizations</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/07-branches/>07 Branches</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/08-epsilons/>08 Epsilons</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/09-groups/>09 Groups</a> <span class=meta></span></div><div class=post><a href=/series/making-regex-from-scratch-in-go/10-modifiers/>10 Modifiers</a> <span class=meta></span></div><div class=post><span>11 Reducing Epsilon NFA to NFA</span></div></div></div><br><div class=post-header><h1 class=title>11 Reducing Epsilon NFA to NFA</h1><div class=meta></div></div><aside><nav id=TableOfContents><ul><li><a href=#reducing-epsilon-nfa-to-nfa>Reducing Epsilon NFA to NFA</a></li><li><a href=#some-preparatory-code-changes>Some preparatory code changes</a></li><li><a href=#adding-flags-to-our-command-line-tool>Adding flags to our command line tool</a></li><li><a href=#reducers>Reducers</a></li></ul></nav></aside><div class=markdown><h2 id=reducing-epsilon-nfa-to-nfa>Reducing Epsilon NFA to NFA</h2><p>Having spent so long building up state machines using epsilon transitions, it now seems slightly perverse that we&rsquo;re going to spend this chapter ripping them out! However, we&rsquo;re still going to use them to compose our regular expression FSMs. The idea is to compose using epsilons, because it&rsquo;s easier, and then <strong>reduce</strong> the epsilon-NFA to a normal NFA.</p><p>The benefits of doing so are mainly for performance, although we haven&rsquo;t been particularly performance conscious up until now, and there are plenty of optimisations we could make before this one. The performance benefits come from not having to traverse the set of states connected by epsilons. One way of thinking of this optimisation is that we cache those set of states so that they don&rsquo;t have to be traversed every time.</p><h2 id=some-preparatory-code-changes>Some preparatory code changes</h2><p>Before we get stuck in, there are a few changes we have to make to our code.</p><p>First, it&rsquo;s finally time to give up our hack of using the last state as the success state. The technique we&rsquo;re going to use means that this is not true in all cases, so we need a way of keeping track of which states should be considered success states.</p><p>The simplest way I can think of is a flag on the <code>State</code> struct for this.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // state.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> type State struct {
</span></span><span style=display:flex><span>        transitions []Transition
</span></span><span style=display:flex><span>        epsilons    []*State
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       success     bool
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span></code></pre></div><p>This simplifies our <code>isSuccessState() bool</code> method, as we no longer need to check its transitions.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // state.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> func (s *State) isSuccessState() bool {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       if len(s.transitions) == 0 &amp;&amp; len(s.epsilons) == 0 {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-               return true
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-       return false
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+       return s.success
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span> }
</span></span></code></pre></div><p>And now we just need a simple method to turn a state into a success state.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// state.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> (s <span style=color:#000;font-weight:700>*</span>State) <span style=color:#900;font-weight:700>SetSuccess</span>() {
</span></span><span style=display:flex><span>    s.success = <span style=color:#000;font-weight:700>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now let&rsquo;s use our new setter method. We&rsquo;ll need it in our <code>myRegex</code> struct, and also in our <code>draw_test</code> methods.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // regex.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func NewMyRegex(re string) *myRegex {
</span></span><span style=display:flex><span>        tokens := lex(re)
</span></span><span style=display:flex><span>        parser := NewParser(tokens)
</span></span><span style=display:flex><span>        ast := parser.Parse()
</span></span><span style=display:flex><span>        state, _ := ast.compile()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       endState.SetSuccess()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>
</span></span><span style=display:flex><span>        return &amp;myRegex{fsm: state}
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // draw_test.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span>func abcBuilder() *State {
</span></span><span style=display:flex><span>        state1.addTransition(state2, Predicate{allowedChars: &#34;a&#34;}, &#34;a&#34;)
</span></span><span style=display:flex><span>        state2.addTransition(state3, Predicate{allowedChars: &#34;b&#34;}, &#34;b&#34;)
</span></span><span style=display:flex><span>        state3.addTransition(state4, Predicate{allowedChars: &#34;c&#34;}, &#34;c&#34;)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       state4.SetSuccess()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return state1
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func aaaBuilder() *State {
</span></span><span style=display:flex><span>        state1.addTransition(state2, Predicate{allowedChars: &#34;a&#34;}, &#34;a&#34;)
</span></span><span style=display:flex><span>        state2.addTransition(state3, Predicate{allowedChars: &#34;a&#34;}, &#34;a&#34;)
</span></span><span style=display:flex><span>        state3.addTransition(state4, Predicate{allowedChars: &#34;a&#34;}, &#34;a&#34;)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       state4.SetSuccess()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return state1
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func aεbBuilder() *State {
</span></span><span style=display:flex><span>        state1.addTransition(state2, Predicate{allowedChars: &#34;a&#34;}, &#34;a&#34;)
</span></span><span style=display:flex><span>        state2.addEpsilon(state3)
</span></span><span style=display:flex><span>        state3.addTransition(state4, Predicate{allowedChars: &#34;b&#34;}, &#34;b&#34;)
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       state4.SetSuccess()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return state1
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>Lovely, everything should be green again!</p><h2 id=adding-flags-to-our-command-line-tool>Adding flags to our command line tool</h2><p>We want the ability to apply flag arguments to our commands. Flag arguments are prefixed with <code>--</code> and they can be used in any order. This is unlike arguments we&rsquo;ve used until now, which have a fixed order. For example, in the command <code>draw "abc" "a"</code>, the arguments <code>draw</code>, <code>"abc"</code>, and <code>"a"</code> are all defined by their order. We could also describe the command as <code>{command} {regex} {search-string}</code>.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>Let&rsquo;s add a data structure for flags.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// main.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> CmdFlag <span style=color:#458;font-weight:700>string</span>
</span></span></code></pre></div><p>This should be enough for now. We just need a set of <code>CmdFlags</code>, which are a special type built on top of simple <code>strings</code>. The only flag we&rsquo;ll need now is the one which enabled epsilon reduction, so let&rsquo;s add that.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// main.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>const</span> reduceEpsilon CmdFlag = <span style=color:#d14>&#34;reduce-epsilon&#34;</span>
</span></span></code></pre></div><p>Now let&rsquo;s add these to our main function.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // main.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span> // Main just used for linking up the main functions
</span></span><span style=display:flex><span> func Main(args []string) {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       args, flags := parseArgumentsAndFlags(args)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        switch args[0] {
</span></span><span style=display:flex><span>        case &#34;draw&#34;:
</span></span><span style=display:flex><span>                if len(args) == 2 {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       RenderFSM(args[1])
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       RenderFSM(args[1], flags)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                } else if len(args) == 3 {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       RenderRunner(args[1], args[2])
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       RenderRunner(args[1], args[2], flags)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                }
</span></span><span style=display:flex><span>        case &#34;out&#34;:
</span></span><span style=display:flex><span>                if len(args) == 4 {
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-                       OutputRunnerToFile(args[1], args[2], args[3])
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+                       OutputRunnerToFile(args[1], args[2], args[3], flags)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>                }
</span></span><span style=display:flex><span>        default:
</span></span><span style=display:flex><span>                panic(&#34;command not recognized&#34;)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> // RenderFSM will render just the finite state machine, and output the result to the browser
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-func RenderFSM(input string) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+func RenderFSM(input string, flags Set[CmdFlag]) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        graph := NewMyRegex(input).DebugFSM()
</span></span><span style=display:flex><span>        html := buildFsmHtml(graph)
</span></span><span style=display:flex><span>        outputToBrowser(html)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> // RenderRunner will render every step of the runner until it fails or succeeds. The template will then take care
</span></span><span style=display:flex><span> // of hiding all but one of the steps to give the illusion of stepping through the input characters. It will
</span></span><span style=display:flex><span> // then output the result to the browser.
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-func RenderRunner(regex, input string) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+func RenderRunner(regex, input string, flags Set[CmdFlag]) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        htmlRunner := buildRunnerHTML(data)
</span></span><span style=display:flex><span>        outputToBrowser(htmlRunner)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> // OutputRunnerToFile will render every step of the runner, the same as RenderRunner, and then write the html to
</span></span><span style=display:flex><span> // a file.
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-func OutputRunnerToFile(regex, input, filePath string) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+func OutputRunnerToFile(regex, input, filePath string, flags Set[CmdFlag]) {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        data := buildRunnerTemplateData(regex, input)
</span></span><span style=display:flex><span>        htmlRunner := buildRunnerHTML(data)
</span></span><span style=display:flex><span>        outputToFile(htmlRunner, filePath)
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><p>Here, we&rsquo;re simply passing the <code>flags</code> variable, which is of type <code>Set[CmdFlag]</code>, to our three output functions, <code>RenderFSM</code>, <code>RenderRunner</code>, and <code>OutputRunnerToFile</code>. Currently, we do nothing with it (we&rsquo;ll fix that later).</p><p>The <code>flags</code> variable comes from the <code>parseArgumentsAndFlags(args)</code> method. Let&rsquo;s implement that now.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// main.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>func</span> <span style=color:#900;font-weight:700>parseArgumentsAndFlags</span>(args []<span style=color:#458;font-weight:700>string</span>) ([]<span style=color:#458;font-weight:700>string</span>, Set[CmdFlag]) {  
</span></span><span style=display:flex><span>   flagSet <span style=color:#000;font-weight:700>:=</span> NewSet[CmdFlag]()  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>var</span> arguments = []<span style=color:#458;font-weight:700>string</span>{}  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>for</span> _, arg <span style=color:#000;font-weight:700>:=</span> <span style=color:#000;font-weight:700>range</span> args {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>switch</span> arg {  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>case</span> <span style=color:#d14>&#34;--reduce-epsilons&#34;</span>:  
</span></span><span style=display:flex><span>         flagSet.<span style=color:#900;font-weight:700>add</span>(reduceEpsilon)  
</span></span><span style=display:flex><span>      <span style=color:#000;font-weight:700>default</span>:  
</span></span><span style=display:flex><span>         <span style=color:#000;font-weight:700>if</span> strings.<span style=color:#900;font-weight:700>HasPrefix</span>(arg, <span style=color:#d14>&#34;--&#34;</span>) {  
</span></span><span style=display:flex><span>            <span style=color:#0086b3>panic</span>(fmt.<span style=color:#900;font-weight:700>Sprintf</span>(<span style=color:#d14>&#34;flag &#39;%s&#39; not recognized&#34;</span>, arg))  
</span></span><span style=display:flex><span>         }  
</span></span><span style=display:flex><span>         arguments = <span style=color:#0086b3>append</span>(arguments, arg)  
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>   }  
</span></span><span style=display:flex><span>   <span style=color:#000;font-weight:700>return</span> arguments, flagSet  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is simple enough. We add any flag arguments to our <code>flagSet</code>, other arguments are appended to the list of normal arguments, and if we receive any <code>--</code> flags which we don&rsquo;t recognise, we panic. This is where we&rsquo;ll add any other flags we want to introduce to our system.</p><p>Now we&rsquo;re ready to add to start reducing.</p><h2 id=reducers>Reducers</h2><p>We&rsquo;re going to add a new concept to our program; a <strong>Reducer</strong>. A Reducer is an object which takes an FSM and modifies it. The modified FSM will have been reduced in some way which is opaque to the outside - our components will know how to use a reducer, but not how it works.</p><p>We can implement this as an interface. <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#998;font-style:italic>// regex.go
</span></span></span><span style=display:flex><span><span style=color:#998;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#000;font-weight:700>type</span> Reducer <span style=color:#000;font-weight:700>interface</span> {  
</span></span><span style=display:flex><span>   <span style=color:#900;font-weight:700>reduce</span>(s <span style=color:#000;font-weight:700>*</span>State)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We now simply have to apply one or more Reducer to our FSM.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#aaa>@@ // regex.go
</span></span></span><span style=display:flex><span><span style=color:#aaa></span>
</span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd>-func NewMyRegex(re string) *myRegex {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#fdd></span><span style=color:#000;background-color:#dfd>+func NewMyRegex(re string, reducers ...Reducer) *myRegex {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        tokens := lex(re)
</span></span><span style=display:flex><span>        parser := NewParser(tokens)
</span></span><span style=display:flex><span>        ast := parser.Parse()
</span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       state, endState := ast.compile()
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       for _, reducer := range reducers {
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+               reducer.reduce(state)
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+       }
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd>+
</span></span></span><span style=display:flex><span><span style=color:#000;background-color:#dfd></span>        return &amp;myRegex{fsm: state}
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><div class="notices tip"><p>Check out this part of the project on GitHub <a href=https://github.com/LeweyM/search/tree/master/src/v10>here</a></p></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Command line arguments which depend on the order are known as <strong>positional arguments</strong>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>In Go, unlike most languages which use interfaces, the interface is defined by the consumer, rather than the implementer. Because of this, I&rsquo;ve chosen to define this interface in the <code>regex.go</code> file. In the project repository, all of the examples are defined in the same package, so only one definition of the interface is required. If we were spreading our program across different packages, as most Go projects do, we would write this interface everywhere that it is consumed. Although this seems like unnecessary repetition, it&rsquo;s actually very useful, as it allows the consumer to only define the parts of the required object necessary to carry out its specific task. If the interface were centrally defined by the implementer, the consumer would be obliged to know everything about the whole interface.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><p>Previous: <a href=/series/making-regex-from-scratch-in-go/10-modifiers/>10 Modifiers</a><span class=meta></span></p><div class=post-tags></div></div><div class="footer wrapper"><nav class=nav><div><a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div></body></html>